\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the key features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Typed Racket and occurrence typing}

\citet{TF10}
presented Typed Racket with occurrence typing,
an inference technique for conditional control flow.
They introduce the concept of occurrence typing 
with the following example.

\inputminted[firstline=1]{racket}{code/tr/example1.rkt}

This function takes a value that is either \emph{\#f} % mintinline really hates #
or a number, represented by an untagged \emph{union type}.
The `then' branch has an implicit invariant
that \rkt{x} is a number, which is automatically inferred with occurrence typing
and type checked without further annotations.
Here is same program in Typed Clojure.

\begin{exmp}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\label{example:conditionalflow}
\end{exmp}

Clojure uses \emph{namespaces}, declared with the
\clj{ns} form, to manage top-level \emph{vars}.
This is a regular Clojure file compiled with
the Clojure compiler except it declares a runtime dependency on
\clj{clojure.core.typed}, Typed Clojure's core namespace.
Programmers import typed versions of certain constructs as needed, like
a \clj{fn} variant that supports annotations,
and use the provided \clj{check-ns} function to type check the current namespace
when convenient.

Typed Clojure can check all the examples in the occurrence typing
paper---the rest of this section describes the extensions necessary
to check Clojure code.

\subsection{Exceptional control flow}

Along with conditional control flow,
Clojure programmers rely on \emph{exceptions}
to assert type-related invariants.

\begin{exmp}
\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
\label{example:doexception}
\end{exmp}

We combine the sequencing form \clj{do} and a thrown exception with
\clj{throw} to avoid a null-pointer exception from attempting to increment \clj{nil}.
(We omit \clj{ns} forms for the rest of the examples)
\footnote{See <this> github repo for full working examples}.

To check this example, we note that
occurrence typing already provides
valuable information about the conditional expression---namely that it cannot return logically true and if it returns logically false 
then \clj{x} is a \clj{Number}. Equivalently, if it returns a value then \clj{x} is a \clj{Number}.
We use this assumption to check \clj{(inc x)} with an automatic
guarantee that a null-pointer exception is impossible
(modelled formally in section~\ref{sec:doformal} and proved
in section~\ref{sec:metatheory}).

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{Code}
\begin{exmp}
\inputminted[firstline=6,lastline=8]{clojure}{code/demo/src/demo/hmap.clj}
\inputminted[firstline=27,lastline=29]{clojure}{code/demo/src/demo/hmap.clj}
\end{exmp}
\end{Code}

Here we define a type abbreviation with \clj{defalias} called \clj{Expr}
that describes the structure of a recursively-defined AST as a union of HMaps.
\clj{an-exp} is a function verified to return an \clj{Expr}.

HMaps support various options to track the presence and absence of entries.
\clj{:mandatory} declares entries that must be present.

\begin{Code}
\begin{exmp}
\inputminted[firstline=58,lastline=64]{clojure}{code/demo/src/demo/hmap.clj}
\end{exmp}
\end{Code}
Looking up \clj{:a} simply returns the associated type \clj{Num}.
Keys other than \clj{:a} are unaccounted for in \clj{Mand}, so 
the best we can infer is \clj{Any}, the supertype of all types.
\clj{'{:a Num}} is shorthand for \clj{(HMap :mandatory {:a Num})}.

\clj{:absent-keys} is a set of keywords that are known to not have entries.
\begin{Code}
\begin{exmp}
\inputminted[firstline=66,lastline=73]{clojure}{code/demo/src/demo/hmap.clj}
\end{exmp}
\end{Code}
We can infer a better type for \clj{(:b m)}---\clj{:b} is absent in \clj{Abs}
so it looking up \clj{:b} returns \clj{nil}.

\clj{:optional} is a map that declares entries either absent \emph{or}
present with a specific type. 

\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=12]{clojure}{code/demo/src/demo/hmap_path.clj}
\end{exmp}
\end{Code}

Concretely \clj{(HMap :optional {:a Num})}
is the same as
\begin{minted}{clojure}
      (U '{:a Num} (HMap :absent-keys #{:a})).
\end{minted}


\clj{:complete?} is \clj{true} if there are no further entries
than those declared \clj{:mandatory} or \clj{:optional}.
\begin{Code}
\begin{exmp}
\inputminted[firstline=17,lastline=26]{clojure}{code/demo/src/demo/hmap_path.clj}
\end{exmp}
\end{Code}
\clj{:a} is \clj{:mandatory} in \clj{Comp} so lookups return \clj{Num}.
\clj{:b} is \clj{:optional} so lookups return \clj{(U nil Kw)}.
\clj{:c} is not mentioned, but since \clj{:complete?} is \clj{true}
it must be absent so a lookup returns \clj{nil}.

The next example is a real Typed Clojure program written by CircleCI, who maintain a large production
installation of Clojure (see section~\ref{sec:casestudy} for a case study).

\begin{Code}
\begin{exmp}
\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
\end{exmp}
\end{Code}

\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
removing the raw \clj{:private-key} entry and associating an encrypted private key
as \clj{:enc-private-key}.
Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
operation forgot to remove it.

HMaps interact with occurrence typing in interesting ways.
The next example branches on the result of a lookup, and the types
inferred for \clj{f} are subtle.

\begin{Code}
\begin{exmp}
\inputminted[firstline=14,lastline=15]{clojure}{code/demo/src/demo/hmap_path.clj}
\end{exmp}
\end{Code}

Typed Clojure infers \clj{m} as \clj{'{:a Num}} in the then branch
and \clj{(HMap :optional {:a nil})}
in the else branch.
We cannot infer 
\begin{minted}{clojure}
 (HMap :absent-keys #{:a})
\end{minted}
in the else branch because \clj{m} could be the value \clj{{:a nil}}
by the definiton of \clj{Opt}.
Section~\ref{sec:hmapformal} discusses this in greater detail.

\subsection{Java interoperability}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.
Method calls use prefix syntax, for example this call to 
\clj{java.io.File}'s \clj{getParent} method.

\begin{minted}{clj}
  (fn [f] (.getParent f))
\end{minted}

We have a problem: Clojure's compiler does not know which method to call.
Instead, \clj{f} is inspected at runtime and an appropriate method is selected based
and then invoked by \emph{Java reflection}.
Unfortunately, reflection is slow and Clojure's algorithm for
choosing methods at runtime is undefined in some cases.

To resolve reflective calls, Clojure supports \emph{type-hints}.

\begin{minted}{clj}
  (fn [^File f] (.getParent f))
\end{minted}

The Clojure compiler uses the type hint on \clj{f}
to statically resolve the method call to the \clj{java.io.File}
method with the Java signature

\begin{minted}{java}
  public String getParent()
\end{minted}

Typed Clojure ignores type-hints, so to check this we must
annotate the parameter's static type.

\begin{minted}{clj}
  (fn [f :- File] (.getParent f))
\end{minted}

However Typed Clojure disallows reflection in typed code, so we
must add a type hint.

\inputminted[firstline=10,lastline=10]{clojure}{code/demo/src/demo/parent3.clj}

Now we have a well-typed expression free of reflection.

Typed Clojure and Java treat \java{null} differently.
In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
This means the Java static type \java{String} is equivalent to
\clj{(U nil String)} in Typed Clojure.

To guarantee \java{null} is never accidentally leaked into a Typed Clojure program,
we must assume methods are nullable.

\begin{exmp}
\inputminted[firstline=12,lastline=13]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

In contrast, JVM invariants guarantee that  constructor cannot return \java{null},
so we are safe to assume constructors are non-nullable.

\begin{Code}
\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}
\end{Code}

Notice a type hint is used in an argument position to help choose the \java{File(String pathname)}
constructor. By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular positions if needed.

Finally, Typed Clojure guarantees typed code cannot throw a null-pointer exception
by attempting to dereference \clj{nil}. This can happen in several ways, including
calling a method or a field on \clj{nil}.
The next example calls a method on once-nullable local binding.
(\clj{ann} annotates a var with an expected type).

\begin{exmp}
\inputminted[firstline=5,lastline=8]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

The test on \clj{f} is essential to check this example---only then can Typed Clojure
prove null-pointer exceptions are impossible.

\subsection{Multimethods}

A multimethod in Clojure is a function that contains a dispatch
function and methods. Multimethods are created with {\clj{defmulti}}.
\begin{minted}{clojure}
(ann rep [Any -> String])
(defmulti rep class)
\end{minted}
\clj{rep} is a multimethod of type \clj{[Any -> String]} with an empty \emph{dispatch table}
and \emph{dispatch function} \clj{class}, a function that returns the argument's class or \clj{nil} if none.
There are no methods to dispatch to so invocations of \clj{rep} will fail at runtime.
\begin{minted}{clojure}
  (rep :a) ;=> IllegalArgumentException ...
\end{minted}

Methods are installed via {\clj{defmethod}}.
\begin{minted}{clojure}
(defmethod rep Keyword [x] (str (name x)))
\end{minted}
We extend \clj{rep}'s dispatch table, mapping
the \emph{dispatch value} \clj{Number} to the function
\clj{(fn [x] (str (name x)))}. The call \clj{(rep arg)}
uses the value of \clj{(isa? (disp-fn arg) disp-val)}
on each method entry to pick a winner \clj{mth}, and finally returns \clj{(mth arg)}.
\clj{isa?} is a subclassing check when provided with classes
\begin{minted}{clojure}
  (isa? Keyword Object) ;=> true
  (isa? Keyword Number) ;=> false
\end{minted}
otherwise an equality check.
\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? :a 1) ;=> false
\end{minted}

For example
\clj{(rep :a)}
picks the \clj{Keyword} method because
\clj{(isa? (class :a) Keyword)} returns true,
and finally returns \clj{"a"}, the value of
\clj{((fn [x] (str (name x))) :a)}.
We give the full definition of \clj{rep}.

\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=11]{clojure}{code/demo/src/demo/rep.clj}
\label{example:rep}
\end{exmp}
\end{Code}
Typed Clojure does not statically ensure multimethod calls dispatch successfully---
\clj{(rep "a")} type checks but throws a runtime error.

The flexibility of \clj{isa?} is key to the generality of multimethods. 
We can dispatch on the \clj{:op} key 
of our HMap AST \clj{Expr}.
Keywords are functions that look themselves up in their argument, so \clj{:op}
is our dispatch function.
\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=23]{clojure}{code/demo/src/demo/eg5.clj}
\end{exmp}
\end{Code}
The destructuring syntax \clj{(fn [{:keys [val] :as m}] ...)} binds
\clj{m} to the value of the first argument, and \clj{val} to \clj{(:val m)}.

\clj{isa?} is special with vectors---vectors of the
same length recursively call \clj{isa?} on the elements pairwise.
\begin{minted}{clojure}
  (isa? [Keyword :a] [Object :a]) ;=> true
  (isa? [Keyword Keyword] [Object Object]) ;=> true
  (isa? [Keyword Object] [Object Object]) ;=> false
\end{minted}

Now multiple dispatch is possible---we dispatch on the class of both
arguments simultaneously by defining a dispatch function that returns
a vector containing the classes of the arguments.
\begin{Code}
\begin{exmp}
\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
\end{exmp}
\end{Code}
The dispatch values are also vectors---the first method is picked
when the left argument is a \clj{Number} and the right is a \clj{Keyword},
and is thus safe to increment and extract its name respectively.
The dispatch value \clj{:default} specifies a default
method if no preferred method is found.

No extra annotations are needed to follow type-directed control flow
in multimethod dispatch.

\subsection{Final example}

The final example combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning
and use of HMaps. 
\begin{Code}
\begin{exmp}
\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
\end{exmp}
\end{Code}
\clj{PayLoad} is either a HMap containing a file
or a string. We dispatch on \clj{:p} to distinguish the two cases---for example on \clj{:F}
we know the \clj{:file} is a file.
The body of the first method uses type-hints to resolve reflection
and conditional control flow to prove null-pointer exceptions are impossible.
The second method is similar except it uses exceptional control flow.





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

