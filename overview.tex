\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Clojure and Typed Clojure Primer}

We now review the basics of the Clojure subset we use in the paper.

\paragraph{Syntax} Parentheses indicate \emph{applications}, brackets
delimit
\emph{vectors}, braces
delimit
\emph{hash-maps}
and double quotes delimit Java \emph{strings}.
\clj{nil} is exactly Java's \java{null}.
\emph{Symbols} begin with an alphabetic character.
A colon prefixed symbol like \clj{:a} is a \emph{keyword}.
\emph{Commas} are always whitespace.

\paragraph{Core forms} \clj{if} is a standard two-armed conditional.
\clj{do} sequences two expressions returning the latter.
\clj{throw} corresponds to Java's \java{throw}.
\clj{fn} creates a function from a parameter vector and a body expression.
\clj{let} takes a flat binding vector (which can refer to previous bindings like Scheme's \mintinline{scheme}{let*})
and a body expression.
\clj{def} binds a top-level \emph{var}.
\clj{defn} combines \clj{def} and \clj{fn}.

\paragraph{Semantics} \clj{get} applied to a hash-map and a key returns the value
associated with the key in the map, or \clj{nil} if there is none.
Keywords are functions that apply \clj{get} to their argument
and itself.
\clj{inc} and \clj{dec} increment and decrement numbers;
\clj{assoc} and \clj{dissoc} associate and dissociate entries
from immutable maps.
\clj{class} returns the argument's class, or \clj{nil} if passed \clj{nil}.
The \clj{=} function returns true if both arguments are equal.
\clj{number?} is
a Java \java{instanceof} test of \clj{java.lang.Number}.
\clj{nil} and \clj{false} are the false values.

\paragraph{Namespaces} \clj{ns}
declares a
\emph{namespace}
which manage var and class imports. 
\clj{:require} takes a number of namespace dependencies and \clj{:refer}
brings vars into scope by name.
\clj{:refer-clojure} \clj{:exclude} unmaps core vars from the current namespace.


\paragraph{Java Interoperability} Java methods and fields have prefix notation
like \clj{(.method target args*)} and \clj{(.field target)} respectively,
with method and field names prefixed with a dot and methods taking some number of arguments.
Constructors are called with the class name with a dot suffix and arguments like \clj{(class. args*)}.

\paragraph{Metadata} Symbols support \emph{metadata}---the syntax \clj{^File x}
is a single expression of a symbol \clj{x} with metadata \clj{{:tag File}}.
In binding positions like \clj{(fn [^File x] ...)}
syntactic occurrences preserve metadata.

\paragraph{Destructuring} \emph{Map destructuring} is binding position syntax for pattern matching.
Parameters are replaced with maps of symbols to keywords that bind the symbols
to lookups on that keyword, optionally terminated by \clj{:as}
which aliases the parameter. For example
\clj{(fn [{^File x :x, :as m}] ...)}
expands to a \clj{let} binding \clj{m} to the first argument and 
\clj{^File x} to \clj{(:x m)}.

\paragraph{Static type syntax} Single quoted keywords are singleton types containing just the keyword.
Single quoted maps mapping keywords to types 
are HMap types representing
maps with known keyword entries with values of the associated type.
\clj{U} creates an \emph{untagged union} type, which can take
any number of types.

\paragraph{Typed Clojure Macros}
The \clj{defalias} macro defines a type abbreviation which can reference itself recursively.
The typed \clj{fn} supports optional annotations by 
adding
\clj{:-} and a type after a parameter
position
or binding vector 
to annotate parameter types
and return types respectively.

\subsection{Typed Racket and occurrence typing}

\citet{TF10}
presented Typed Racket with occurrence typing,
a technique for deriving type information from conditional control flow.
They introduced the concept of occurrence typing 
with the following example.

\inputminted[firstline=1]{racket}{code/tr/example1.rkt}

This function takes a value that is either \emph{\#f} % mintinline really hates #
or a number, represented by an \emph{untagged} union type.
The `then' branch has an implicit invariant
that \rkt{x} is a number, which is automatically inferred with occurrence typing
and type checked without further annotations.

We chose to build on the ideas and implementation
of Typed Racket to implement a type system targeting Clojure for several reasons.
Initially, the similarities between Racket and Clojure drew us to
investigate the effectiveness of repurposing occurrence typing
for a Clojure type system---both languages share a Lisp heritage,
similar standard functions 
(for instance \clj{map}
in both languages is variable-arity)
and idioms.
While Typed Racket is gradually typed and has sophisticated
dynamic semantics for cross-language interaction, we 
chose to first implement
the static semantics
with the hope to extend Typed Clojure to be gradually typed at a future date.
Finally,
Typed Racket's combination of bidirectional checking
and occurrence typing presents a successful model for 
type checking dynamically typed programs without compromising
soundness, which is appealing over success typing~\cite{todo-dialyzer-paper}
which cannot prove strong properties about programs
and soft typing~\cite{successtyping-todo}
which has proved too complicated in practice.

Here is above program in Typed Clojure.

\begin{exmp}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\label{example:conditionalflow}
\end{exmp}

This is a regular Clojure file compiled with
the Clojure compiler. It has a
runtime dependency 
on
\clj{clojure.core.typed},
Typed Clojure's core namespace.
Programmers import typed versions of `typed' macros and qualified types to ease annotation.
The \clj{check-ns} function type checks the current namespace.

Typed Clojure can check all the examples in~\citet{TF10}---the 
rest of this section describes the extensions necessary
to check Clojure code.

\subsection{Exceptional control flow}

Along with conditional control flow,
Clojure programmers rely on \emph{exceptions}
to assert type-related invariants.

\begin{exmp}
\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
\label{example:doexception}
\end{exmp}

In this example a \clj{throw} expression guards \clj{(inc x)}
from being evaluated if \clj{x} is \clj{nil}, preventing
a possible null-pointer exception.

To check this example,
occurrence typing 
automatically
assumes
\clj{x} is a number when checking the second \clj{do} subexpression
based on the first subexpression.
\footnote{See \url{https://github.com/typedclojure/examples}
  for full examples. From here we omit \clj{ns} forms.}
We model this formally (section~\ref{sec:doformal}) and prove
null-pointer exceptions are impossible in typed code (section~\ref{sec:metatheory}).

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{exmp}
\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decleaf}
\end{exmp}

Here \clj{defalias} defines a type abbreviation called \clj{Expr}
that describes the structure of a recursively-defined AST as a union of HMaps.
\clj{an-exp} is a function verified to return an \clj{Expr}.

\paragraph{HMaps in Practice} The next example is extracted from a production system at CircleCI
(section~\ref{sec:casestudy} presents a case study).

\begin{exmp}
\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
\end{exmp}

\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
dissociating the raw \clj{:private-key} entry and associating an encrypted private key
as \clj{:enc-private-key}.
Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
operation forgot to remove it.

The next example is the same except we use the \clj{:absent-keys}
HMap option
and
utilize destructuring.

\begin{exmp}
\inputminted[firstline=10,lastline=21]{clojure}{code/demo/src/demo/key2.clj}
\end{exmp}

We would still catch the bug if \clj{dissoc} forgot to remove \clj{:private-key},
but now stashing the raw private key as \clj{:secret-key} is allowed.

\paragraph{Branching on HMaps} Finally, testing on HMap properties
allows us to refine its type down branches. \clj{dec-map} takes an
\clj{Expr}, traverses to its nodes and decrements their values, then
builds the \clj{Expr} back up with the decremented nodes.

\begin{exmp}
\inputminted[linenos,firstnumber=1,firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decmap}
\end{exmp}

If we go down the then branch (line 4), since \clj{(= (:op m) :if)} is true
we remove
the \clj{:do} and \clj{:const}
Expr's from the type of \clj{m} (because their respective \clj{:op} entries disagrees with \clj{(= (:op m) :if)})
and we are left with an \clj{:if} Expr.
On line 8,
we instead strike out the \clj{:if} Expr since it contradicts \clj{(= (:op m) :if)} being false. 
Line 9 we know \clj{m}
we remove \clj{:const} because it contradicts \clj{(= (:op m) :do)} being true,
and we know \clj{m} is a \clj{:do} Expr.
Line 12 we strike out \clj{:do} because \clj{(= (:op m) :do)} is false,
so we are left with \clj{m} being a \clj{:const} Expr.

Section~\ref{sec:formalpaths} discusses how this automatic reasoning is achieved.

\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.

\begin{minted}{clj}
  (fn [f] (.getParent f))
\end{minted}

Unlike Java, Clojure is dynamically typed. We have no type information about \clj{f}
but we still need to pick a method to call. The Clojure compiler delegates
the choice to runtime using \emph{Java reflection}.
Unfortunately reflection is slow and unpredictable, so Clojure supports \emph{type hints}
to help eliminate it where possible, 

\begin{minted}{clj}
  (fn [^File f] (.getParent f))
\end{minted}

The Clojure compiler uses the type hint
to statically resolve 
the method call to the
\mintinline{java}{public String getParent()}
method of \clj{java.io.File}.
The method is unambiguous but type checking fails---Typed Clojure
considers \clj{f} to be of type \clj{Any}, which is unsafe 
to use as the target of even a resolved method.
We annotate the function parameter with type \clj{File}.

\begin{minted}{clj}
  (fn [f :- File] (.getParent f)) ;; type error
\end{minted}

Typed Clojure disallows reflection in typed code
so we must add back the type hint to obtain a well-typed
expression.

\begin{exmp}
\inputminted[firstline=10,lastline=10]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

The type hinting system and Typed Clojure's static type checking
are separate, the latter predating the former by several years.
The interaction between them is often not as obvious, for example type hints
do not need to take \clj{nil} into account, while Typed Clojure guarantees
null-pointer exceptions are impossible.

\begin{exmp}
\inputminted[firstline=18,lastline=19]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

Typed Clojure and Java treat \java{null} differently.
In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
This means the Java static type \java{String} is equivalent to
\clj{(U nil String)} in Typed Clojure.

To guarantee \java{null} is never accidentally leaked into a Typed Clojure program,
we must assume methods are nullable.

\begin{exmp}
\inputminted[firstline=6,lastline=8]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

In contrast, JVM invariants guarantee that  constructor cannot return \java{null},
so we are safe to assume constructors are non-nullable.

\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular positions if needed.

\subsection{Multimethods}

\label{sec:multioverview}

A multimethod in Clojure is a function with a \emph{dispatch
function} and a \emph{dispath table} of methods. Multimethods are created with {\clj{defmulti}}.
\inputminted[firstline=5,lastline=7]{clojure}{code/demo/src/demo/rep.clj}
The multimethod \clj{path} has type \clj{[Any -> (U nil String)]}, an initially empty \emph{dispatch table}
and \emph{dispatch function} \clj{class}.
There are currently no methods so \clj{path} will fail at runtime.
\begin{minted}{clojure}
  (path (File. "dir/a"));=> IllegalArgumentException
\end{minted}

We can use {\clj{defmethod}} to add a method to \clj{path}.
\inputminted[firstline=8,lastline=8]{clojure}{code/demo/src/demo/rep.clj}
Now the dispatch table maps
the \emph{dispatch value} \clj{File} to the function
\clj{(fn [^File x] (.getPath x))}. 
The call 
$$
\clj{(path (File. "dir/a"))}
$$
now dispatches to the \clj{File} method because
$$
\clj{(isa? (class "dir/a") String)}
$$
is true, and finally returns 
$$
\clj{((fn [^File x] (.getPath x)) "dir/a")}.
$$

The \clj{isa?} function first tries an equality check
on its arguments, then if that fails
and both arguments are classes a subclassing
check is returned.
\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? Keyword Object) ;=> true
\end{minted}

In the full definition for \clj{path} we add a method for \clj{nil}
which uses the equality check provied by \clj{isa?}.

\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=11]{clojure}{code/demo/src/demo/rep.clj}
\label{example:rep}
\end{exmp}
\end{Code}

Typed Clojure does not predict if a runtime dispatch will be successful---\clj{(path :a)} 
type checks because \clj{:a} agrees with the parameter type \clj{Any},
but throws an error at runtime.

\paragraph{HMap dispatch} The flexibility of \clj{isa?} is key to the generality of multimethods. 
In example~\ref{example:incmap} we
dispatch on the \clj{:op} key 
of our HMap AST \clj{Expr}.
Since keywords are functions that look themselves up in their argument, we simply
use \clj{:op} as the dispatch function.

\begin{figure}
\begin{exmp}
\inputminted[firstline=5,lastline=18]{clojure}{code/demo/src/demo/eg5.clj}
\label{example:incmap}
\end{exmp}
\end{figure}

\clj{inc-map} is like example~\ref{example:decmap} except the nodes are incremented.
The reasoning is similar, except we only consider one branch (the current method) by
locally considering the current \emph{dispatch value} and reasoning about how it relates
to the \emph{dispatch function}.
For example, 
in the \clj{:do} method we learn the \clj{:op} key is a \clj{:do}, which
narrows our argument type to the \clj{:do} Expr, and similarly for the \clj{:if}
and \clj{:const} methods.

\paragraph{Multiple dispatch} \clj{isa?} is special with vectors---vectors of the
same length recursively call \clj{isa?} on the elements pairwise.
\begin{minted}{clojure}
  (isa? [Keyword Keyword] [Object Object]) ;=> true
\end{minted}

Example~\ref{example:multidispatch}
simulates multiple dispatch by dispatching on
a vector containing the class of both arguments. \clj{open}
takes two arguments which can be strings or files and returns
a new file that concatenates their paths.

\begin{figure}
\begin{exmp}
\inputminted[firstline=6,lastline=22]{clojure}{code/demo/src/demo/eg7.clj}
\label{example:multidispatch}
\end{exmp}
\end{figure}

We call three different \clj{File} constructors, each known at compile-time
via type hints.
Multiple dispatch follows the same kind of reasoning as example~\ref{example:incmap},
except we update multiple bindings simultaneously.

\subsection{Final example}

Example~\ref{example:final}
combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning,
and HMaps. 

\begin{figure}
\begin{exmp}
\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
\label{example:final}
\end{exmp}
\end{figure}

We dispatch on \clj{:p} to distinguish the two cases of \clj{FSM}---for example on \clj{:F}
we know the \clj{:file} is a file.
The body of the first method uses type hints to resolve reflection
and conditional control flow to prove null-pointer exceptions are impossible.
The second method is similar except it uses exceptional control flow.





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

