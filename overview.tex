\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Typed Racket and occurrence typing}

\citet{TF10}
presented Typed Racket with occurrence typing,
a technique for deriving type information from conditional control flow.
They introduce the concept of occurrence typing 
with the following example.

\inputminted[firstline=1]{racket}{code/tr/example1.rkt}

This function takes a value that is either \emph{\#f} % mintinline really hates #
or a number, represented by an untagged \emph{union type}.
The `then' branch has an implicit invariant
that \rkt{x} is a number, which is automatically inferred with occurrence typing
and type checked without further annotations.

We chose to build on the ideas and implementation
of Typed Racket to implement a type system targeting Clojure for several reasons.
Initially, the similarities between Racket and Clojure drew us to
investigate the effectiveness of repurposing occurrence typing
for a Clojure type system---both languages share a Lisp heritage,
similar standard functions 
(for instance \clj{map}
in both languages is variable-arity)
and idioms.
While Typed Racket is gradually typed and has sophisticated
dynamic semantics for cross-language interaction, we 
chose to first implement
the static semantics
with the hope to extend Typed Clojure to be gradually typed at a future date.
Finally,
Typed Racket's combination of bidirectional checking
and occurrence typing presents a successful model for 
type checking dynamically typed programs without compromising
soundness, where other approaches like success typing~\cite{todo-dialyzer-paper}
or soft typing~\cite{successtyping-todo}
fail to prove strong properties about programs
and have proved too complicated in practice respectively.

Here is above program in Typed Clojure.

\begin{exmp}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\label{example:conditionalflow}
\end{exmp}

Typed Clojure can check all the examples in~\citet{TF10}---the 
rest of this section describes the extensions necessary
to check Clojure code.

\subsection{Clojure and Typed Clojure Primer}

We introduce Clojure's syntax.
Parenthesis indicate \emph{applications}, square brackets
are syntax for literal \emph{vectors} and curly braces delimit literal
\emph{hash-maps}.
\clj{nil} is exactly Java's \java{null} and is one of two logically
false values (the other is \clj{false}).
\emph{Symbols} begin with an alphabetic character.
A symbol prefixed with a colon like \clj{:a} is an interned \emph{keyword}.
The \clj{get} function takes a hash-map and a key returns the value
associated with the key in the map, or returns \clj{nil} if there is none.
Keywords are functions that take a map and applies \clj{get} to the map
and itself.
\clj{inc} and \clj{dec} increment and decrement numbers respectively.
\clj{assoc} and \clj{dissoc} associate and dissociate entries
from immutable maps.
The \clj{=} function returns true if all its arguments are structurally equal---in this
paper we use it only for pointer equality.
Everything is an instance of some class
except for \clj{nil}. Predicates like \clj{number?} are equivalent to
a Java \java{instanceof} test, in this case on \clj{java.lang.Number}.

Symbols support \emph{metadata}, an arbitrary map of
data. The syntax \clj{^File x}, shorthand for \clj{^{:tag File} x}, is a single expression that is the symbol \clj{x} 
with metadata \clj{{:tag File}}.
In binding positions like \clj{(fn [^File x] ...)}
the compile-time metadata is preserved in occurrences of \clj{x}
and utilized by the compiler.

\emph{Commas} are always whitespace.

Clojure uses \emph{namespaces}, declared with the
\clj{ns} form, to manage top-level \emph{vars} and
class imports.
Example~\ref{example:conditionalflow}
is a regular Clojure file compiled with
the Clojure compiler using \clj{:require} to declare a
runtime dependency on Typed Clojure's core namespace
\clj{clojure.core.typed}.
Programmers import typed versions of certain constructs as needed, like
a \clj{fn} variant that supports annotations,
and use the provided \clj{check-ns} function to type check the current namespace
when convenient.
We omit \clj{ns} forms for the rest of the examples.
\footnote{See <this> github repo for full working examples}

Java methods and fields are called in prefix notation
like \clj{(.method target args*)} and \clj{(.field target)} respectively,
with method and field names prefixed with a dot and methods taking some number of arguments.
The canonical form for methods is \clj{(. target (method args*))} 
and for fields \clj{(. target field)} using the dot special form, which we utilise occasionally
for clarity.
Constructors are the class name with a dot suffix and arguments like \clj{(class. args*)}
or equivalently \clj{(new class args*)} with the \clj{new} special form.

The \clj{if} special form is a standard two-armed conditional.
The \clj{do} special form sequentially evaluates any number of expressions
left-to-right, returning the last expression or \nil{}.
The \clj{when} macro is a one-armed \clj{if} with an implicit \clj{do}
around arguments after the test, and returns \clj{nil} if the test fails.
The \clj{throw} special form is exactly Java's \java{throw}, which takes an
instance of \clj{Throwable} and throws it as an exception.
The \clj{fn} macro creates a function---it takes a parameter vector of symbols indicating parameter names
and any number of expressions in an implicit \clj{do} for the body of the function.
The \clj{let} macro takes a vector of bindings, a flat vector of binding-value pairs,
and scopes them in the body, an implicit \clj{do}.
Scoping works like \clj{let*} in Scheme---that is values in the binding vector can refer
to variables previously introduced in the same binder.
The typed
variant of \clj{fn} supports an optional keyword \clj{:-} and type following
each parameter to declare their static types, and similarly after
the parameter vector to declare the return type.

\emph{Destructuring} is binding position syntax for pattern matching.
A \emph{map destructuring} contains pairs of symbols and keywords that bind the symbols
to lookups on that keyword with the current argument, optionally terminated by
\clj{:as} and a symbol, which binds the symbol to the current argument. For example
$$
\clj{(fn [{^File x :x, :as m}] ...)}
$$ 
expands to a \clj{let} that binds \clj{m} to the argument and 
\clj{^File x} to \clj{(:x m)}.
Destructuring is supported similarly by \clj{let}.

In a static type, a quoted keyword \clj{':if} is a singleton type containing just the keyword.
Quoted maps like \clj{'{:op ':const, :val Num}} are HMap types representing
maps with known keyword entries with values of the associated type
The keys are not quoted because only keyword keys
are allowed. The type constructor \clj{U} indicates an untagged union type, which can take
any number of types.

The \clj{defalias} macro defines a type abbreviation which can reference itself recursively.

\subsection{Exceptional control flow}

Along with conditional control flow,
Clojure programmers rely on \emph{exceptions}
to assert type-related invariants.

\begin{exmp}
\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
\label{example:doexception}
\end{exmp}

To check this example, we note that
occurrence typing already provides
valuable information about the conditional expression---namely that it cannot return logically true and if it returns logically false 
then \clj{x} is a \clj{Number}. Equivalently, if it returns a value then \clj{x} is a \clj{Number}.
We use this assumption to check \clj{(inc x)} with an automatic
guarantee that a null-pointer exception is impossible
(modelled formally in section~\ref{sec:doformal} and proved
in section~\ref{sec:metatheory}).

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{Code}
\begin{exmp}
\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decleaf}
\end{exmp}
\end{Code}

Here we define a type abbreviation with \clj{defalias} called \clj{Expr}
that describes the structure of a recursively-defined AST as a union of HMaps.
\clj{an-exp} is a function verified to return an \clj{Expr}.

The next example is a real Typed Clojure program written by CircleCI, who maintain a large production
installation of Clojure (see section~\ref{sec:casestudy} for a case study).

\begin{Code}
\begin{exmp}
\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
\end{exmp}
\end{Code}

\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
removing the raw \clj{:private-key} entry and associating an encrypted private key
as \clj{:enc-private-key}.
Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
operation forgot to remove it.

\begin{Code}
\begin{exmp}
\inputminted[firstline=10,lastline=23]{clojure}{code/demo/src/demo/key2.clj}
\end{exmp}
\end{Code}


HMaps interact with occurrence typing in interesting ways.

\begin{Code}
\begin{exmp}
\inputminted[firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
\end{exmp}
\end{Code}

Section~\ref{sec:hmapformal} discusses this in greater detail.

\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.
Method calls use prefix syntax, for example this call to 
\clj{java.io.File}'s \clj{getParent} method.

\begin{minted}{clj}
  (fn [f] (.getParent f))
\end{minted}

We have a problem: Clojure's compiler does not know which method to call.
Instead, \clj{f} is inspected at runtime and an appropriate method is selected based
and then invoked by \emph{Java reflection}.
Unfortunately, reflection is slow and Clojure's algorithm for
choosing methods at runtime is undefined in some cases.

To resolve reflective calls, Clojure supports \emph{type hints}.

\begin{minted}{clj}
  (fn [^File f] (.getParent f))
\end{minted}

The Clojure compiler uses the type hint on \clj{f}
to statically resolve the method call to the \clj{java.io.File}
method with the Java signature

\begin{minted}{java}
  public String getParent()
\end{minted}

Typed Clojure ignores type hints, so to check this we must
annotate the parameter's static type.

\begin{minted}{clj}
  (fn [f :- File] (.getParent f))
\end{minted}

However Typed Clojure disallows reflection in typed code, so we
must add a type hint.

\inputminted[firstline=10,lastline=10]{clojure}{code/demo/src/demo/parent3.clj}

Now we have a well-typed expression free of reflection.

Typed Clojure and Java treat \java{null} differently.
In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
This means the Java static type \java{String} is equivalent to
\clj{(U nil String)} in Typed Clojure.

To guarantee \java{null} is never accidentally leaked into a Typed Clojure program,
we must assume methods are nullable.

\begin{exmp}
\inputminted[firstline=12,lastline=13]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

In contrast, JVM invariants guarantee that  constructor cannot return \java{null},
so we are safe to assume constructors are non-nullable.

\begin{Code}
\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}
\end{Code}

Notice a type hint is used in an argument position to help choose the \java{File(String pathname)}
constructor. By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular positions if needed.

Finally, Typed Clojure guarantees typed code cannot throw a null-pointer exception
by attempting to dereference \clj{nil}. This can happen in several ways, including
calling a method or a field on \clj{nil}.
The next example calls a method on once-nullable local binding.
(\clj{ann} annotates a var with an expected type).

\begin{exmp}
\inputminted[firstline=5,lastline=8]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

The test on \clj{f} is essential to check this example---only then can Typed Clojure
prove null-pointer exceptions are impossible.

\subsection{Multimethods}

A multimethod in Clojure is a function that contains a dispatch
function and methods. Multimethods are created with {\clj{defmulti}}.
\begin{minted}{clojure}
(ann rep [Any -> String])
(defmulti rep class)
\end{minted}
\clj{rep} is a multimethod of type \clj{[Any -> String]} with an empty \emph{dispatch table}
and \emph{dispatch function} \clj{class}, a function that returns the argument's class or \clj{nil} if none.
There are no methods to dispatch to so invocations of \clj{rep} will fail at runtime.
\begin{minted}{clojure}
  (rep :a) ;=> IllegalArgumentException ...
\end{minted}

Methods are installed via {\clj{defmethod}}.
\begin{minted}{clojure}
(defmethod rep Keyword [x] (str (name x)))
\end{minted}
We extend \clj{rep}'s dispatch table, mapping
the \emph{dispatch value} \clj{Keyword} to the function
\clj{(fn [x] (str (name x)))}. The call \clj{(rep arg)}
uses the value of \clj{(isa? (disp-fn arg) disp-val)}
on each method entry to pick a winner \clj{mth}, and finally returns \clj{(mth arg)}.
\clj{isa?} is a subclassing check when provided with classes
\begin{minted}{clojure}
  (isa? Keyword Object) ;=> true
  (isa? Keyword Number) ;=> false
\end{minted}
otherwise an equality check.
\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? :a 1) ;=> false
\end{minted}

For example
\clj{(rep :a)}
picks the \clj{Keyword} method because
\clj{(isa? (class :a) Keyword)} returns true,
and finally returns \clj{"a"}, the value of
\clj{((fn [x] (str (name x))) :a)}.
We give the full definition of \clj{rep}.

\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=11]{clojure}{code/demo/src/demo/rep.clj}
\label{example:rep}
\end{exmp}
\end{Code}
Typed Clojure does not statically ensure multimethod calls dispatch successfully---
\clj{(rep "a")} type checks but throws a runtime error.

The flexibility of \clj{isa?} is key to the generality of multimethods. 
We can dispatch on the \clj{:op} key 
of our HMap AST \clj{Expr}.
Keywords are functions that look themselves up in their argument, so \clj{:op}
is our dispatch function.
\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=25]{clojure}{code/demo/src/demo/eg5.clj}
\end{exmp}
\end{Code}
The destructuring syntax \clj{(fn [{:keys [val] :as m}] ...)} binds
\clj{m} to the value of the first argument, and \clj{val} to \clj{(:val m)}.

\clj{isa?} is special with vectors---vectors of the
same length recursively call \clj{isa?} on the elements pairwise.
\begin{minted}{clojure}
  (isa? [Keyword :a] [Object :a]) ;=> true
  (isa? [Keyword Keyword] [Object Object]) ;=> true
  (isa? [Keyword Object] [Object Object]) ;=> false
\end{minted}

Now multiple dispatch is possible---we dispatch on the class of both
arguments simultaneously by defining a dispatch function that returns
a vector containing the classes of the arguments.
\begin{Code}
\begin{exmp}
\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
\end{exmp}
\end{Code}
The dispatch values are also vectors---the first method is picked
when the left argument is a \clj{Number} and the right is a \clj{Keyword},
and is thus safe to increment and extract its name respectively.
The dispatch value \clj{:default} specifies a default
method if no preferred method is found.

No extra annotations are needed to follow type-directed control flow
in multimethod dispatch.

\subsection{Final example}

The final example combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning
and use of HMaps. 
\begin{Code}
\begin{exmp}
\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
\end{exmp}
\end{Code}
\clj{PayLoad} is either a HMap containing a file
or a string. We dispatch on \clj{:p} to distinguish the two cases---for example on \clj{:F}
we know the \clj{:file} is a file.
The body of the first method uses type hints to resolve reflection
and conditional control flow to prove null-pointer exceptions are impossible.
The second method is similar except it uses exceptional control flow.





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

