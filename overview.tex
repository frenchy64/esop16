\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Clojure and Typed Clojure Primer}

We introduce Clojure's syntax.
Parenthesis indicate \emph{applications}, square brackets
are syntax for literal \emph{vectors} and curly braces delimit literal
\emph{hash-maps}.
\clj{nil} is exactly Java's \java{null} and is one of two logically
false values (the other is \clj{false}).
\emph{Symbols} begin with an alphabetic character.
A symbol prefixed with a colon like \clj{:a} is an interned \emph{keyword}.
The \clj{get} function takes a hash-map and a key returns the value
associated with the key in the map, or returns \clj{nil} if there is none.
Keywords are functions that take a map and applies \clj{get} to the map
and itself.
\clj{inc} and \clj{dec} increment and decrement numbers respectively.
\clj{assoc} and \clj{dissoc} associate and dissociate entries
from immutable maps.
The \clj{=} function returns true if all its arguments are pointer equal.
Everything is an instance of some class
except for \clj{nil}. Predicates like \clj{number?} are equivalent to
a Java \java{instanceof} test, in this case on \clj{java.lang.Number}.

Symbols support \emph{metadata}, an arbitrary map of
data. The syntax \clj{^File x}, shorthand for \clj{^{:tag File} x}, is a single expression that is the symbol \clj{x} 
with metadata \clj{{:tag File}}.
In binding positions like \clj{(fn [^File x] ...)}
the compile-time metadata is preserved in occurrences of \clj{x}
and utilized by the compiler.

\emph{Commas} are always whitespace.

Clojure uses \emph{namespaces}, declared with the
\clj{ns} form, to manage top-level \emph{vars} and
class imports.
Example~\ref{example:conditionalflow}
is a regular Clojure file compiled with
the Clojure compiler using \clj{:require} to declare a
runtime dependency on Typed Clojure's core namespace
\clj{clojure.core.typed}.
Programmers import typed versions of certain constructs as needed, like
a \clj{fn} variant that supports annotations,
and use the provided \clj{check-ns} function to type check the current namespace
when convenient.

Java methods and fields are called in prefix notation
like \clj{(.method target args*)} and \clj{(.field target)} respectively,
with method and field names prefixed with a dot and methods taking some number of arguments.
The canonical form for methods is \clj{(. target (method args*))} 
and for fields \clj{(. target field)} using the dot special form, which we utilise occasionally
for clarity.
Constructors are the class name with a dot suffix and arguments like \clj{(class. args*)}
or equivalently \clj{(new class args*)} with the \clj{new} special form.

The \clj{if} special form is a standard two-armed conditional.
The \clj{do} special form sequentially evaluates any number of expressions
left-to-right, returning the last expression or \nil{}.
The \clj{when} macro is a one-armed \clj{if} with an implicit \clj{do}
around arguments after the test, and returns \clj{nil} if the test fails.
The \clj{throw} special form is exactly Java's \java{throw}, which takes an
instance of \clj{Throwable} and throws it as an exception.
The \clj{fn} macro creates a function---it takes a parameter vector of symbols indicating parameter names
and any number of expressions in an implicit \clj{do} for the body of the function.
The \clj{let} macro takes a vector of bindings, a flat vector of binding-value pairs,
and scopes them in the body, an implicit \clj{do}.
Scoping works like \clj{let*} in Scheme---that is values in the binding vector can refer
to variables previously introduced in the same binder.
The typed
variant of \clj{fn} supports an optional keyword \clj{:-} and type following
each parameter to declare their static types, and similarly after
the parameter vector to declare the return type.

\emph{Map destructuring} is binding position syntax for pattern matching.
Parameters are replaced with a map containing entries of symbols to keywords that bind the symbols
to lookups on that keyword with the current argument---the \clj{:as} option
can follow which binds a symbol to the current argument. For example
$$
\clj{(fn [{^File x :x, :as m}] ...)}
$$ 
expands to a \clj{let} that binds \clj{m} to the argument and 
\clj{^File x} to \clj{(:x m)}.

In a static type, a quoted keyword \clj{':if} is a singleton type containing just the keyword.
Quoted maps like \clj{'{:op ':const, :val Num}} are HMap types representing
maps with known keyword entries with values of the associated type
The keys are not quoted because only keyword keys
are allowed. The type constructor \clj{U} indicates an untagged union type, which can take
any number of types.

The \clj{defalias} macro defines a type abbreviation which can reference itself recursively.

\subsection{Typed Racket and occurrence typing}

\citet{TF10}
presented Typed Racket with occurrence typing,
a technique for deriving type information from conditional control flow.
They introduce the concept of occurrence typing 
with the following example.

\inputminted[firstline=1]{racket}{code/tr/example1.rkt}

This function takes a value that is either \emph{\#f} % mintinline really hates #
or a number, represented by an untagged \emph{union type}.
The `then' branch has an implicit invariant
that \rkt{x} is a number, which is automatically inferred with occurrence typing
and type checked without further annotations.

We chose to build on the ideas and implementation
of Typed Racket to implement a type system targeting Clojure for several reasons.
Initially, the similarities between Racket and Clojure drew us to
investigate the effectiveness of repurposing occurrence typing
for a Clojure type system---both languages share a Lisp heritage,
similar standard functions 
(for instance \clj{map}
in both languages is variable-arity)
and idioms.
While Typed Racket is gradually typed and has sophisticated
dynamic semantics for cross-language interaction, we 
chose to first implement
the static semantics
with the hope to extend Typed Clojure to be gradually typed at a future date.
Finally,
Typed Racket's combination of bidirectional checking
and occurrence typing presents a successful model for 
type checking dynamically typed programs without compromising
soundness, where other approaches like success typing~\cite{todo-dialyzer-paper}
or soft typing~\cite{successtyping-todo}
fail to prove strong properties about programs
and have proved too complicated in practice respectively.

Here is above program in Typed Clojure.

\begin{exmp}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\label{example:conditionalflow}
\end{exmp}

Typed Clojure can check all the examples in~\citet{TF10}---the 
rest of this section describes the extensions necessary
to check Clojure code.

\subsection{Exceptional control flow}

Along with conditional control flow,
Clojure programmers rely on \emph{exceptions}
to assert type-related invariants, such as preventing
null-pointer exceptions.

\begin{exmp}
\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
\label{example:doexception}
\end{exmp}

To check this example,
occurrence typing 
automatically
assumes
\clj{x} is a number when checking the second \clj{do} subexpression
based on the first subexpression.
\footnote{We omit \clj{ns} forms for the rest of the examples, see <this> github repo for full working examples}
We model this formally (section~\ref{sec:doformal}) and prove
null-pointer exceptions are impossible in typed code (section~\ref{sec:metatheory}).

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{exmp}
\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decleaf}
\end{exmp}

Here \clj{defalias} defines a type abbreviation called \clj{Expr}
that describes the structure of a recursively-defined AST as a union of HMaps.
\clj{an-exp} is a function verified to return an \clj{Expr}.

The next example is extracted from a Typed Clojure production system at CircleCI
(section~\ref{sec:casestudy} presents a case study).

\begin{exmp}
\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
\end{exmp}

\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
dissociating the raw \clj{:private-key} entry and associating an encrypted private key
as \clj{:enc-private-key}.
Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
operation forgot to remove it.

\begin{exmp}
\inputminted[firstline=10,lastline=21]{clojure}{code/demo/src/demo/key2.clj}
\end{exmp}

Next, 
HMaps interact with occurrence typing in interesting ways.

\begin{exmp}
\inputminted[firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
\end{exmp}

Section~\ref{sec:hmapformal} discusses this in greater detail.

\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.

\begin{minted}{clj}
  (fn [f] (.getParent f))
\end{minted}

Unlike Java, Clojure is dynamically typed. We have no type information about \clj{f}
but we still need to pick a method to call. The Clojure compiler delegates
the choice to runtime using \emph{Java reflection}.
Unfortunately reflection is slow and unpredictable, so Clojure supports \emph{type hints}
to help eliminate it where possible, 

\begin{minted}{clj}
  (fn [^File f] (.getParent f))
\end{minted}

The Clojure compiler uses the type hint
to statically resolve 
the method call to the
\mintinline{java}{public String getParent()}
method of \clj{java.io.File}.
The method is unambiguous but type checking fails---Typed Clojure
considers \clj{f} to be of type \clj{Any}, which is unsafe 
to use as the target of even a resolved method.
We annotate the function parameter with type \clj{File}.

\begin{minted}{clj}
  (fn [f :- File] (.getParent f)) ;; type error
\end{minted}

Typed Clojure disallows reflection in typed code
so we must add back the type hint to obtain a well-typed
expression.

\inputminted[firstline=10,lastline=10]{clojure}{code/demo/src/demo/parent3.clj}

The type hinting system and Typed Clojure's static type checking
are separate, the latter predating the former by several years.
The interaction between them is often not as obvious, for example type hints
do not need to take \clj{nil} into account, while Typed Clojure guarantees
null-pointer exceptions are impossible.

\begin{exmp}
\inputminted[firstline=18,lastline=19]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

Typed Clojure and Java treat \java{null} differently.
In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
This means the Java static type \java{String} is equivalent to
\clj{(U nil String)} in Typed Clojure.

To guarantee \java{null} is never accidentally leaked into a Typed Clojure program,
we must assume methods are nullable.

\begin{exmp}
\inputminted[firstline=6,lastline=8]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

In contrast, JVM invariants guarantee that  constructor cannot return \java{null},
so we are safe to assume constructors are non-nullable.

\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular positions if needed.

\subsection{Multimethods}

A multimethod in Clojure is a function that contains a dispatch
function and methods. Multimethods are created with {\clj{defmulti}}.
\inputminted[firstline=5,lastline=7]{clojure}{code/demo/src/demo/rep.clj}
The multimethod \clj{path} has type \clj{[Any -> String]}, an initially empty \emph{dispatch table}
and \emph{dispatch function} \clj{class}, a function that returns the argument's class or \clj{nil} if none.
There are currently no methods so \clj{path} will fail at runtime.
\begin{minted}{clojure}
  (path "dir/a") ;=> IllegalArgumentException ...
\end{minted}

We can use {\clj{defmethod}} to add a method to \clj{path}.
\inputminted[firstline=8,lastline=8]{clojure}{code/demo/src/demo/rep.clj}
Now \clj{path}'s dispatch table contains a method mapping
the \emph{dispatch value} \clj{String} to the function
\clj{(fn [x] x)}. The call \clj{(path "dir/a")}
now dispatches to the method because
\clj{(isa? (class "dir/a") String)}
is true, and finally returns \clj{((fn [x] x) "dir/a")}.
\clj{isa?} is a subclassing check when provided with classes,
otherwise it is an equality check.
\begin{minted}{clojure}
  (isa? Keyword Object) ;=> true
  (isa? :a :a) ;=> true
\end{minted}

\begin{exmp}
\inputminted[firstline=5,lastline=11]{clojure}{code/demo/src/demo/rep.clj}
\label{example:rep}
\end{exmp}

Typed Clojure does not statically ensure multimethod calls dispatch successfully---\clj{(path :a)} 
type checks but throws a runtime error.

The flexibility of \clj{isa?} is key to the generality of multimethods. 
We can dispatch on the \clj{:op} key 
of our HMap AST \clj{Expr}.
Keywords are functions that look themselves up in their argument, so \clj{:op}
is our dispatch function.

\begin{exmp}
\inputminted[firstline=5,lastline=25]{clojure}{code/demo/src/demo/eg5.clj}
\end{exmp}

\clj{isa?} is special with vectors---vectors of the
same length recursively call \clj{isa?} on the elements pairwise.
\begin{minted}{clojure}
  (isa? [Keyword Keyword] [Object Object]) ;=> true
\end{minted}

Now we can simulate multiple dispatch by dispatching on
a vector containing the class of both arguments.

\begin{exmp}
\inputminted[firstline=6,lastline=22]{clojure}{code/demo/src/demo/eg7.clj}
\end{exmp}

We call three different \clj{File} constructors, each known at compile-time
via type hints.
No extra annotations are needed to follow type-directed control flow
in multimethod dispatch.

\subsection{Final example}

The final example combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning
and use of HMaps. 

\begin{exmp}
\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
\end{exmp}

\clj{PayLoad} is either a HMap containing a file
or a string. We dispatch on \clj{:p} to distinguish the two cases---for example on \clj{:F}
we know the \clj{:file} is a file.
The body of the first method uses type hints to resolve reflection
and conditional control flow to prove null-pointer exceptions are impossible.
The second method is similar except it uses exceptional control flow.





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

