\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

%\paragraph{Clojure Syntax}
%
%We describe new syntax as they appear in each example, but
%begin with include the essential basics of Clojure syntax.
%
%\clj{nil} is exactly Java's \java{null}.
%Parentheses indicate \emph{applications}, brackets
%delimit
%\emph{vectors}, braces
%delimit
%\emph{hash-maps}
%and double quotes delimit \emph{Java strings}.
%\emph{Symbols} begin with an alphabetic character,
%and a colon prefixed symbol like \clj{:a} is a \emph{keyword}.
%
%\emph{Commas} are always \emph{whitespace}.

\subsection{Typed Clojure}

Here is a simple program in Typed Clojure.

We define a global variable \clj{greet} as a one-argument function
taking and returning a string.

\begin{minted}{clj}
(ann  greet [Str -> Str])
(defn greet [n]
  (str "Hello, " n "!"))
(greet "Grace") ; :- Str
;=> "Hello, Grace!"
\end{minted}

The function may take strings, but providing \clj{nil} (Clojure's name for Java's \java{null})
is a static type error --- \clj{nil} is not a string in Typed Clojure.

\begin{minted}{clj}
(greet 
  nil ; Type Error:
      ;   Expected Str, given nil
  )
\end{minted}

\paragraph{Unions} We can make the annotation more permissive with \emph{ad-hoc unions}
to allow \clj{nil}.

\begin{minted}{clj}
(ann  greet-nil [(U nil Str) -> Str])
(defn greet-nil [n]
  (str "Hello" (when n (str ", " n)) "!"))
(greet-nil "Donald") ; :- Str
;=> "Hello, Donald!"
(greet-nil nil)      ; :- Str
;=> "Hello!"
\end{minted}

All Clojure values are true except \clj{nil} and \clj{false}, so the
comma is only added when the argument is non-nil.

Typed Clojure guarantees that well-typed code cannot
dereference the null-pointer.
This is especially important for Clojure programs---\clj{nil}
is treated like any other distinct datum in Clojure,  and its status as
one of only two false values means it is a common choice to indicate
``nothing'' or ``failure''.

\paragraph{Flow analysis} Typed Clojure uses occurrence typing to
model type-based control flow.
In \clj{greetings}, a \clj{when} expression ensures \clj{repeat}
is never passed a \clj{nil} argument.

\begin{minted}{clj}
(ann  greetings [Str (U nil Int) -> Str])
(defn greetings [n i]
  (str "Hello, "
       (when i  ; when i is a non-nil integer
         (apply str (repeat i "hello, ")))
       n "!"))
(greetings "Donald" 2)  ; :- Str
;=> "Hello, hello, hello, Donald!"
(greetings "Grace" nil) ; :- Str
;=> "Hello, Grace!"
\end{minted}

Removing the \clj{when} expression is a static type error
--- \clj{repeat} cannot be passed \clj{nil}.

\begin{minted}{clj}
(ann  greetings-bad [Str (U nil Int) -> Str])
(defn greetings-bad [n i]
  (str "Hello, "
       (apply str 
         (repeat 
           i ; Type Error:
             ;   Expected Int, given (U nil Int).
           "hello, "))
       n "!"))
\end{minted}



%\subsection{Type System Basics}
%
%\citet{TF10}
%presented Typed Racket with occurrence typing,
%a technique for deriving type information from conditional control flow.
%They introduced the concept of occurrence typing 
%with the following example.
%
%\inputminted[firstline=3]{racket}{code/tr/example1.rkt}
%
%This function takes a value that is either \emph{\#f} % mintinline really hates #
%or a number, represented by an \emph{untagged} union type.
%The `then' branch has an implicit invariant
%that \rkt{x} is a number, which is automatically inferred with occurrence typing
%and type checked without further annotations.
%
%We chose to build on the ideas and implementation
%of Typed Racket to implement a type system targeting Clojure for several reasons.
%Initially, the similarities between Racket and Clojure drew us to
%investigate the effectiveness of repurposing occurrence typing
%for a Clojure type system---both languages share a Lisp heritage,
%similar standard functions 
%(for instance \clj{map}
%in both languages is variable-arity)
%and idioms.
%While Typed Racket is gradually typed and has sophisticated
%dynamic semantics for cross-language interaction, we 
%chose to first implement
%the static semantics
%with the hope to extend Typed Clojure to be gradually typed at a future date.
%Finally,
%Typed Racket's combination of bidirectional checking
%and occurrence typing presents a successful model for 
%type checking dynamically typed programs without compromising
%soundness, which is appealing over success typing~\cite{Lindahl:2006:PTI}
%which cannot prove strong properties about programs
%and soft typing~\cite{CF91}
%which has proved too complicated in practice.
%
%Here is the above program in Typed Clojure.
%\begin{exmp}
%\inputminted[firstline=5]{clojure}{code/demo/src/demo/eg1.clj}
%\label{example:conditionalflow}
%\end{exmp}
%
%The \clj{fn} macro (provided by core.typed) supports optional annotations by 
%adding
%\clj{:-} and a type after a parameter
%position
%or binding vector 
%to annotate parameter types
%and return types respectively.
%\clj{number?} is
%a Java \java{instanceof} test of \clj{java.lang.Number}.
%As in Typed Racket, \clj{U} creates an \emph{untagged union} type, which can take
%any number of types.
%
%Typed Clojure can already check all of the examples in~\citet{TF10}---the 
%rest of this section describes the extensions necessary
%to check Clojure code.


\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, invoke methods, and access fields.

The following Typed Clojure program constructs a new \clj{File}
instance and calls the \clj{getParent} method on the result.

\begin{exmp}
\begin{minted}{clj}
  (.getParent (new File "a/b"))  ; :- (U nil Str)
  ;=> "a"
\end{minted}
\label{example:getparent-direct-constructor}
\end{exmp}

Typed Clojure helps the Clojure compiler avoid expensive reflective 
calls,
however if a specific constructor, method, or field cannot be found based on the
static types of its arguments, a type error is thrown.

\begin{minted}{clj}
  (fn [f] 
    (.getParent f) ; Type Error:
                   ;   Unresolved interop: getParent
    )
\end{minted}

Function arguments default to \clj{Any}, the most permissive type. Ascribing
a parameter type helps Typed Clojure find a specific method.

%Calls to Java methods and fields have prefix notation
%like \clj{(.method target args*)} and \clj{(.field target)} respectively,
%with method and field names prefixed with a dot and methods taking some number of arguments.

\begin{exmp}
\begin{minted}{clojure}
(ann parent [(U nil File) -> (U nil Str)])
(defn parent [f]
  (if f (.getParent f) nil))
\end{minted}
\label{example:parent-if}
\end{exmp}

%\begin{exmp}
%\inputminted[firstline=18,lastline=19]{clojure}{code/demo/src/demo/parent3.clj}
%\end{exmp}

The conditional guards from dereferencing \clj{nil}, and---as before---removing 
it is a static type error, as typed code could possibly dereference \clj{nil}.

\begin{minted}{clj}
(defn parent-bad-in [f :- (U nil File)]
  (.getParent f) ; Type Error:
                 ;   Cannot call instance method 
                 ;   java.io.File/getParent on type 
                 ;   (U nil File).
  )
\end{minted}

Any Java method returning a reference can also return \java{null} ---
Typed Clojure rejects programs that assume otherwise.

\begin{minted}{clj}
(defn parent-bad-out [f :- File] :- Str
  (.getParent f) ; Type Error:
                 ;   Expected Str, given (U nil Str).
  )
\end{minted}

%Typed Clojure and Java treat \java{null} differently.
%In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
%called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
%This means the Java static type \java{String} is equivalent to
%\clj{(U nil String)} in Typed Clojure.
%
%Reference types in Java are nullable, so to guarantee a method call does not
%leak \java{null} into a Typed Clojure program we
%must assume methods can return \clj{nil}.

In contrast, JVM invariants guarantee constructors return a non-null reference.\footnote{\url{http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.4}}

\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular non-target positions if needed.

\subsection{Multimethods}

\label{sec:multioverview}

A \emph{multimethod} is a kind of extensible function. It combines
a \emph{dispatch function} with one or more \emph{methods}.

\paragraph{Value-based dispatch}
Here is a simple multimethod.

\begin{exmp}
\begin{minted}{clojure}
(ann hi [Kw -> Str]) ; interface type for `hi`
(defmulti hi identity) ; dispatch function `identity`
(defmethod hi :en [_] "hello") ; method for `:en`
(defmethod hi :fr [_] "bonjour") ; method for `:fr`
(defmethod hi :default [_] "um...") ; default method
\end{minted}
\label{example:hi-multimethod}
\end{exmp}

When invoked, the arguments are first supplied to the dispatch function---\clj{identity}---yielding
a \emph{dispatch value}. A method is then chosen
based on the dispatch value---this method is applied to the arguments
to finally return a value for the entire expression.

\begin{minted}{clojure}
(map hi [:en :fr :bocce]) ; map over keyword vector 
;=> ("hello" "bonjour" "um...")
\end{minted}

For example, 
\clj{(hi :en)} evaluates to \clj{"hello"}---it executes
the \clj{:en} method
because \clj{(= (identity :en) :en)} is true
and \clj{(= (identity :en) :fr)} is false.

This is only part of the story for multimethod dispatch.

\paragraph{Class-based dispatch}
For class values, multimethods choose methods based on subclassing
relationships.

Recall the multimethod in figure~\ref{fig:ex1}, duplicated below.

\begin{minted}{clj}
(ann pname [(U File String) -> (U nil String)])
(defmulti pname class)
(defmethod pname String [s] (pname (new File s)))
(defmethod pname File [f] (.getName f))
\end{minted}

%Its dispatching function is
%\clj{class}, with two methods associated with dispatch values \clj{java.lang.String} and \clj{java.io.File}
%respectively.

The dispatch function \clj{class}
%---associated at multimethod creation with \clj{defmulti}---
dictates 
whether the \clj{String} or \clj{File} method is chosen.
%---both installed via \clj{defmethod}

The multimethod dispatch rules involve
\clj{isa?}, a hybrid predicate which includes a subclassing check for classes and
an equality check for most other values.

\begin{minted}{clojure}
(isa? (identity :en) :en) ;=> true
(isa? (identity :en) :fr) ;=> false
(isa? (class "STAINS/JELLY") String) ;=> true
(isa? (class "STAINS/JELLY") Object) ;=> true
(isa? (class (new File "JELLY")) String) ;=> false
\end{minted}

The current dispatch value and---in turn---each method's associated dispatch value
is supplied to \clj{isa?}. If exactly one method returns true, it is chosen.

To demonstrate,
  \clj{(pname "STAINS/JELLY")}
chooses the \clj{String} method because
\clj{(isa? (class "STAINS/JELLY") String)}
is true and
\clj{(isa? (class "STAINS/JELLY") File)}
is false. Then the \clj{String} method body
\clj{(pname (new File "STAINS/JELLY"))}
chooses the \clj{File} method for opposite reasons,
resulting in 
\begin{minted}{clojure}
(.getName (new File "STAINS/JELLY")) ; :- (U nil Str)
;=> "JELLY"
\end{minted}

%The following Typed Clojure program is semantically identical to figure~\ref{fig:ex1}.
%
%\begin{minted}{clj}
%(ann pname [(U Str File) -> (U nil Str)])
%(defn pname [x]
%  ; dispatch value calculated by applying dispatch
%  ; function `class` to argument `x`.
%  (cond
%    ; if (class x) subclasses String, but not File
%    (and (isa? (class x) String)
%         (not (isa? (class x) File)))
%    ; then choose the String method
%    (pname (new File x))
%
%    ; else if (class x) subclasses File, but not String
%    (and (isa? (class x) File)         
%         (not (isa? (class x) String)))
%    ; then choose the File method
%    (.getName x)
%    :else (throw (Exception. "No match"))))
%\end{minted}
%
%An unambiguous match leads to the corresponding method being applied to the arguments,
%giving the final result.

%\subsection{Multimethods}
%
%A multimethod in Clojure is a function with a \emph{dispatch
%function} and a \emph{dispatch table} of methods. Multimethods are created with {\clj{defmulti}}.
%\inputminted[firstline=5,lastline=6]{clojure}{code/demo/src/demo/rep.clj}
%The multimethod \clj{path} has type \clj{[Any -> (U nil String)]}, an initially empty \emph{dispatch table}
%and \emph{dispatch function} \clj{class}, a function that
%returns the class of its argument or \clj{nil} if passed \clj{nil}.
%
%We can use {\clj{defmethod}} to install a method to \clj{path}.
%\inputminted[firstline=7,lastline=7]{clojure}{code/demo/src/demo/rep.clj}
%Now the dispatch table maps
%the \emph{dispatch value} \clj{String} to the function
%\clj{(fn [x] x)}. 
%We add another method
%which maps
%\clj{File} to the function
%\clj{(fn [x] (.getPath x))}
%in the dispatch table.
%\inputminted[firstline=8,lastline=8]{clojure}{code/demo/src/demo/rep.clj}
%
%After installing both methods, the call 
%$$
%\clj{(path (new File "dir/a"))}
%$$
%dispatches to the second method we installed because
%$$
%\clj{(isa? (class "dir/a") String)}
%$$
%is true, and finally returns 
%$$
%\clj{((fn [x] (.getPath x)) "dir/a")}.
%$$

%We include the above sequence of definitions as \egref{example:rep}.
%
%\begin{Code}
%\begin{exmp}
%\inputminted[firstline=5,lastline=10]{clojure}{code/demo/src/demo/rep.clj}
%\label{example:rep}
%\end{exmp}
%\end{Code}
%
%Typed Clojure does not predict if a runtime dispatch will be successful---\clj{(path :a)} 
%type checks because \clj{:a} agrees with the parameter type \clj{Any},
%but throws an error at runtime.

%\paragraph{Multiple dispatch} \clj{isa?} is special with vectors---vectors of the
%same length recursively call \clj{isa?} on the elements pairwise.
%\begin{minted}{clojure}
%  (isa? [Keyword Keyword] [Object Object]) ;=> true
%\end{minted}
%
%\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
%
%\egref{example:multidispatch}
%simulates multiple dispatch by dispatching on
%a vector containing the class of both arguments. \clj{open}
%takes two arguments which can be strings or files and returns
%a new file that concatenates their paths.
%
%We call three different \clj{File} constructors, each known at compile-time
%via type hints.
%Multiple dispatch follows the same kind of reasoning as \egref{example:incmap},
%except we update multiple bindings simultaneously.

\subsection{Heterogeneous hash-maps}

Immutable hash-maps with keyword keys play a major role in Clojure programming
as the primary way to structure data.

\begin{minted}{clojure}
(def breakfast {:en "waffles" :fr "croissants"})

(get breakfast :en)    ; :- Str
;=> "waffles"
; keywords are functions that look themselves up
(:fr breakfast)        ; :- Str
;=> "croissants"
(:bocce breakfast) ; :- nil
;=> nil
\end{minted}

HMap types model the most common usages of keyword maps.
\begin{minted}{clojure}
breakfast ; :- (HMap :mandatory {:en Str :fr Str}
          ;          :complete? true)
\end{minted}
The inferred type for \clj{breakfast} holds two kinds of information---the known entries \clj{:en}
and \clj{:fr} have string values (expressed as a \clj{:mandatory} entry) and that 
every other key is absent (by \clj{:complete?} being \clj{true}).

HMap's default to being partially specified---\clj{:complete?} defaults to \clj{false}. The HMap shorthand 
\clj{'{:en Str :fr Str}}
forgets 
information about absent keys, only providing \clj{:mandatory}
information.

\begin{minted}{clojure}
(ann lunch '{:en Str :fr Str})
(def lunch {:en "muffin" :fr "baguette"})
(:en lunch)    ; :- Str
;=> "muffin"
(:fr lunch)    ; :- Str
;=> "baguette"
; Unknown lookups are now less accurate
(:bocce lunch) ; :- Any
;=> nil
\end{minted}

\paragraph{HMaps in practice} The next example is extracted from a production system at CircleCI,
a company with a large production Typed Clojure system
(section~\ref{sec:casestudy} presents a case study).

\begin{exmp}
\begin{minted}{clojure}
(defalias RawKeyPair
  "Unencrypted keypair -- extra keys disallowed"
  (HMap :mandatory {:public-key RawKey,
                    :private-key RawKey},
        :complete? true))

(defalias EncKeyPair
  "Encrypted keypair -- extra keys disallowed"
  (HMap :mandatory {:public-key RawKey,
                    :enc-private-key EncKey},
        :complete? true))

(ann enc-keypair [RawKeyPair -> EncKeyPair])
(defn enc-keypair "Encrypt an unencrypted keypair"
  [{pk :private-key :as kp}] ; original map is kp
  (assoc 
    ; remove unencrypted private key
    (dissoc kp :private-key)
    ; add encrypted private key
    :enc-private-key (encrypt pk)))
\end{minted}
\label{example:circleci}
\end{exmp}

%\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
Fully specified HMap's
statically enforce the private key is not accidentally left in a supposedly
encrypted keypair.

\begin{minted}{clojure}
(ann enc-keypair-bad [RawKeyPair -> EncKeyPair])
(defn enc-keypair-bad
  [{pk :private-key :as kp}]
  (assoc kp :enc-private-key (encrypt pk))
  ; Type Error:
  ;   Expected EncKeyPair, given 
  ;   (HMap :mandatory {:enc-private-key EncKey
  ;                     :private-key RawKey
  ;                     :public-key RawKey}
  ;         :complete? true)
  )
\end{minted}

The extra \clj{:private-key} entry disagrees with \clj{EncKeyPair}, so a type error
is given.

%\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
%dissociating the raw \clj{:private-key} entry with \clj{dissoc}
%and associating an encrypted private key
%as \clj{:enc-private-key} on an immutable map with \clj{assoc}.
%The expression \clj{(:private-key kp)} shows that keywords are also 
%functions that look themselves up in a map returning the associated value or \nil{} if the key is missing.
%Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
%does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
%operation forgot to remove it.

%\egref{example:absentkeys}
%is like \egref{example:circleci}
%except the \clj{:absent-keys} HMap option is used
%instead of \clj{:complete?},
%which takes a \emph{set literal} of keywords that do not appear in the map, written 
%with \emph{\#}-prefixed braces.
%The syntax \clj{(fn [{pkey :private-key, :as kp}] ...)}
%aliases \clj{kp} to the first argument and \clj{pkey} to \clj{(:private-key m)}
%in the function body.
%
%\begin{exmp}
%\inputminted[firstline=10,lastline=21]{clojure}{code/demo/src/demo/key2.clj}
%\label{example:absentkeys}
%\end{exmp}
%
%Since this example enforces that \clj{:private-key} must not appear
%in a \clj{EncKeyPair}
%Typed Clojure would still complain if we forgot to \clj{dissoc} \clj{:private-key}
%from the return value.
%Now, however we could stash the raw private key in another entry
%like \clj{:secret-key} which is not mentioned by the partial HMap \clj{EncKeyPair}
%without Typed Clojure noticing.

%\paragraph{Branching on HMaps} Finally, testing on HMap properties
%allows us to refine its type down branches. \clj{dec-map} takes an
%\clj{Expr}, traverses to its nodes and decrements their values by \clj{dec}, then
%builds the \clj{Expr} back up with the decremented nodes.
%
%\begin{exmp}
%\inputminted[linenos,firstnumber=1,firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
%\label{example:decmap}
%\end{exmp}
%
%If we go down the then branch (line 4), since \clj{(= (:op m) :if)} is true
%we remove
%the \clj{:do} and \clj{:const}
%Expr's from the type of \clj{m} (because their respective \clj{:op} entries disagrees with \clj{(= (:op m) :if)})
%and we are left with an \clj{:if} Expr.
%On line 8,
%we instead strike out the \clj{:if} Expr since it contradicts \clj{(= (:op m) :if)} being false. 
%Line 9 know we can
%remove the \clj{:const} Expr from the type of \clj{m} because it contradicts \clj{(= (:op m) :do)} being true,
%and we know \clj{m} is a \clj{:do} Expr.
%Line 12 we strike out \clj{:do} because \clj{(= (:op m) :do)} is false,
%so we are left with \clj{m} being a \clj{:const} Expr.
%
%Section~\ref{sec:formalpaths} discusses how this automatic reasoning is achieved.

\subsection{HMaps and multimethods, joined at the hip}

Since HMaps are the primary way of specifying the structure of data in Clojure,
and multimethods are the primary tool for dispatching on data, they are inevitably
linked.
There are infinite ways of both structuring and dispatching on data, so there is no
hope predicting them all, or even manually covering useful a subset.

Thankfully, occurrence typing is both extensible \emph{and} compositional.
By extending occurrence typing with
a handful of rules based on HMaps and other functions, 
we can automatically cover almost all the common cases---as well others
that compose simple rules in arbitrary ways.

Futhermore, no special attention is needed for multimethod dispatch---the primitive branching
mechanism is still the humble \clj{if} conditional. Only a small number of rules are needed
to encode the \clj{isa?}-based dispatch, themselves made of small, simple pieces.
In practice, this means all conditional-based control flow analysis
also extends to the context of multimethod dispatch, and vice-versa.

We first demonstrate a very common, simple dispatch style,
then move on to deeper structural dispatching where occurrence typing's
compositionality shines.

\paragraph{HMaps and unions} Partially specified HMap's with a common dispatch key
combine naturally with ad-hoc unions.
An \clj{Order} is one of three kinds of HMaps.

\begin{minted}{clojure}
(defalias Order   ; define type abbreviation
  "A meal order, tracking dessert quantities."
  (U '{:Meal ':lunch ; keyword singleton type
       :desserts Int}
     '{:Meal ':dinner :desserts Int}
     '{:Meal ':combo :meal1 Order :meal2 Order}))
\end{minted}

The \clj{:Meal} entry is common to each HMap, always mapped to a known keyword singleton
type.
It's natural to dispatch on the \clj{class} of an instance---it's similarly
natural to dispatch on a known entry like \clj{:Meal}.

\begin{exmp}
\begin{minted}{clojure}
(ann desserts [Order -> Int])
(defmulti desserts "Total desserts per order."
          :Meal)  ; dispatch on :Meal entry
; map destructuring backwards, d is :desserts entry
(defmethod desserts :lunch [{d :desserts}] d)
(defmethod desserts :dinner [{d :desserts}] d)
(defmethod desserts :combo [{m1 :meal1 m2 :meal2}]
  (+ (desserts m1) (desserts m2)))

(desserts {:Meal :combo 
           :meal1 {:Meal :lunch :desserts 1}
           :meal2 {:Meal :dinner :desserts 2}})
;=> 3
\end{minted}
\label{example:desserts-on-meal}
\end{exmp}

The \clj{:combo} method is verified to only structurally recur
on \clj{Order}s. This is achieved because we learn the argument--- \clj{o} ---must % em dash needs space here, looks weird
be of type
\clj{'{:Meal :combo}}
since
\clj{(isa? (:Meal o) :combo)}
must be true. Combining \clj{'{:Meal :combo}}
with the fact that \clj{o} is an \clj{Order}
eliminates possibility of \clj{:lunch} and \clj{:dinner}
orders, simplifying \clj{o} to
\begin{minted}{clojure}
'{:Meal ':combo :meal1 Order :meal2 Order}
\end{minted}
which can safely structurally recur.


\paragraph{Nested dispatch}
An equally valid dispatch mechanism for \clj{desserts}
would be on the \clj{class} of the \clj{:desserts} key.
We have already seen dispatch on \clj{class} and on keywords
in isolation---occurrence typing automatically understands
control flow that combines its simple building blocks.

\begin{minted}{clojure}
(ann desserts' [Order -> Int])
(defmulti desserts' 
          (fn [o :- Order] (class (:desserts o))))
(defmethod desserts' Long [{d :desserts :as o}] 
  ; o :- (U '{:Meal ':lunch :desserts Int}
  ;         '{:Meal ':dinner :desserts Int})
  d)
(defmethod desserts' nil [{m1 :meal1 m2 :meal2 :as o}]
  ; o :- '{:Meal ':combo :meal1 Order :meal2 Order}
  (+ (desserts' m1) (desserts' m2)))
\end{minted}
%
%(desserts' {:Meal :combo 
%            :meal1 {:Meal :lunch :desserts 1}
%            :meal2 {:Meal :dinner :desserts 2}})
%;=> 3

In the \clj{Long} method, Typed Clojure learns that
its argument is at least of type \clj{'{:desserts Long}}---since
\begin{minted}{clojure}
(isa? (class (:desserts o)) Long)
\end{minted}
must be true.

Knowing \clj{o} is also an
\clj{Order}, we can eliminate the possibility of
a \clj{:combo} meal, and infer the type
\begin{minted}{clojure}
(U '{:Meal ':lunch :desserts Int}
   '{:Meal ':dinner :desserts Int})
\end{minted}
Looking up \clj{:desserts} on this type returns an \clj{Int}.

In the \clj{nil} method, we know
\begin{minted}{clojure}
(isa? (class (:desserts o)) nil)
\end{minted}
is true---which implies \clj{(class (:desserts o))} is \clj{nil}.

Since lookups on missing keys return \clj{nil}, either
\begin{itemize}
  \item \clj{o} has a \clj{:desserts} entry to \clj{nil}, or
  \item \clj{o} is missing a \clj{:desserts} entry.
\end{itemize}
Equivalently, we learn \clj{o} is at least of type
\begin{minted}{clojure}
(U '{:desserts nil}
   ; :absent-keys, a set of known absent entries
   (HMap :absent-keys #{:desserts}))
\end{minted}
This intersected with \clj{o} being an \clj{Order} simplifies to a \clj{:combo} meal, 
\begin{minted}{clojure}
'{:Meal ':combo :meal1 Order :meal2 Order}
\end{minted}
thus verifying both structural recursions.

\paragraph{From multiple to arbitrary dispatch}
Multimethod dispatch goes even further, supporting
multiple dispatch via vectors.

Fully specifying multimethod dispatch is beyond the scope of this paper,
but the same intuition applies---adding support for multiple dispatch
automatically allows arbitrary combinations and nestings
of it and previous simple dispatch rules.

%\begin{exmp}
%\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
%\label{example:decleaf}
%\end{exmp}
%
%The \clj{defn} macro defines a top-level function, with syntax like the typed \clj{fn}.
%The function \clj{an-exp} is verified to return an \clj{Expr}.
%
%Here \clj{defalias} defines \clj{Expr}, a type abbreviation
%that describes the structure of a recursively-defined AST as a union of HMaps.
%Keyword singleton types are quoted---\clj{':lunch}.
%A type that is a quoted map like \clj{'{:op ':if}} is a
%HMap type with a fixed number of keyword entries of the specified types
%known to be \emph{present},
%zero entries known to absolutely be \emph{absent},
%and an infinite number of \emph{unknown} entries entries.
%Since only keyword keys are allowed, they do not require quoting.

%\paragraph{HMap dispatch} The flexibility of \clj{isa?} is key to the generality of multimethods. 
%In \egref{example:incmap} we
%dispatch on the \clj{:op} key 
%of our HMap AST \clj{Expr}.
%Since keywords are functions that look themselves up in their argument, we simply
%use \clj{:op} as the dispatch function.
%
%\begin{exmp}
%\inputminted[firstline=5,lastline=18]{clojure}{code/demo/src/demo/eg5.clj}
%\label{example:incmap}
%\end{exmp}
%
%The function \clj{inc-leaf} is like \egref{example:decmap} except the nodes are incremented.
%The reasoning is similar, except we only consider one branch (the current method) by
%locally considering the current \emph{dispatch value} and reasoning about how it relates
%to the \emph{dispatch function}.
%For example, 
%in the \clj{:do} method we learn the \clj{:op} key is a \clj{:do}, which
%narrows our argument type to the \clj{:do} Expr, and similarly for the \clj{:if}
%and \clj{:const} methods.
%
%
%\subsection{Final example}
%
%\egref{example:final}
%combines everything we will cover for the rest of the paper:
%multimethod dispatch, reflection resolution via type hints, Java method
%and constructor calls, conditional and exceptional flow reasoning,
%and HMaps. 
%
%
%\begin{figure}
%\begin{exmp}
%\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
%\label{example:multidispatch}
%\end{exmp}
%\begin{exmp}
%\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
%\label{example:final}
%\end{exmp}
%\caption{Multimethod Examples}
%\end{figure}
%
%We dispatch on \clj{:p} to distinguish the two cases of \clj{FSM}---for example on \clj{:F}
%we know the \clj{:file} is a file.
%The body of the first method uses type hints to resolve reflection
%and conditional control flow to prove null-pointer exceptions are impossible.
%The second method is similar except it uses exceptional control flow.
