\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

%\paragraph{Clojure Syntax}
%
%We describe new syntax as they appear in each example, but
%begin with include the essential basics of Clojure syntax.
%
%\clj{nil} is exactly Java's \java{null}.
%Parentheses indicate \emph{applications}, brackets
%delimit
%\emph{vectors}, braces
%delimit
%\emph{hash-maps}
%and double quotes delimit \emph{Java strings}.
%\emph{Symbols} begin with an alphabetic character,
%and a colon prefixed symbol like \clj{:a} is a \emph{keyword}.
%
%\emph{Commas} are always \emph{whitespace}.

\subsection{Typed Clojure}

Here is a simple program in Typed Clojure.
%
We define \clj{greet} as a one-argument function
taking and returning a string.

\begin{minted}{clj}
(ann  greet [Str -> Str])
(defn greet [n]
  (str "Hello, " n "!"))
(greet "Grace") ; :- Str
;=> "Hello, Grace!"
\end{minted}
%
Strings are accepted, but providing \clj{nil} (Clojure's name for Java's \java{null})
is a static type error---\clj{nil} is not a string in Typed Clojure.
%
\begin{minted}{clj}
(greet nil) ; Type Error:
            ;   Expected Str, given nil
\end{minted}

\paragraph{Unions} We can make the annotation more permissive with \emph{ad-hoc unions}
to allow \clj{nil}.

\begin{minted}{clj}
(ann  greet-nil [(U nil Str) -> Str])
(defn greet-nil [n]
  (str "Hello" (when n (str ", " n)) "!"))
(greet-nil "Donald") ; :- Str
;=> "Hello, Donald!"
(greet-nil nil)      ; :- Str
;=> "Hello!"
\end{minted}

All Clojure values are true except \clj{nil} and \clj{false}, so the
comma is only added when the argument is non-nil.

Typed Clojure guarantees that well-typed code cannot
dereference the null-pointer.
This is especially important for Clojure programs---\clj{nil}
is treated like any other distinct datum in Clojure,  and its status as
one of only two false values means it is a common choice to indicate
``nothing'' or ``failure''.

\paragraph{Flow analysis} Typed Clojure uses occurrence typing~\cite{TF10} to
model type-based control flow.
In \clj{greetings}, a \clj{when} expression ensures \clj{repeat}
is never passed a \clj{nil} argument.
%
\begin{minted}{clj}
(ann  greetings [Str (U nil Int) -> Str])
(defn greetings [n i]
  (str "Hello, "
       (when i  ; when i is a non-nil integer
         (apply str (repeat i "hello, ")))
       n "!"))
(greetings "Donald" 2)  ; :- Str
;=> "Hello, hello, hello, Donald!"
(greetings "Grace" nil) ; :- Str
;=> "Hello, Grace!"
\end{minted}
%
Removing the \clj{when} expression is a static type error---\clj{repeat} 
cannot be passed \clj{nil}.
%
\begin{minted}{clj}
(ann  greetings-bad [Str (U nil Int) -> Str])
(defn greetings-bad [n i]
  (str "Hello, "
       (apply str 
         (repeat 
           i ; Type Error:
             ;   Expected Int, given (U nil Int).
           "hello, "))
       n "!"))
\end{minted}



%\subsection{Type System Basics}
%
%\cite{TF10}
%presented Typed Racket with occurrence typing,
%a technique for deriving type information from conditional control flow.
%They introduced the concept of occurrence typing 
%with the following example.
%
%\inputminted[firstline=3]{racket}{code/tr/example1.rkt}
%
%This function takes a value that is either \emph{\#f} % mintinline really hates #
%or a number, represented by an \emph{untagged} union type.
%The `then' branch has an implicit invariant
%that \rkt{x} is a number, which is automatically inferred with occurrence typing
%and type checked without further annotations.
%
%We chose to build on the ideas and implementation
%of Typed Racket to implement a type system targeting Clojure for several reasons.
%Initially, the similarities between Racket and Clojure drew us to
%investigate the effectiveness of repurposing occurrence typing
%for a Clojure type system---both languages share a Lisp heritage,
%similar standard functions 
%(for instance \clj{map}
%in both languages is variable-arity)
%and idioms.
%While Typed Racket is gradually typed and has sophisticated
%dynamic semantics for cross-language interaction, we 
%chose to first implement
%the static semantics
%with the hope to extend Typed Clojure to be gradually typed at a future date.
%Finally,
%Typed Racket's combination of bidirectional checking
%and occurrence typing presents a successful model for 
%type checking dynamically typed programs without compromising
%soundness, which is appealing over success typing~\cite{Lindahl:2006:PTI}
%which cannot prove strong properties about programs
%and soft typing~\cite{CF91}
%which has proved too complicated in practice.
%
%Here is the above program in Typed Clojure.
%\begin{exmp}
%\inputminted[firstline=5]{clojure}{code/demo/src/demo/eg1.clj}
%\label{example:conditionalflow}
%\end{exmp}
%
%The \clj{fn} macro (provided by core.typed) supports optional annotations by 
%adding
%\clj{:-} and a type after a parameter
%position
%or binding vector 
%to annotate parameter types
%and return types respectively.
%\clj{number?} is
%a Java \java{instanceof} test of \clj{java.lang.Number}.
%As in Typed Racket, \clj{U} creates an \emph{untagged union} type, which can take
%any number of types.
%
%Typed Clojure can already check all of the examples in~\cite{TF10}---the 
%rest of this section describes the extensions necessary
%to check Clojure code.


\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, invoke methods, and access fields.

The following Typed Clojure program constructs a new \clj{File}
instance and calls the \clj{getParent} method on the result,
returning a string \clj{"a"}, inferred as nullable.

\begin{exmp}
\begin{minted}{clj}
(.getParent (new File "a/b"))  
; :- (U nil Str)
;=> "a"
\end{minted}
\label{example:getparent-direct-constructor}
\end{exmp}

Typed Clojure helps the Clojure compiler avoid expensive reflective 
calls,
however if a specific constructor, method, or field cannot be found based on the
static types of its arguments, a type error is thrown.

\begin{minted}{clj}
(fn [f]           ; Type Error:                    
  (.getParent f)) ;   Unresolved interop: getParent
                  
\end{minted}

Function arguments default to \clj{Any}, the most permissive type. Ascribing
a parameter type allows Typed Clojure to find a specific method.

%Calls to Java methods and fields have prefix notation
%like \clj{(.method target args*)} and \clj{(.field target)} respectively,
%with method and field names prefixed with a dot and methods taking some number of arguments.

\begin{exmp}
\begin{minted}{clojure}
(ann parent [(U nil File) -> (U nil Str)])
(defn parent [f]
  (if f (.getParent f) nil))
\end{minted}
\label{example:parent-if}
\end{exmp}

%\begin{exmp}
%\inputminted[firstline=18,lastline=19]{clojure}{code/demo/src/demo/parent3.clj}
%\end{exmp}

The conditional guards from dereferencing \clj{nil}, and---as before---removing 
it is a static type error, as typed code could possibly dereference \clj{nil}.
\begin{minted}{clj}
(defn parent-bad-in [f :- (U nil File)]
  (.getParent f)) ; Type Error:
                  ;   Cannot call instance method 
                  ;   java.io.File/getParent on type 
                  ;   (U nil File).
\end{minted}
Since Java-level types do not provide information about nullability,
by default Typed Clojure conservatively assumes that Java method and
constructor arguments, such as \clj{"a/b"} provided to the \clj{File} constructor in
\egref{example:getparent-direct-constructor},
 must be \emph{non-nullable}, but this can be
configured for  particular calls as needed.
The target of method invocations is always non-nullable.

Any Java method returning a reference can also return \java{null} ---
Typed Clojure rejects programs that assume otherwise.
%
\begin{minted}{clj}
(defn parent-bad-out [f :- File] :- Str
  (.getParent f)) ; Type Error:
                  ;   Expected Str, given (U nil Str).
\end{minted}

%Typed Clojure and Java treat \java{null} differently.
%In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
%called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
%This means the Java static type \java{String} is equivalent to
%\clj{(U nil String)} in Typed Clojure.
%
%Reference types in Java are nullable, so to guarantee a method call does not
%leak \java{null} into a Typed Clojure program we
%must assume methods can return \clj{nil}.

In contrast, JVM invariants guarantee constructors return a non-null reference.\footnote{\url{http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.4}}
%
\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}


\subsection{Multimethods}

\label{sec:multioverview}

\emph{Multimethods} are a kind of extensible function, and they are
widely used to define Clojure operations.  It combines a
\emph{dispatch function} with one or more \emph{methods}.

\paragraph{Value-based dispatch}
This simple multimethod says hello in different languages, as
specified by a keyword argument.

\begin{exmp}
\begin{minted}{clojure}
(ann hi [Kw -> Str]) ; multimethod type
(defmulti hi identity) ; dispatch function `identity`
(defmethod hi :en [_] "hello") ; method for `:en`
(defmethod hi :fr [_] "bonjour") ; method for `:fr`
(defmethod hi :default [_] "um...") ; default method
\end{minted}
\label{example:hi-multimethod}
\end{exmp}

When invoked, the arguments are first supplied to the dispatch function---\clj{identity}---yielding
a \emph{dispatch value}. A method is then chosen
based on the dispatch value---the arguments are then passed to the method
to finally return a value for the entire expression.
%
\begin{minted}{clojure}
(map hi [:en :fr :bocce]) ; map over keyword vector 
;=> ("hello" "bonjour" "um...")
\end{minted}
%
For example, 
\clj{(hi :en)} evaluates to \clj{"hello"}---it executes
the \clj{:en} method
because \clj{(= (identity :en) :en)} is true
and \clj{(= (identity :en) :fr)} is false.

Dispatching based on literal values enables certain forms of method
definition, but this is only part of the story for multimethod dispatch.

\paragraph{Class-based dispatch}
For class values, multimethods can choose methods based on subclassing
relationships.
%
Recall the multimethod from figure~\ref{fig:ex1}, reproduced here.
\begin{minted}{clj}
(ann pname [(U File String) -> (U nil String)])
(defmulti pname class)
(defmethod pname String [s] (pname (new File s)))
(defmethod pname File [f] (.getName f))
\end{minted}

%Its dispatching function is
%\clj{class}, with two methods associated with dispatch values \clj{java.lang.String} and \clj{java.io.File}
%respectively.
\noindent
The dispatch function \clj{class}
%---associated at multimethod creation with \clj{defmulti}---
dictates 
whether the \clj{String} or \clj{File} method is chosen.
%---both installed via \clj{defmethod}
%
The multimethod dispatch rules use
\clj{isa?}, a hybrid predicate which is a subclassing check for classes and
an equality check for other values.

\begin{minted}{clojure}
(isa? (identity :en) :en) ;=> true
(isa? (identity :en) :fr) ;=> false
(isa? (class "STAINS/JELLY") String) ;=> true
(isa? (class "STAINS/JELLY") Object) ;=> true
(isa? (class (new File "JELLY")) String) ;=> false
\end{minted}
%
The current dispatch value and---in turn---each method's associated dispatch value
is supplied to \clj{isa?}. If exactly one method returns true, it is chosen.

In our example,
  \clj{(pname "STAINS/JELLY")}
chooses the  method for \clj{String} because
\clj{(isa? (class "STAINS/JELLY") String)}
is true and
\clj{(isa? (class "STAINS/JELLY") File)}
is false. The \clj{String} method body
\clj{(pname (new File "STAINS/JELLY"))}
chooses the \clj{File} method for opposite reasons,
resulting in 
\begin{minted}{clojure}
(.getName (new File "STAINS/JELLY")) ; :- (U nil Str)
;=> "JELLY"
\end{minted}

%The following Typed Clojure program is semantically identical to figure~\ref{fig:ex1}.
%
%\begin{minted}{clj}
%(ann pname [(U Str File) -> (U nil Str)])
%(defn pname [x]
%  ; dispatch value calculated by applying dispatch
%  ; function `class` to argument `x`.
%  (cond
%    ; if (class x) subclasses String, but not File
%    (and (isa? (class x) String)
%         (not (isa? (class x) File)))
%    ; then choose the String method
%    (pname (new File x))
%
%    ; else if (class x) subclasses File, but not String
%    (and (isa? (class x) File)         
%         (not (isa? (class x) String)))
%    ; then choose the File method
%    (.getName x)
%    :else (throw (Exception. "No match"))))
%\end{minted}
%
%An unambiguous match leads to the corresponding method being applied to the arguments,
%giving the final result.

%\subsection{Multimethods}
%
%A multimethod in Clojure is a function with a \emph{dispatch
%function} and a \emph{dispatch table} of methods. Multimethods are created with {\clj{defmulti}}.
%\inputminted[firstline=5,lastline=6]{clojure}{code/demo/src/demo/rep.clj}
%The multimethod \clj{path} has type \clj{[Any -> (U nil String)]}, an initially empty \emph{dispatch table}
%and \emph{dispatch function} \clj{class}, a function that
%returns the class of its argument or \clj{nil} if passed \clj{nil}.
%
%We can use {\clj{defmethod}} to install a method to \clj{path}.
%\inputminted[firstline=7,lastline=7]{clojure}{code/demo/src/demo/rep.clj}
%Now the dispatch table maps
%the \emph{dispatch value} \clj{String} to the function
%\clj{(fn [x] x)}. 
%We add another method
%which maps
%\clj{File} to the function
%\clj{(fn [x] (.getPath x))}
%in the dispatch table.
%\inputminted[firstline=8,lastline=8]{clojure}{code/demo/src/demo/rep.clj}
%
%After installing both methods, the call 
%$$
%\clj{(path (new File "dir/a"))}
%$$
%dispatches to the second method we installed because
%$$
%\clj{(isa? (class "dir/a") String)}
%$$
%is true, and finally returns 
%$$
%\clj{((fn [x] (.getPath x)) "dir/a")}.
%$$

%We include the above sequence of definitions as \egref{example:rep}.
%
%\begin{Code}
%\begin{exmp}
%\inputminted[firstline=5,lastline=10]{clojure}{code/demo/src/demo/rep.clj}
%\label{example:rep}
%\end{exmp}
%\end{Code}
%
%Typed Clojure does not predict if a runtime dispatch will be successful---\clj{(path :a)} 
%type checks because \clj{:a} agrees with the parameter type \clj{Any},
%but throws an error at runtime.

%\paragraph{Multiple dispatch} \clj{isa?} is special with vectors---vectors of the
%same length recursively call \clj{isa?} on the elements pairwise.
%\begin{minted}{clojure}
%  (isa? [Keyword Keyword] [Object Object]) ;=> true
%\end{minted}
%
%\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
%
%\egref{example:multidispatch}
%simulates multiple dispatch by dispatching on
%a vector containing the class of both arguments. \clj{open}
%takes two arguments which can be strings or files and returns
%a new file that concatenates their paths.
%
%We call three different \clj{File} constructors, each known at compile-time
%via type hints.
%Multiple dispatch follows the same kind of reasoning as \egref{example:incmap},
%except we update multiple bindings simultaneously.

\subsection{Heterogeneous hash-maps}

Beyond primitives and Java objects, the most common Clojure data
structure is the 
immutable hash-map, typicially with keyword keys. This structure is
the primary way to represent compound data in Clojure programs.

Hash-maps are accessed with the \clj{get} function:
\begin{exmp}
\begin{minted}{clojure}
(def breakfast 
  {:en "waffles" :fr "croissants"})

(get breakfast :en)    ; :- Str
;=> "waffles"
\end{minted}
\label{example:breakfastcomplete}
\end{exmp}
Additionally, keywords are functions that look themselves up in a
map. Missing keys produce \clj{nil}.
\begin{minted}{clojure}
(:fr breakfast)        ; :- Str
;=> "croissants"
(:bocce breakfast) ; :- nil
;=> nil
\end{minted}

In Typed Clojure, \emph{HMap types} describe the most common usages of
keyword-keyed maps.
\begin{minted}{clojure}
breakfast ; :- (HMap :mandatory {:en Str :fr Str}
          ;          :complete? true)
\end{minted}
The inferred type for \clj{breakfast} holds two kinds of information---the known entries--\clj{:en}
and \clj{:fr}---and their types, which are  \clj{:mandatory}, and that 
no other key is present, since \clj{:complete?} is \clj{true}.

HMap types default to  partial specification---\clj{:complete?} defaults to \clj{false}. The HMap shorthand 
\clj{'{:en Str :fr Str}}
omits
information about absent keys, only providing information on
\clj{:mandatory} keys.
%
\begin{exmp}
\begin{minted}{clojure}
(ann lunch '{:en Str :fr Str})
(def lunch {:en "muffin" :fr "baguette"})
(:en lunch)    ; :- Str
;=> "muffin"
(:fr lunch)    ; :- Str
;=> "baguette"
; Unknown lookups are now less accurate
(:bocce lunch) ; :- Any
;=> nil
\end{minted}
\label{example:lunchpartial}
\end{exmp}

\paragraph{HMaps in practice} The next example is extracted from a production system at CircleCI,
a company with a large production Typed Clojure system
(section~\ref{sec:casestudy} presents a case study and empirical
result from this code base).

\begin{exmp}
\begin{minted}{clojure}
(defalias RawKeyPair
  "Unencrypted keypair -- extra keys disallowed"
  (HMap :mandatory {:public-key RawKey,
                    :private-key RawKey},
        :complete? true))

(defalias EncKeyPair
  "Encrypted keypair -- extra keys disallowed"
  (HMap :mandatory {:public-key RawKey,
                    :enc-private-key EncKey},
        :complete? true))

(ann enc-keypair [RawKeyPair -> EncKeyPair])
(defn enc-keypair "Encrypt an unencrypted keypair"
  [{pk :private-key :as kp}] ; original map is kp
  (assoc 
    ; remove unencrypted private key
    (dissoc kp :private-key)
    ; add encrypted private key
    :enc-private-key (encrypt pk)))
\end{minted}
\label{example:circleci}
\end{exmp}

%\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
If we forget to remove the unencrypted private key,
a type error is given, because \clj{EncKeyPair} is fully specified.
%
\begin{minted}{clojure}
(ann enc-keypair-bad [RawKeyPair -> EncKeyPair])
(defn enc-keypair-bad
  [{pk :private-key :as kp}]
  (assoc kp :enc-private-key (encrypt pk)))
  ; Type Error:
  ;   Expected EncKeyPair, given 
  ;   (HMap :mandatory {:enc-private-key EncKey
  ;                     :private-key RawKey
  ;                     :public-key RawKey}
  ;         :complete? true)
\end{minted}
The extra \clj{:private-key} entry does not match \clj{EncKeyPair}, so a type error
is raised.

%\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
%dissociating the raw \clj{:private-key} entry with \clj{dissoc}
%and associating an encrypted private key
%as \clj{:enc-private-key} on an immutable map with \clj{assoc}.
%The expression \clj{(:private-key kp)} shows that keywords are also 
%functions that look themselves up in a map returning the associated value or \nil{} if the key is missing.
%Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
%does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
%operation forgot to remove it.

%\egref{example:absentkeys}
%is like \egref{example:circleci}
%except the \clj{:absent-keys} HMap option is used
%instead of \clj{:complete?},
%which takes a \emph{set literal} of keywords that do not appear in the map, written 
%with \emph{\#}-prefixed braces.
%The syntax \clj{(fn [{pkey :private-key, :as kp}] ...)}
%aliases \clj{kp} to the first argument and \clj{pkey} to \clj{(:private-key m)}
%in the function body.
%
%\begin{exmp}
%\inputminted[firstline=10,lastline=21]{clojure}{code/demo/src/demo/key2.clj}
%\label{example:absentkeys}
%\end{exmp}
%
%Since this example enforces that \clj{:private-key} must not appear
%in a \clj{EncKeyPair}
%Typed Clojure would still complain if we forgot to \clj{dissoc} \clj{:private-key}
%from the return value.
%Now, however we could stash the raw private key in another entry
%like \clj{:secret-key} which is not mentioned by the partial HMap \clj{EncKeyPair}
%without Typed Clojure noticing.

%\paragraph{Branching on HMaps} Finally, testing on HMap properties
%allows us to refine its type down branches. \clj{dec-map} takes an
%\clj{Expr}, traverses to its nodes and decrements their values by \clj{dec}, then
%builds the \clj{Expr} back up with the decremented nodes.
%
%\begin{exmp}
%\inputminted[linenos,firstnumber=1,firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
%\label{example:decmap}
%\end{exmp}
%
%If we go down the then branch (line 4), since \clj{(= (:op m) :if)} is true
%we remove
%the \clj{:do} and \clj{:const}
%Expr's from the type of \clj{m} (because their respective \clj{:op} entries disagrees with \clj{(= (:op m) :if)})
%and we are left with an \clj{:if} Expr.
%On line 8,
%we instead strike out the \clj{:if} Expr since it contradicts \clj{(= (:op m) :if)} being false. 
%Line 9 know we can
%remove the \clj{:const} Expr from the type of \clj{m} because it contradicts \clj{(= (:op m) :do)} being true,
%and we know \clj{m} is a \clj{:do} Expr.
%Line 12 we strike out \clj{:do} because \clj{(= (:op m) :do)} is false,
%so we are left with \clj{m} being a \clj{:const} Expr.
%
%Section~\ref{sec:formalpaths} discusses how this automatic reasoning is achieved.

\subsection{HMaps and multimethods, joined at the hip}

Since HMaps are the primary way of specifying the structure of data in Clojure,
and multimethods are the primary tool for dispatching on data, they are inevitably
linked.
There are infinite ways of both structuring and dispatching on data,
so we cannot hope to merely add a set of special case rules for
handling these features. Instead, as type system designers, we must
search for a compositional approach.

Thankfully, occurrence typing, originally designed for reasoning about
\clj{if} tests, provides the compositional approach we need.
By extending the system with
a handful of rules based on HMaps and other functions, 
we can automatically cover both easy cases and those
that compose simple rules in arbitrary ways.

Futhermore, this approach extends to multimethod dispatch---the primitive branching
mechanism works like the humble \clj{if} conditional. 
Only a small number of rules are needed
to encode the \clj{isa?}-based dispatch, themselves made of simple pieces.
In practice, this means that conditional-based control flow typing
 extends to  multimethod dispatch, and vice-versa.

We first demonstrate a very common, simple dispatch style,
then move on to deeper structural dispatching where occurrence typing's
compositionality shines.

\paragraph{HMaps and unions} Partially specified HMap's with a common dispatch key
combine naturally with ad-hoc unions.
An \clj{Order} is one of three kinds of HMaps.

\begin{minted}{clojure}
(defalias Order   ; define type abbreviation
  "A meal order, tracking dessert quantities."
  (U '{:Meal ':lunch ; keyword singleton type
       :desserts Int}
     '{:Meal ':dinner :desserts Int}
     '{:Meal ':combo :meal1 Order :meal2 Order}))
\end{minted}

The \clj{:Meal} entry is common to each HMap, always mapped to a known keyword singleton
type.
It's natural to dispatch on the \clj{class} of an instance---it's similarly
natural to dispatch on a known entry like \clj{:Meal}.

\begin{exmp}
\begin{minted}{clojure}
(ann desserts [Order -> Int])
(defmulti desserts "Total desserts per order."
          :Meal)  ; dispatch on :Meal entry
; destructuring reads backwards, d is :desserts entry
(defmethod desserts :lunch [{d :desserts}] d)
(defmethod desserts :dinner [{d :desserts}] d)
(defmethod desserts :combo [{m1 :meal1 m2 :meal2}]
  (+ (desserts m1) (desserts m2)))

(desserts {:Meal :combo 
           :meal1 {:Meal :lunch :desserts 1}
           :meal2 {:Meal :dinner :desserts 2}})
;=> 3
\end{minted}
\label{example:desserts-on-meal}
\end{exmp}

The \clj{:combo} method is verified to only structurally recur
on \clj{Order}s. This is achieved because we learn the argument---\clj{o}---must % em dash needs space here, looks weird
be of type
\clj{'{:Meal :combo}}
since
\clj{(isa? (:Meal o) :combo)}
must be true. Combining \clj{'{:Meal :combo}}
with the fact that \clj{o} is an \clj{Order}
eliminates possibility of \clj{:lunch} and \clj{:dinner}
orders, simplifying \clj{o} to
\begin{minted}{clojure}
'{:Meal ':combo :meal1 Order :meal2 Order}
\end{minted}
which contains appropriate arguments for both recursive calls.

\paragraph{Nested dispatch}
An equally valid dispatch mechanism for \clj{desserts}
would be on the \clj{class} of the \clj{:desserts} key.
We have already seen dispatch on \clj{class} and on keywords
in isolation---occurrence typing automatically understands
control flow that combines its simple building blocks.

In the first method, the dispatch value is the class \clj{Long}, a subtype
of \clj{Int}, and the second method has dispatch value \clj{nil}, the sentinel value for a failed map lookup.
In practice, \clj{:lunch} and \clj{:dinner} meals will dispatch to the \clj{Long}
method, but Typed Clojure infers a slightly more general type due to the definition
of \clj{:combo} meals.

\begin{exmp}
\begin{minted}{clojure}
(ann desserts' [Order -> Int])
(defmulti desserts' 
          (fn [o :- Order] (class (:desserts o))))
(defmethod desserts' Long [{d :desserts :as o}] 
  ; o :- (U '{:Meal ':lunch :desserts Int}
  ;         '{:Meal ':dinner :desserts Int}
  ;         '{:Meal ':combo :desserts Int
  ;           :meal1 Order :meal2 Order})
  d)
(defmethod desserts' nil [{m1 :meal1 m2 :meal2 :as o}]
  ; o :- '{:Meal ':combo :meal1 Order :meal2 Order}
  (+ (desserts' m1) (desserts' m2)))
\end{minted}
\label{example:desserts-on-class}
\end{exmp}
%
%(desserts' {:Meal :combo 
%            :meal1 {:Meal :lunch :desserts 1}
%            :meal2 {:Meal :dinner :desserts 2}})
%;=> 3

In the \clj{Long} method, Typed Clojure learns that
its argument is at least of type \clj{'{:desserts Long}}---since
\begin{minted}{clojure}
(isa? (class (:desserts o)) Long)
\end{minted}
must be true.
%
%Knowing \clj{o} is also an
%\clj{Order},
In this method, we deduce
the entry \clj{:desserts}
\emph{must} be a present and mapped to a \clj{Long},
even in a \clj{:combo} meal
which does not state \clj{:desserts}
as present or absent.

In the \clj{nil} method,
\clj{(isa? (class (:desserts o)) nil)}
must be true---which implies \clj{(class (:desserts o))} is \clj{nil}.
%
Since lookups on missing keys return \clj{nil}, either
\begin{itemize}
  \item \clj{o} has a \clj{:desserts} entry to \clj{nil}, like \clj{{:desserts nil}}, or
  \item \clj{o} is missing a \clj{:desserts} entry, like \clj{{}}.
\end{itemize}
Equivalently, we learn \clj{o} is at least of type
\begin{minted}{clojure}
(U '{:desserts nil}
   ; :absent-keys, a set of known absent entries
   (HMap :absent-keys #{:desserts}))
\end{minted}
This eliminates non-\clj{:combo} meals
since their \clj{'{:desserts Int}} type does not agree
with this new information (because \clj{:desserts}
is neither mapped to \clj{nil} or absent).

%simplifies to a \clj{:combo} meal, 
%\begin{minted}{clojure}
%'{:Meal ':combo :meal1 Order :meal2 Order}
%\end{minted}
%thus allowing both recursive calls to type check.

\paragraph{From multimethod to multiple dispatch}
Clojure multimethod dispatch, and Typed Clojure's handling of it, goes
even further, supporting dispatch on multiple arguments via vectors.
%
Dispatch on multiple arguments is beyond the scope of this paper,
but the same intuition applies---adding support for multiple dispatch
automatically allows arbitrary combinations and nestings
of it and previous simple dispatch rules.

%\begin{exmp}
%\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
%\label{example:decleaf}
%\end{exmp}
%
%The \clj{defn} macro defines a top-level function, with syntax like the typed \clj{fn}.
%The function \clj{an-exp} is verified to return an \clj{Expr}.
%
%Here \clj{defalias} defines \clj{Expr}, a type abbreviation
%that describes the structure of a recursively-defined AST as a union of HMaps.
%Keyword singleton types are quoted---\clj{':lunch}.
%A type that is a quoted map like \clj{'{:op ':if}} is a
%HMap type with a fixed number of keyword entries of the specified types
%known to be \emph{present},
%zero entries known to absolutely be \emph{absent},
%and an infinite number of \emph{unknown} entries entries.
%Since only keyword keys are allowed, they do not require quoting.

%\paragraph{HMap dispatch} The flexibility of \clj{isa?} is key to the generality of multimethods. 
%In \egref{example:incmap} we
%dispatch on the \clj{:op} key 
%of our HMap AST \clj{Expr}.
%Since keywords are functions that look themselves up in their argument, we simply
%use \clj{:op} as the dispatch function.
%
%\begin{exmp}
%\inputminted[firstline=5,lastline=18]{clojure}{code/demo/src/demo/eg5.clj}
%\label{example:incmap}
%\end{exmp}
%
%The function \clj{inc-leaf} is like \egref{example:decmap} except the nodes are incremented.
%The reasoning is similar, except we only consider one branch (the current method) by
%locally considering the current \emph{dispatch value} and reasoning about how it relates
%to the \emph{dispatch function}.
%For example, 
%in the \clj{:do} method we learn the \clj{:op} key is a \clj{:do}, which
%narrows our argument type to the \clj{:do} Expr, and similarly for the \clj{:if}
%and \clj{:const} methods.
%
%
%\subsection{Final example}
%
%\egref{example:final}
%combines everything we will cover for the rest of the paper:
%multimethod dispatch, reflection resolution via type hints, Java method
%and constructor calls, conditional and exceptional flow reasoning,
%and HMaps. 
%
%
%\begin{figure}
%\begin{exmp}
%\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
%\label{example:multidispatch}
%\end{exmp}
%\begin{exmp}
%\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
%\label{example:final}
%\end{exmp}
%\caption{Multimethod Examples}
%\end{figure}
%
%We dispatch on \clj{:p} to distinguish the two cases of \clj{FSM}---for example on \clj{:F}
%we know the \clj{:file} is a file.
%The body of the first method uses type hints to resolve reflection
%and conditional control flow to prove null-pointer exceptions are impossible.
%The second method is similar except it uses exceptional control flow.
