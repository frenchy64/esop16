\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the key features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphaisizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behavior. By
default, it provides fast implemenations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \clj{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Typed Racket and occurrence typing}

Classic occurrence typing concentrates on conditional
control flow like the following example.

\begin{listing}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\caption{Occurrence typing}
\end{listing}

Here we include the full \clj{ns} form, which we omit in the following
examples. Going down the then branch in this example means that we know
\clj{x} is a number, which is automatically updated with occurrence typing.

In Clojure, exceptional control flow is also common, often in the form of
runtime assertions. 


\begin{listing}
\inputminted[firstline=5,lastline=7]{clojure}{code/demo/src/demo/do.clj}
\caption{Exceptional control flow}
\end{listing}

Clojure assertions expand to simple exceptional control flow,
which we enhance our sequencing \doliteral{} expression to understand.

\begin{minted}{clojure}
(fn [x :- (U nil Number)]
  (do (if (number? x) nil (throw (new Exception)))
      (inc x)))
\end{minted}

Our main insight is that occurrence typing already provides
valuable information about the left argument of \doliteral{} expressions,
namely if it returns a value, \clj{x} is a \clj{Number}.
Since the right argument is evaluated after the left, we can assume
\clj{x} is a \clj{Number} when evaluating \clj{(inc x)}, verifying
the programmer's attempt to avoid null-pointer exceptions without further annotations.

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.

HMaps track the presense and absense of entries.

$$
\clj{(HMap :mandatory {:a Num})} 
$$

is the type of a map with at least an \clj{:a} entry mapped to a number,
also written \clj{'{:a Num}}. If \clj{:b} is also known to be an absent entry
then

% '#' not allowed in mintinline
\smallskip
\begin{minted}{clojure}
  (HMap :mandatory {:a Num} :absent-keys #{:b})
\end{minted}

declares \clj{:b} absent. If the mandatory keys fully specify the
entries, we write

$$
\clj{(HMap :mandatory {:a Num} :complete? true)}.
$$

\clj{:complete?} defaults to \clj{false}.
The \clj{:optional} option 

$$
\clj{(HMap :optional {:a Num})}
$$

abbreviates the union of present and absent entries

\smallskip
\begin{minted}{clojure}
(U '{:a Num} (HMap :absent #{:a}))
\end{minted}
.


\clj{defalias} defines a custom type abbreviation, often for unions of HMaps.

\begin{listing}
\inputminted[firstline=5,lastline=8]{clojure}{code/demo/src/demo/hmap.clj}
\inputminted[firstline=26,lastline=28]{clojure}{code/demo/src/demo/hmap.clj}
\caption{A simple AST in terms of HMaps}
\end{listing}


HMaps are very malleable, including support for associate, merge and dissociate operations.

\begin{listing}
\inputminted[firstline=10,lastline=24]{clojure}{code/demo/src/demo/hmap.clj}
\caption{HMap operations}
\end{listing}

Lookups on HMaps with multiple options combined with
occurrence typing is an interesting problem.
Testing a lookup on a mandatory entry is straightforward, since we
know the lookup always succeeded.

\begin{minted}{clojure}
(fn [m :- '{:a (U nil Num)}] :- '{:a Num}
  {:pre [(number? (:a m))]}
  m)
\end{minted}

The result type is updated as expected to exclude \clj{nil}.
Testing for \clj{nil} is more complicated, since it is the sentinel
lookup failure indicator but may also appear as an entry value.
If we test for \clj{nil} in an \clj{:optional} entry, the best we learn
is that either the entry is missing or contains \clj{nil}.

\begin{minted}{clojure}
(fn [m :- (HMap :optional {:a (U nil Num)})] 
  :- (HMap :optional {:a nil})
  {:pre [(nil? (:a m))]}
  m)
\end{minted}

\subsection{Java interoperability}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.

Clojure supports \emph{type hints}, an optional type system to improve performance
and disambiguate Java calls.
Programmers communicate to the Clojure compiler via type hints
to resolve Java methods and prevent boxing in loops. Tags are propagated bidirectionally
and the programmer is free to add them where they like.

Here we use \clj{ann} to annotate static types for the function, and the type hint
\clj{^File} directs the Clojure compiler to assume \clj{f} is a \clj{File}
when resolving Java calls at compile time.

\begin{listing}
  \begin{minted}{clojure}
(ann parent [(U nil File) -> (U nil Str)]
(defn parent [^File f]
  (when f
    (.getParent f)))
  \end{minted}
\caption{Java Interoperability}
\end{listing}

While \clj{f} has the type hint \clj{File}, it also has the static type \clj{(U nil File)},
and Typed Clojure disallows invoking \clj{nil} even if the compiler
has statically resolved a method.
Typed Clojure also conservatively assumes fields and method returns are nullable,
and guarantees null-pointer exceptions cannot happen in typed code.

\subsection{Multimethod}

A multimethod in Clojure is a function with a dispatch mechanism to
of internal methods. Multimethods are created with {\clj{defmulti}}
and methods are installed via {\clj{defmethod}}.
They are called like regular functions.

\begin{minted}{clojure}
(ann rep [Any -> String])
(defmulti rep class)
(defmethod rep Number [x] (str (inc x)))
(defmethod rep Keyword [x] (str (name x)))

(rep :a) ;=> "a"
(rep 1)  ;=> "2"
\end{minted}

The \clj{class} function returns the class of an object, or \clj{nil}
if given \clj{nil}. This multimethod's dispatch function returns the class of its
argument. The underlying dispatch strategy features \clj{isa?}, a function
that is a subclassing check when provided with classes

\begin{minted}{clojure}
  (isa? Keyword Object) ;=> true
  (isa? Keyword Number) ;=> false
\end{minted}

otherwise an equality check.

\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? :a 1) ;=> false
\end{minted}

So in the previous example, \clj{(rep :a)} dispatched to the method
where \clj{(isa? (class :a) v)} returned true, where \clj{v} is the dispatch value.
Since \clj{(isa? (class :a) Keyword)} is true, the second method is chosen.

The flexibility of \clj{isa?} is key to the generality of multimethods. 
For instance, we can dispatch on the value of
a map entry, even if it is not a class.

\inputminted[firstline=4,lastline=23]{clojure}{code/demo/src/demo/eg5.clj}

\clj{isa?} is further special-case with vectors: with two vectors of the
same length, it returns the logical conjunction of the pairwise applications
of \clj{isa?}.

\begin{minted}{clojure}
  (isa? [Keyword :a] [Object :a]) ;=> true
  (isa? [Keyword Keyword] [Object Object]) ;=> true
\end{minted}

We can use this to dispatch on more than one thing. Here we perform
double dispatch on the class of each argument.

\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}

No extra annotations are needed to follow the type-directed control flow.
For instance, the middle method is has inferred the left argument is a number
and thus safe to increment, and the right argument is a keyword and safe to
extract its name.

A dispatch value can also be the keyword \clj{:default} to specify a default
method if no preferred method is found. The static type of both arguments
remains unchanged.

\subsection{Final example}

The final example combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning
and use of HMaps.

\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

