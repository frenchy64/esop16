\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

%\paragraph{Clojure Syntax}
%
%We describe new syntax as they appear in each example, but
%begin with include the essential basics of Clojure syntax.
%
%\clj{nil} is exactly Java's \java{null}.
%Parentheses indicate \emph{applications}, brackets
%delimit
%\emph{vectors}, braces
%delimit
%\emph{hash-maps}
%and double quotes delimit \emph{Java strings}.
%\emph{Symbols} begin with an alphabetic character,
%and a colon prefixed symbol like \clj{:a} is a \emph{keyword}.
%
%\emph{Commas} are always \emph{whitespace}.

\subsection{Typed Clojure}

Here is a simple program in Typed Clojure.

We define a global variable \clj{greet} as a one-argument function
taking and returning a string.

\begin{minted}{clj}
(ann  greet [Str -> Str])
(defn greet [n]
  (str "Hello, " n "!"))
(greet "Grace") ; :- Str
;=> "Hello, Grace!"
\end{minted}

The function may take strings, but providing \clj{nil} (Clojure's name for Java's \java{null})
is a static type error --- \clj{nil} is not a string in Typed Clojure.

\begin{minted}{clj}
(greet nil)    ; Type Error:
               ;   Expected Str, given nil
               ; in: nil
\end{minted}

\paragraph{Unions} We can make the annotation more permissive with \emph{ad-hoc unions}
to allow \clj{nil}.

\begin{minted}{clj}
(ann  greet-nil [(U nil Str) -> Str])
(defn greet-nil [n]
  (str "Hello" (when n (str ", " n)) "!"))
(greet-nil "Donald") ; :- Str
;=> "Hello, Donald!"
(greet-nil nil)      ; :- Str
;=> "Hello!"
\end{minted}

All Clojure values are true except \clj{nil} and \clj{false}, so the
comma is only added when the argument is non-nil.

\paragraph{Flow analysis} Typed Clojure uses occurrence typing to
model type-based control flow.
In \clj{greetings}, a \clj{when} expression ensures \clj{repeat}
is never passed a \clj{nil} argument.

\begin{minted}{clj}
(ann  greetings [Str (U nil Int) -> Str])
(defn greetings [n i]
  (str "Hello, "
       (when i
         (apply str (repeat i (str "hello, "))))
       n "!"))
(greetings "Donald" 2)  ; :- Str
;=> "Hello, hello, hello, Donald!"
(greetings "Grace" nil) ; :- Str
;=> "Hello, Grace!"
\end{minted}

Removing the \clj{when} expression is a static type error
--- \clj{repeat} cannot be passed \clj{nil}.

\begin{minted}{clj}
(ann  greetings-bad [Str (U nil Int) -> Str])
(defn greetings-bad [n i]
  (str "Hello, "
       (apply str (repeat i (str "hello, ")))
       ; Type Error:
       ;   Expected Num, given (U nil Num).
       ; in: i
       n "!"))
\end{minted}



%\subsection{Type System Basics}
%
%\citet{TF10}
%presented Typed Racket with occurrence typing,
%a technique for deriving type information from conditional control flow.
%They introduced the concept of occurrence typing 
%with the following example.
%
%\inputminted[firstline=3]{racket}{code/tr/example1.rkt}
%
%This function takes a value that is either \emph{\#f} % mintinline really hates #
%or a number, represented by an \emph{untagged} union type.
%The `then' branch has an implicit invariant
%that \rkt{x} is a number, which is automatically inferred with occurrence typing
%and type checked without further annotations.
%
%We chose to build on the ideas and implementation
%of Typed Racket to implement a type system targeting Clojure for several reasons.
%Initially, the similarities between Racket and Clojure drew us to
%investigate the effectiveness of repurposing occurrence typing
%for a Clojure type system---both languages share a Lisp heritage,
%similar standard functions 
%(for instance \clj{map}
%in both languages is variable-arity)
%and idioms.
%While Typed Racket is gradually typed and has sophisticated
%dynamic semantics for cross-language interaction, we 
%chose to first implement
%the static semantics
%with the hope to extend Typed Clojure to be gradually typed at a future date.
%Finally,
%Typed Racket's combination of bidirectional checking
%and occurrence typing presents a successful model for 
%type checking dynamically typed programs without compromising
%soundness, which is appealing over success typing~\cite{Lindahl:2006:PTI}
%which cannot prove strong properties about programs
%and soft typing~\cite{CF91}
%which has proved too complicated in practice.
%
%Here is the above program in Typed Clojure.
%\begin{exmp}
%\inputminted[firstline=5]{clojure}{code/demo/src/demo/eg1.clj}
%\label{example:conditionalflow}
%\end{exmp}
%
%The \clj{fn} macro (provided by core.typed) supports optional annotations by 
%adding
%\clj{:-} and a type after a parameter
%position
%or binding vector 
%to annotate parameter types
%and return types respectively.
%\clj{number?} is
%a Java \java{instanceof} test of \clj{java.lang.Number}.
%As in Typed Racket, \clj{U} creates an \emph{untagged union} type, which can take
%any number of types.
%
%Typed Clojure can already check all of the examples in~\citet{TF10}---the 
%rest of this section describes the extensions necessary
%to check Clojure code.


\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, invoke methods, and access fields.

\begin{minted}{clj}
  (.getParent (new File "a/b"))  ; :- (U nil Str)
  ;=> "a"
\end{minted}

If a specific constructor, method, or field cannot be found based on the
static types of its arguments, a type error is thrown.

\begin{minted}{clj}
  (fn [f] 
    (.getParent f)
    ; Type error:
    ;   Unresolved host interop: getParent
    )
\end{minted}

Function arguments default to \clj{Any}, the most permissive type. Ascribing
a parameter type helps Typed Clojure find a specific method.

%Calls to Java methods and fields have prefix notation
%like \clj{(.method target args*)} and \clj{(.field target)} respectively,
%with method and field names prefixed with a dot and methods taking some number of arguments.

\begin{exmp}
\inputminted[firstline=6,lastline=8]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

%\begin{exmp}
%\inputminted[firstline=18,lastline=19]{clojure}{code/demo/src/demo/parent3.clj}
%\end{exmp}

The conditional guards from dereferencing \clj{nil}, and as before
removing it is a static type error.

\begin{minted}{clj}
(defn parent-bad-in [f :- (U nil File)]
  (.getParent f)
  ; Type error:
  ;   Cannot call instance method 
  ;   java.io.File/getParent on type 
  ;   (U nil File).
  )
\end{minted}

Any Java method returning a reference can also return \java{null} ---
Typed Clojure rejects programs that assume otherwise.

\begin{minted}{clj}
(defn parent-bad-out [f :- File] :- Str
  (.getParent f)
  ; Type error:
  ;   Expected Str, given (U nil Str).
  ; in: (.getParent f)
  )
\end{minted}

%Typed Clojure and Java treat \java{null} differently.
%In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
%called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
%This means the Java static type \java{String} is equivalent to
%\clj{(U nil String)} in Typed Clojure.
%
%Reference types in Java are nullable, so to guarantee a method call does not
%leak \java{null} into a Typed Clojure program we
%must assume methods can return \clj{nil}.

In contrast, JVM invariants guarantee constructors return a non-null reference.\footnote{\url{http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.9.4}}

\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular non-target positions if needed.

\subsection{Multimethod}

A \emph{multimethod} is a kind of extensible function. It consists of
a \emph{dispatching function}, given with \clj{defmulti}, and a collection of \emph{methods} associated with
\emph{dispatch values}, each installed via \clj{defmethod}.

Recall the multimethod in figure~\ref{fig:ex1}. 

\begin{minted}{clj}
(ann pname [(U File String) -> (U nil String)])
(defmulti pname class)
(defmethod pname String [s] (pname (new File s)))
(defmethod pname File [f] (.getName f))
\end{minted}

Its dispatching function is
\clj{class}, with two methods associated with dispatch values \clj{java.lang.String} and \clj{java.io.File}
respectively.

When called, the dispatching function is applied to the provided arguments to
yield a \emph{dispatching value}.
The \clj{isa?} function is then used to compare the current dispatching value to each method's dispatch value.
An unambiguous match leads to the corresponding method being applied to the arguments,
giving the final result.

The following Typed Clojure program is semantically identical to figure~\ref{fig:ex1}.

\begin{minted}{clj}
(ann pname [(U Str File) -> (U nil Str)])
(defn pname [x]
  (let [dfn  class ; dispatching function
        dval (dfn x)] ; dispatching value
    (cond
      (and (isa? dval String)       ; if
           (not (isa? dval File))) 
      (pname (new File x))          ; then

      (and (not (isa? dval String)) ; else if
           (isa? dval File))       
      (.getName x)                  ; then
      :else (throw (Exception. "No match")))))
\end{minted}

The \clj{isa?} predicate 
is a subclassing check for classes, otherwise
an equality check.

\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? :a :b) ;=> false
  (isa? String Object) ;=> true
  (isa? Object String) ;=> false
\end{minted}

\subsection{Multimethods}

\label{sec:multioverview}

%A multimethod in Clojure is a function with a \emph{dispatch
%function} and a \emph{dispatch table} of methods. Multimethods are created with {\clj{defmulti}}.
%\inputminted[firstline=5,lastline=6]{clojure}{code/demo/src/demo/rep.clj}
%The multimethod \clj{path} has type \clj{[Any -> (U nil String)]}, an initially empty \emph{dispatch table}
%and \emph{dispatch function} \clj{class}, a function that
%returns the class of its argument or \clj{nil} if passed \clj{nil}.
%
%We can use {\clj{defmethod}} to install a method to \clj{path}.
%\inputminted[firstline=7,lastline=7]{clojure}{code/demo/src/demo/rep.clj}
%Now the dispatch table maps
%the \emph{dispatch value} \clj{String} to the function
%\clj{(fn [x] x)}. 
%We add another method
%which maps
%\clj{File} to the function
%\clj{(fn [x] (.getPath x))}
%in the dispatch table.
%\inputminted[firstline=8,lastline=8]{clojure}{code/demo/src/demo/rep.clj}
%
%After installing both methods, the call 
%$$
%\clj{(path (new File "dir/a"))}
%$$
%dispatches to the second method we installed because
%$$
%\clj{(isa? (class "dir/a") String)}
%$$
%is true, and finally returns 
%$$
%\clj{((fn [x] (.getPath x)) "dir/a")}.
%$$

We include the above sequence of definitions as \egref{example:rep}.

\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=10]{clojure}{code/demo/src/demo/rep.clj}
\label{example:rep}
\end{exmp}
\end{Code}

Typed Clojure does not predict if a runtime dispatch will be successful---\clj{(path :a)} 
type checks because \clj{:a} agrees with the parameter type \clj{Any},
but throws an error at runtime.

\paragraph{HMap dispatch} The flexibility of \clj{isa?} is key to the generality of multimethods. 
In \egref{example:incmap} we
dispatch on the \clj{:op} key 
of our HMap AST \clj{Expr}.
Since keywords are functions that look themselves up in their argument, we simply
use \clj{:op} as the dispatch function.

\begin{exmp}
\inputminted[firstline=5,lastline=18]{clojure}{code/demo/src/demo/eg5.clj}
\label{example:incmap}
\end{exmp}

The function \clj{inc-leaf} is like \egref{example:decmap} except the nodes are incremented.
The reasoning is similar, except we only consider one branch (the current method) by
locally considering the current \emph{dispatch value} and reasoning about how it relates
to the \emph{dispatch function}.
For example, 
in the \clj{:do} method we learn the \clj{:op} key is a \clj{:do}, which
narrows our argument type to the \clj{:do} Expr, and similarly for the \clj{:if}
and \clj{:const} methods.

\paragraph{Multiple dispatch} \clj{isa?} is special with vectors---vectors of the
same length recursively call \clj{isa?} on the elements pairwise.
\begin{minted}{clojure}
  (isa? [Keyword Keyword] [Object Object]) ;=> true
\end{minted}

\egref{example:multidispatch}
simulates multiple dispatch by dispatching on
a vector containing the class of both arguments. \clj{open}
takes two arguments which can be strings or files and returns
a new file that concatenates their paths.

We call three different \clj{File} constructors, each known at compile-time
via type hints.
Multiple dispatch follows the same kind of reasoning as \egref{example:incmap},
except we update multiple bindings simultaneously.

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{exmp}
\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decleaf}
\end{exmp}

%The \clj{defn} macro defines a top-level function, with syntax like the typed \clj{fn}.
%The function \clj{an-exp} is verified to return an \clj{Expr}.
%
Here \clj{defalias} defines \clj{Expr}, a type abbreviation
that describes the structure of a recursively-defined AST as a union of HMaps.
A quoted keyword in a type --- \clj{':if} --- is a singleton type that contains just the keyword.
A type that is a quoted map like \clj{'{:op ':if}} is a
HMap type with a fixed number of keyword entries of the specified types
known to be \emph{present},
zero entries known to absolutely be \emph{absent},
and an infinite number of \emph{unknown} entries entries.
Since only keyword keys are allowed, they do not require quoting.

\paragraph{HMaps in Practice} The next example is extracted from a production system at CircleCI,
a company with a large production Typed Clojure system
(section~\ref{sec:casestudy} presents a case study).

\begin{exmp}
\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
\label{example:circleci}
\end{exmp}

\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
dissociating the raw \clj{:private-key} entry with \clj{dissoc}
and associating an encrypted private key
as \clj{:enc-private-key} on an immutable map with \clj{assoc}.
The expression \clj{(:private-key kp)} shows that keywords are also 
functions that look themselves up in a map returning the associated value or \nil{} if the key is missing.
Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
operation forgot to remove it.

\egref{example:absentkeys}
is like \egref{example:circleci}
except the \clj{:absent-keys} HMap option is used
instead of \clj{:complete?},
which takes a \emph{set literal} of keywords that do not appear in the map, written 
with \emph{\#}-prefixed braces.
The syntax \clj{(fn [{pkey :private-key, :as kp}] ...)}
aliases \clj{kp} to the first argument and \clj{pkey} to \clj{(:private-key m)}
in the function body.

\begin{exmp}
\inputminted[firstline=10,lastline=21]{clojure}{code/demo/src/demo/key2.clj}
\label{example:absentkeys}
\end{exmp}

Since this example enforces that \clj{:private-key} must not appear
in a \clj{EncKeyPair}
Typed Clojure would still complain if we forgot to \clj{dissoc} \clj{:private-key}
from the return value.
Now, however we could stash the raw private key in another entry
like \clj{:secret-key} which is not mentioned by the partial HMap \clj{EncKeyPair}
without Typed Clojure noticing.

\paragraph{Branching on HMaps} Finally, testing on HMap properties
allows us to refine its type down branches. \clj{dec-map} takes an
\clj{Expr}, traverses to its nodes and decrements their values by \clj{dec}, then
builds the \clj{Expr} back up with the decremented nodes.

\begin{exmp}
\inputminted[linenos,firstnumber=1,firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decmap}
\end{exmp}

If we go down the then branch (line 4), since \clj{(= (:op m) :if)} is true
we remove
the \clj{:do} and \clj{:const}
Expr's from the type of \clj{m} (because their respective \clj{:op} entries disagrees with \clj{(= (:op m) :if)})
and we are left with an \clj{:if} Expr.
On line 8,
we instead strike out the \clj{:if} Expr since it contradicts \clj{(= (:op m) :if)} being false. 
Line 9 know we can
remove the \clj{:const} Expr from the type of \clj{m} because it contradicts \clj{(= (:op m) :do)} being true,
and we know \clj{m} is a \clj{:do} Expr.
Line 12 we strike out \clj{:do} because \clj{(= (:op m) :do)} is false,
so we are left with \clj{m} being a \clj{:const} Expr.

Section~\ref{sec:formalpaths} discusses how this automatic reasoning is achieved.

\subsection{Final example}

\egref{example:final}
combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning,
and HMaps. 


\begin{figure}
\begin{exmp}
\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}
\label{example:multidispatch}
\end{exmp}
\begin{exmp}
\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
\label{example:final}
\end{exmp}
\caption{Multimethod Examples}
\end{figure}

We dispatch on \clj{:p} to distinguish the two cases of \clj{FSM}---for example on \clj{:F}
we know the \clj{:file} is a file.
The body of the first method uses type hints to resolve reflection
and conditional control flow to prove null-pointer exceptions are impossible.
The second method is similar except it uses exceptional control flow.
