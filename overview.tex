\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the core features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \java{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Clojure Syntax}

We describe new syntax as they appear in each example, but
we also include the essential basics of Clojure syntax.

\clj{nil} is exactly Java's \java{null}.
Parentheses indicate \emph{applications}, brackets
delimit
\emph{vectors}, braces
delimit
\emph{hash-maps}
and double quotes delimit \emph{Java strings}.
\emph{Symbols} begin with an alphabetic character,
and a colon prefixed symbol like \clj{:a} is a \emph{keyword}.

\emph{Commas} are always \emph{whitespace}.

\subsection{Typed Racket and occurrence typing}

\citet{TF10}
presented Typed Racket with occurrence typing,
a technique for deriving type information from conditional control flow.
They introduced the concept of occurrence typing 
with the following example.

\inputminted[firstline=1]{racket}{code/tr/example1.rkt}

This function takes a value that is either \emph{\#f} % mintinline really hates #
or a number, represented by an \emph{untagged} union type.
The `then' branch has an implicit invariant
that \rkt{x} is a number, which is automatically inferred with occurrence typing
and type checked without further annotations.

We chose to build on the ideas and implementation
of Typed Racket to implement a type system targeting Clojure for several reasons.
Initially, the similarities between Racket and Clojure drew us to
investigate the effectiveness of repurposing occurrence typing
for a Clojure type system---both languages share a Lisp heritage,
similar standard functions 
(for instance \clj{map}
in both languages is variable-arity)
and idioms.
While Typed Racket is gradually typed and has sophisticated
dynamic semantics for cross-language interaction, we 
chose to first implement
the static semantics
with the hope to extend Typed Clojure to be gradually typed at a future date.
Finally,
Typed Racket's combination of bidirectional checking
and occurrence typing presents a successful model for 
type checking dynamically typed programs without compromising
soundness, which is appealing over success typing~\cite{todo-dialyzer-paper}
which cannot prove strong properties about programs
and soft typing~\cite{successtyping-todo}
which has proved too complicated in practice.

Here is the above program in Typed Clojure.

\begin{exmp}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\label{example:conditionalflow}
\end{exmp}

This is a regular Clojure file compiled with
the Clojure compiler, with the \clj{ns} form
declaring a
\emph{namespace}
for managing var and class imports.
Here \clj{:require} declares a runtime dependency 
on
\clj{clojure.core.typed},
Typed Clojure's core namespace, and
\clj{:refer}
brings a collection of vars into scope by name.
The \clj{:refer-clojure} \clj{:exclude} option unmaps core vars from the current 
namespace---here we unmap \clj{clojure.core/fn},
which creates a function from a parameter vector and a body expression,
and import a typed variant of \clj{fn}
that supports type annotations.

The typed \clj{fn} supports optional annotations by 
adding
\clj{:-} and a type after a parameter
position
or binding vector 
to annotate parameter types
and return types respectively.
Typed Clojure provides a \clj{check-ns} function to type checks the current namespace.
\clj{number?} is
a Java \java{instanceof} test of \clj{java.lang.Number}.
As in Typed Racket, \clj{U} creates an \emph{untagged union} type, which can take
any number of types.

Typed Clojure can already check all of the examples in~\citet{TF10}---the 
rest of this section describes the extensions necessary
to check Clojure code.

\subsection{Exceptional control flow}

Along with conditional control flow,
Clojure programmers rely on \emph{exceptions}
to assert type-related invariants.

\begin{exmp}
\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
\label{example:doexception}
\end{exmp}

The \clj{do} form sequences two expressions returning the latter,
\clj{throw} corresponds to Java's \java{throw}
and \clj{(class. args*)} is the syntax for Java constructors---that 
is a class name with a dot suffix as the operator followed the arguments to the constructor.

In this example a \clj{throw} expression guards \clj{(inc x)}, the increment function for numbers,
from being evaluated if \clj{x} is \clj{nil}, preventing
a possible null-pointer exception.

To check this example,
occurrence typing 
automatically
assumes
\clj{x} is a number when checking the second \clj{do} subexpression
based on the first subexpression.
\footnote{See \url{https://github.com/typedclojure/examples}
  for full examples. From here we omit \clj{ns} forms.}
We model this formally (section~\ref{sec:doformal}) and prove
null-pointer exceptions are impossible in typed code (section~\ref{sec:metatheory}).

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{exmp}
\inputminted[firstline=6,lastline=13]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decleaf}
\end{exmp}

The \clj{defn} macro defines a top-level function, with syntax like the typed \clj{fn}.
The function \clj{an-exp} is verified to return an \clj{Expr}.

The \clj{defalias} macro defines a type abbreviation which can reference itself recursively.
Here \clj{defalias} defines \clj{Expr}
that describes the structure of a recursively-defined AST as a union of HMaps.
A quoted keyword in a type, such as \clj{':if}, is a singleton type that contains just the keyword.
A type that is a quoted map like \clj{'{:op ':if}} is a
HMap type with a fixed number of keyword entries of the specified types
known to be \emph{present},
zero entries known to absolutely be \emph{absent},
and an infinite number of \emph{unknown} entries entries.
Since only keyword keys are allowed, they do not require quoting.

\paragraph{HMaps in Practice} The next example is extracted from a production system at CircleCI,
a company with a large production Typed Clojure system
(section~\ref{sec:casestudy} presents a case study).

\begin{exmp}
\inputminted[firstline=10,lastline=22]{clojure}{code/demo/src/demo/key.clj}
\label{example:circleci}
\end{exmp}

\clj{enc-keypair} takes an unencrypted keypair and returns an encrypted keypair by
non-destructively dissociating the raw \clj{:private-key} entry with \clj{dissoc}
and associating an encrypted private key
as \clj{:enc-private-key} on an immutable map with \clj{assoc}.
The expression \clj{(:private-key kp)} shows that keywords are also 
functions that look themselves up in a map returning the associated value or \nil{} if the key is missing.
Since \clj{EncKeyPair} is \clj{:complete?}, Typed Clojure enforces the return type
does not contain an entry \clj{:private-key}, and would complain if the \clj{dissoc}
operation forgot to remove it.

The next example is the same except we use the \clj{:absent-keys} HMap option.
We also
utilize \emph{map destructuring}, which is binding position syntax for pattern matching.
Parameters are replaced with maps of symbols to keywords that bind the symbols
to lookups on that keyword, optionally terminated by \clj{:as}
which aliases the parameter. For example
\clj{(fn [{^File x :x, :as m}] ...)}
expands to a \clj{let} binding \clj{m} to the first argument and 
\clj{^File x} to \clj{(:x m)}.
Clojure's \clj{let} takes a flat binding vector which can refer to previous bindings like Scheme's \mintinline{scheme}{let*},
and a body expression.

\begin{exmp}
\inputminted[firstline=10,lastline=21]{clojure}{code/demo/src/demo/key2.clj}
\end{exmp}

Since this example enforces that \clj{:private-key} must not appear
in a \clj{EncKeyPair}
Typed Clojure would still complain if we forgot to \clj{dissoc} \clj{:private-key}
from the return value.
Now, however we could stash the raw private key in another entry
like \clj{:secret-key} which is not mentioned by the partial HMap \clj{EncKeyPair}
without Typed Clojure noticing.

\paragraph{Branching on HMaps} Finally, testing on HMap properties
allows us to refine its type down branches. \clj{dec-map} takes an
\clj{Expr}, traverses to its nodes and decrements their values by \clj{dec}, then
builds the \clj{Expr} back up with the decremented nodes.

\begin{exmp}
\inputminted[linenos,firstnumber=1,firstline=15,lastline=27]{clojure}{code/demo/src/demo/hmap.clj}
\label{example:decmap}
\end{exmp}

If we go down the then branch (line 4), since \clj{(= (:op m) :if)} is true
we remove
the \clj{:do} and \clj{:const}
Expr's from the type of \clj{m} (because their respective \clj{:op} entries disagrees with \clj{(= (:op m) :if)})
and we are left with an \clj{:if} Expr.
On line 8,
we instead strike out the \clj{:if} Expr since it contradicts \clj{(= (:op m) :if)} being false. 
Line 9 know we can
remove the \clj{:const} Expr from the type of \clj{m} because it contradicts \clj{(= (:op m) :do)} being true,
and we know \clj{m} is a \clj{:do} Expr.
Line 12 we strike out \clj{:do} because \clj{(= (:op m) :do)} is false,
so we are left with \clj{m} being a \clj{:const} Expr.

Section~\ref{sec:formalpaths} discusses how this automatic reasoning is achieved.

\subsection{Java interoperability}
\label{sec:overviewjavainterop}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.

\begin{minted}{clj}
  (fn [f] (.getParent f))
\end{minted}

Calls to Java methods and fields have prefix notation
like \clj{(.method target args*)} and \clj{(.field target)} respectively,
with method and field names prefixed with a dot and methods taking some number of arguments.

Unlike Java, Clojure is dynamically typed. We have no type information about \clj{f}
but we still need to pick a method to call. The Clojure compiler delegates
the choice to runtime using \emph{Java reflection}.
Unfortunately reflection is slow and unpredictable, so Clojure supports \emph{type hints}
to help eliminate it where possible, 

\begin{minted}{clj}
  (fn [^File f] (.getParent f))
\end{minted}

Symbols support \emph{metadata}---the syntax \clj{^File f}
is a single expression that is a symbol \clj{f} with metadata \clj{{:tag File}}.
In binding positions like \clj{(fn [^File f] ...)}
syntactic occurrences preserve metadata.

The Clojure compiler uses the type hint
to statically resolve 
the method call to the
\mintinline{java}{public String getParent()}
method of \clj{java.io.File}.
The call to \clj{getParent} is unambiguous at runtime but type 
checking fails---Typed Clojure
considers \clj{f} to be of type \clj{Any}, which is unsafe 
to use as the target of even a resolved method.
If instead we annotate the function parameter with type \clj{File},
we get a static type error.

\begin{minted}{clj}
  (fn [f :- File] (.getParent f)) ;; type error
\end{minted}

Typed Clojure disallows reflection in typed code
so we must add back the type hint to obtain a well-typed
expression.

\begin{exmp}
\inputminted[firstline=10,lastline=10]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

% type hints give no guarantees
% TODO

The type hinting system and Typed Clojure's static type checking
are separate, the latter predating the former by several years.
The interaction between them is often not as obvious, for example Typed Clojure
has an explicit type for \clj{null}
null-pointer exceptions are impossible.

do not need to take \clj{nil} into account, 

\begin{exmp}
\inputminted[firstline=18,lastline=19]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

Typed Clojure and Java treat \java{null} differently.
In Clojure, where it is known as \clj{nil}, Typed Clojure assigns it an explicit type
called \clj{nil}. In Java \java{null} is implicitly a member of any reference type.
This means the Java static type \java{String} is equivalent to
\clj{(U nil String)} in Typed Clojure.

Reference types in Java are nullable, so to guarantee a method call does not
leak \java{null} into a Typed Clojure program we
must assume methods can return \clj{nil}.

\begin{exmp}
\inputminted[firstline=6,lastline=8]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

In contrast, JVM invariants guarantee that  constructors cannot return \java{null},
so we are safe to assume constructors are non-nullable.

\begin{exmp}
\inputminted[firstline=15,lastline=16]{clojure}{code/demo/src/demo/parent3.clj}
\end{exmp}

By default Typed Clojure conservatively assumes method and constructor arguments to be \emph{non-nullable},
but can be configured globally for particular positions if needed.

\subsection{Multimethods}

\label{sec:multioverview}

A multimethod in Clojure is a function with a \emph{dispatch
function} and a \emph{dispatch table} of methods. Multimethods are created with {\clj{defmulti}}.
\inputminted[firstline=5,lastline=6]{clojure}{code/demo/src/demo/rep.clj}
The multimethod \clj{path} has type \clj{[Any -> (U nil String)]}, an initially empty \emph{dispatch table}
and \emph{dispatch function} \clj{class}, a function that
returns the class of its argument or \clj{nil} if passed \clj{nil}.

We can use {\clj{defmethod}} to install a method to \clj{path}.
\inputminted[firstline=7,lastline=7]{clojure}{code/demo/src/demo/rep.clj}
Now the dispatch table maps
the \emph{dispatch value} \clj{String} to the function
\clj{(fn [x] x)}. 
We add another method
which maps
\clj{File} to the function
\clj{(fn [^File x] (.getPath x))}
in the dispatch table.
\inputminted[firstline=8,lastline=8]{clojure}{code/demo/src/demo/rep.clj}

After installing both methods, the call 
$$
\clj{(path (File. "dir/a"))}
$$
dispatches to the second method we installed because
$$
\clj{(isa? (class "dir/a") String)}
$$
is true, and finally returns 
$$
\clj{((fn [^File x] (.getPath x)) "dir/a")}.
$$

The \clj{isa?} function first tries an equality check
on its arguments, then if that fails
and both arguments are classes a subclassing
check is returned.
\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? Keyword Object) ;=> true
\end{minted}

We include the above sequence of definitions as example~\ref{example:rep}.

\begin{Code}
\begin{exmp}
\inputminted[firstline=5,lastline=10]{clojure}{code/demo/src/demo/rep.clj}
\label{example:rep}
\end{exmp}
\end{Code}

Typed Clojure does not predict if a runtime dispatch will be successful---\clj{(path :a)} 
type checks because \clj{:a} agrees with the parameter type \clj{Any},
but throws an error at runtime.

\paragraph{HMap dispatch} The flexibility of \clj{isa?} is key to the generality of multimethods. 
In example~\ref{example:incmap} we
dispatch on the \clj{:op} key 
of our HMap AST \clj{Expr}.
Since keywords are functions that look themselves up in their argument, we simply
use \clj{:op} as the dispatch function.

\begin{exmp}
\inputminted[firstline=5,lastline=18]{clojure}{code/demo/src/demo/eg5.clj}
\label{example:incmap}
\end{exmp}

\clj{inc-map} is like example~\ref{example:decmap} except the nodes are incremented.
The reasoning is similar, except we only consider one branch (the current method) by
locally considering the current \emph{dispatch value} and reasoning about how it relates
to the \emph{dispatch function}.
For example, 
in the \clj{:do} method we learn the \clj{:op} key is a \clj{:do}, which
narrows our argument type to the \clj{:do} Expr, and similarly for the \clj{:if}
and \clj{:const} methods.

\paragraph{Multiple dispatch} \clj{isa?} is special with vectors---vectors of the
same length recursively call \clj{isa?} on the elements pairwise.
\begin{minted}{clojure}
  (isa? [Keyword Keyword] [Object Object]) ;=> true
\end{minted}

Example~\ref{example:multidispatch}
simulates multiple dispatch by dispatching on
a vector containing the class of both arguments. \clj{open}
takes two arguments which can be strings or files and returns
a new file that concatenates their paths.

We call three different \clj{File} constructors, each known at compile-time
via type hints.
Multiple dispatch follows the same kind of reasoning as example~\ref{example:incmap},
except we update multiple bindings simultaneously.

\subsection{Final example}

Example~\ref{example:final}
combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning,
and HMaps. 


\begin{figure}
\begin{exmp}
\inputminted[firstline=6,lastline=22]{clojure}{code/demo/src/demo/eg7.clj}
\label{example:multidispatch}
\end{exmp}
\begin{exmp}
\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}
\label{example:final}
\end{exmp}
\caption{Multimethod Examples}
\end{figure}

We dispatch on \clj{:p} to distinguish the two cases of \clj{FSM}---for example on \clj{:F}
we know the \clj{:file} is a file.
The body of the first method uses type hints to resolve reflection
and conditional control flow to prove null-pointer exceptions are impossible.
The second method is similar except it uses exceptional control flow.





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

