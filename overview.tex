\section{Overview of Typed Clojure}

\label{sec:overview}

We now begin a tour of the central features of Typed Clojure,
beginning with Clojure itself. In our presentation, we will make 
use of the full Typed Clojure system to illustrate the key type system
ideas, before studying the key features in detail in
section~\ref{sec:formal}. 

\subsection{Clojure}

Clojure~\cite{Hic08} is a Lisp built to run on the
Java Virtual Machine with exemplary support for concurrent programming
and immutable data structures. It emphasizes mostly-functional
programming, restricting imperative updates to a limited set of
structures which have specific thread synchronization behaviour. By
default, it provides fast implementations of immutable lists, vectors,
and hash tables, which are used for most data structures, although it
also provides means for defining new records.

One of Clojure's primary advantages is easy interoperation with
existing Java libraries. It automatically generates appropriate JVM
bytecode to make Java method and constructor calls, and treats Java
values as any other Clojure value. However, this smooth
interoperability comes at the cost of pervasive \clj{null}, which
leads to the possibility of null pointer exceptions---a drawback we
address in Typed Clojure.

\subsection{Typed Racket and occurrence typing}

Tobin-Hochstadt and Felleisen~\cite{TF10}
introduced Typed Racket with occurrence typing,
an inference technique for conditional control flow.
They introduce the concept of occurrence typing 
with the following example.

\inputminted[firstline=1]{racket}{code/tr/example1.rkt}

This function takes a value that is either \emph{\#f} % mintinline really hates #
or a number, represented by an untagged \emph{union type}.
The `then' branch has an implicit invariant
that \rkt{x} is a number, which is automatically inferred with occurrence typing
and type checked without further annotations.
Here is same program in Typed Clojure.

\begin{exmp}
\inputminted[firstline=1]{clojure}{code/demo/src/demo/eg1.clj}
\end{exmp}

Clojure uses \emph{namespaces}, declared with the
\clj{ns} form, to manage top-level \emph{vars}.
This is a regular Clojure file compiled with
the Clojure compiler except it declares a runtime dependency on
\clj{clojure.core.typed}, Typed Clojure's core namespace.
Programmers import typed versions of certain constructs as needed, like
a \clj{fn} variant that support annotations,
and use the provided \clj{check-ns} function to type check the current namespace
when convenient.

Typed Clojure can check all the examples in the occurrence typing
paper---the rest of this section describes the extensions necessary
to check Clojure code.

\subsection{Exceptional control flow}

Along with conditional control flow,
Clojure programmers rely on \emph{exceptions}
to assert type-related invariants.

\begin{exmp}
\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
\end{exmp}

We combine the sequencing form \clj{do} and a thrown exception with
\clj{throw} to avoid a possible null-pointer exception by incrementing \clj{nil}.
(We omit \clj{ns} forms for the rest of the examples).

To check this example, we note that
occurrence typing already provides
valuable information about the conditional expression---namely that it cannot return logically true and if it returns logically false 
then \clj{x} is a \clj{Number}. Equivalently, if it returns a value then \clj{x} is a \clj{Number}.
We use this assumption to check \clj{(inc x)}, automatically
ruling out the possibility of null-pointer exceptions
(said formally in section~\ref{sec:doformal}).

\subsection{Heterogeneous hash-maps}

Hash-maps with keyword keys play a major role in Clojure programming.
HMap types model the most common usages of keyword maps.

\begin{exmp}
\begin{listing}
\inputminted[firstline=5,lastline=8]{clojure}{code/demo/src/demo/hmap.clj}
\inputminted[firstline=26,lastline=28]{clojure}{code/demo/src/demo/hmap.clj}
\end{listing}
\end{exmp}

Here we define a type abbreviation with \clj{defalias} called \clj{Expr}
that describes the structure of a recursively-defined AST as a union of HMaps.
\clj{an-exp} is a function verified to return an \clj{Expr}.

HMaps support various options to track the presence and absence of entries.
\clj{'{:a Num}} is a shorthand for the \clj{:mandatory} option---entries that
must be present:
$$
\clj{(HMap :mandatory {:a Num})}.
$$

\clj{:absent-keys} is a set of keywords that are known to not have entries.
The value \clj{{:a 1 :b nil}} is not a member of the type
% '#' not allowed in mintinline
\smallskip
\begin{minted}{clojure}
  (HMap :mandatory {:a Num} :absent-keys #{:b}).
\end{minted}

\clj{:optional} is a map that declares entries either absent or
present with a specific type. Concretely
$$
\clj{(HMap :optional {:a Num})}
$$
is the same as
\begin{minted}{clojure}
      (U '{:a Num} (HMap :absent-keys #{:a})).
\end{minted}


\clj{:complete?} is \clj{true} if there are no further entries
than those declared \clj{:mandatory} or \clj{:optional}.

\clj{:mandatory}, \clj{:optional} and \clj{:absent-keys} default to empty
and \clj{:complete?} defaults to \clj{false}.

HMaps interact with occurrence typing in interesting ways.
What do we learn about the map \clj{m} in the following test?

\begin{exmp}
\inputminted[firstline=5,lastline=9]{racket}{code/demo/src/demo/hmap_path.clj}
\end{exmp}

In the then branch Typed Clojure infers \clj{'{:a Num}}, in the else branch
\clj{(HMap :optional {:a nil})}. Failed lookups return \clj{nil},
so we cannot distinguish between \clj{'{:a nil}} and \clj{(HMap :optional {:a nil})}
by testing the result of looking up \clj{:a}.
Section~\ref{sec:hmapformal} discusses this in greater detail.

\subsection{Java interoperability}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields.

Clojure supports \emph{type hints}, an optional type system to improve performance
and disambiguate Java calls.
Programmers communicate to the Clojure compiler via type hints
to resolve Java methods and prevent boxing in loops. Tags are propagated bidirectionally
and the programmer is free to add them where they like.

Here we use \clj{ann} to annotate static types for the function, and the type hint
\clj{^File} directs the Clojure compiler to assume \clj{f} is a \clj{File}
when resolving Java calls at compile time.

\begin{listing}
  \begin{minted}{clojure}
(ann parent [(U nil File) -> (U nil Str)]
(defn parent [^File f]
  (when f
    (.getParent f)))
  \end{minted}
\caption{Java Interoperability}
\end{listing}

While \clj{f} has the type hint \clj{File}, it also has the static type \clj{(U nil File)},
and Typed Clojure disallows invoking \clj{nil} even if the compiler
has statically resolved a method.
Typed Clojure also conservatively assumes fields and method returns are nullable,
and guarantees null-pointer exceptions cannot happen in typed code.

\subsection{Multimethod}

A multimethod in Clojure is a function with a dispatch mechanism to
of internal methods. Multimethods are created with {\clj{defmulti}}
and methods are installed via {\clj{defmethod}}.
They are called like regular functions.

\begin{minted}{clojure}
(ann rep [Any -> String])
(defmulti rep class)
(defmethod rep Number [x] (str (inc x)))
(defmethod rep Keyword [x] (str (name x)))

(rep :a) ;=> "a"
(rep 1)  ;=> "2"
\end{minted}

The \clj{class} function returns the class of an object, or \clj{nil}
if given \clj{nil}. This multimethod's dispatch function returns the class of its
argument. The underlying dispatch strategy features \clj{isa?}, a function
that is a subclassing check when provided with classes

\begin{minted}{clojure}
  (isa? Keyword Object) ;=> true
  (isa? Keyword Number) ;=> false
\end{minted}

otherwise an equality check.

\begin{minted}{clojure}
  (isa? :a :a) ;=> true
  (isa? :a 1) ;=> false
\end{minted}

So in the previous example, \clj{(rep :a)} dispatched to the method
where \clj{(isa? (class :a) v)} returned true, where \clj{v} is the dispatch value.
Since \clj{(isa? (class :a) Keyword)} is true, the second method is chosen.

The flexibility of \clj{isa?} is key to the generality of multimethods. 
For instance, we can dispatch on the value of
a map entry, even if it is not a class.

\inputminted[firstline=4,lastline=23]{clojure}{code/demo/src/demo/eg5.clj}

\clj{isa?} is further special-case with vectors: with two vectors of the
same length, it returns the logical conjunction of the pairwise applications
of \clj{isa?}.

\begin{minted}{clojure}
  (isa? [Keyword :a] [Object :a]) ;=> true
  (isa? [Keyword Keyword] [Object Object]) ;=> true
\end{minted}

We can use this to dispatch on more than one thing. Here we perform
double dispatch on the class of each argument.

\inputminted[firstline=6,lastline=23]{clojure}{code/demo/src/demo/eg7.clj}

No extra annotations are needed to follow the type-directed control flow.
For instance, the middle method is has inferred the left argument is a number
and thus safe to increment, and the right argument is a keyword and safe to
extract its name.

A dispatch value can also be the keyword \clj{:default} to specify a default
method if no preferred method is found. The static type of both arguments
remains unchanged.

\subsection{Final example}

The final example combines everything we will cover for the rest of the paper:
multimethod dispatch, reflection resolution via type hints, Java method
and constructor calls, conditional and exceptional flow reasoning
and use of HMaps.

\inputminted[firstline=6,lastline=20]{clojure}{code/demo/src/demo/eg8.clj}





%% Old stuff vvvv


% TODO references
% why is TR such a good base?
% - immutability
% - common lisp ancestry
% differences?
% - Clojure is built on JVM
% - interop with JVM
% - Clojure's idiomatic primitives are different
% - multimethods + protocols
% - less sophisticated macro system
%  - not an issue
%  - implementation difference, AST walking vs syntax walking


%Typed Clojure is a gradual type system for Clojure. It is designed
%to type check normal Clojure code by adding annotations. It is implemented
%as a library, and can be seamlessly included in any Clojure project; no
%separate compiler or language is needed.
%
%{\smallsection {Based on Typed Racket}}
%Initially, the similarities between untyped Racket and Clojure and Typed Racket's 
%ability to type check Racket code led us to investigate a similar type system for Clojure.
%After two years of development, the solid basis of Typed Racket 
%helps us type check many Clojure idioms without significant differences
%in implementation or theory. We found that extending Typed Clojure to check
%those idioms that have no obvious Racket equivalent did not significantly alter the structure
%of the type system.
%
%{\smallsection {Occurrence typing}}
%\citet{TF08,TF10} developed \emph{occurrence typing}, which helps improve types at branches.
%Typed Clojure uses occurrence typing in a similar way to Typed Racket, with
%some extensions (discussed in in Section [?]). %FIXME
%
%{\smallsection {Practical Variable-Arity Polymorphism}}
%Functions with non-trivial variable parameters are common in Racket.
%For example, Racket provides \emph{map} which takes a function and a
%variable number of collections and applies the function simultaneously
%to each element of the provided collections, returning a list of results.
%\citet*{STF09} developed a practical system that handles advanced variable parameters
%which can handle applications of functions like \emph{map}.
%
%Clojure has a similar emphasis on variable-arity functions. In some ways,
%Clojure's core library encourages even more complicated variable-parameter schemes.
%The \emph{assoc} core function, for example, takes three parameters and
%then a quantity of variable parameters that is a multiple of two.
%This is beyond what Typed Racket (and Typed Clojure) can currently handle. 
%
%Functions like \emph{map} are common in Clojure, so we provide an implementation
%of variable-arity polymorphism which has similar capabilities as Typed Racket's
%implementation.
%
%{\smallsection {Local Type Inference}}
%We use Pierce and Turner's Local Type Inference~\cite{PT00} to infer some polymorphic
%applications. Our implementation is based on Typed Racket's, which has extensions
%to support applications of polymorphic variable-arity functions like \emph{map}.
%
%{\smallsection {Unions and intersections}}
%Like Typed Racket, we include union and ordered intersection types. Unions define
%a least-upper-bound for a set of types. For example, we can express a type that is
%either \Number or \Symbol by including them in a union: {\Union {\Number} {\Symbol}}
%
%Ordered intersections (described further by \citet{SA+12})
%are used for overloading function types. We can express a function that takes
%a \Number and returns a \Symbol, and vice-versa with an ordered intersection function type:
%
%\begin{lstlisting}[label=lst:ordered]
%(Fn [Number -> Symbol]
%    [Symbol -> Number])
%\end{lstlisting}
%
%As our intersections are \emph{ordered}, we can express fine invariants in the
%case where arity parameter types overlap. Similar to a pattern match, earlier arities 
%are tried first, and the first arity to match ``wins''.
%
%For example, applying an \lstinline|Integer| argument to a function of type
%
%\begin{lstlisting}
%(Fn [Integer -> Integer]
%    [Number -> Number])
%\end{lstlisting}
%
%returns an \lstinline|Integer|. Reversing the arities however gives
%type \lstinline|Number|, because the arity taking a \lstinline|Number|
%always matches first.
%
%{\smallsection {Hosted on the Java Virtual Machine}}
%Clojure is built to run on the Java Virtual Machine (JVM),
%offering good interoperability with existing Java code.
%Typed Clojure helps programmers correctly call Java code
%by integrating with Java's type system.
%
%We give Java arrays and Java's \emph{null} special treatment
%when involved with interoperability. Arrays are treated as \emph{read-only}
%when sourced from Java methods, discussed in Section \ref{sec:arrays}.
%We are explicit, and conservative by default, in the positions where
%Java's \emph{null} can be passed, discussed in Section \ref{sec:null}.

