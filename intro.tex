\section{Clojure with static typing}

% current situation 

The popularity of dynamically-typed languages in software
development, combined with a recognition that types often improve
programmer productivity, software reliability, and performance, has
led to the recent development of a wide variety of optional and
gradual type systems aimed at checking existing programs written in
existing languages.  These include  TypeScript and Flow for
JavaScript, Hack for PHP, and MyPy
for Python among the optional systems, and Typed Racket, Reticulated
Python, and GradualTalk among gradually-typed systems.\footnote{We
  use ``gradual typing'' for systems like Typed Racket with sound
  interoperation between typed and untyped code; Typed Clojure or
 TypeScript which don't
  enforce type invariants we describe as ``optionally typed''.}
%FIXME: add citations for all those systems.

One key lesson of these systems, indeed a lesson known to early
developers of optional type systems such as StrongTalk, is that type
systems for existing languages must be designed to work with the
features and idioms of the target language. Often this takes the form
of a core language, be it of functions or classes and objects,
together with extensions to handle distinctive language features.


We synthesize these lessons to present \emph{Typed Clojure}, an
optional type system for Clojure. 
%
Clojure is a dynamically
typed language in the Lisp family built to run on the Java Virtual
Machine (JVM) which has recently gained popularity as an alternative
JVM language.  It offers the flexibility of a Lisp dialect, including
macros, emphasizes a functional style via a
standard library of immutable data structures, and provides
interoperability with existing Java code, allowing programmers to use
existing Java libraries without leaving Clojure.
%
Since its initial release in 2007, Clojure has been widely adopted for
``backend'' development in places where its support for parallelism,
functional programming, and Lisp-influenced abstraction is desired on
the JVM. As a result, it now has an extensive base of existing untyped
programs, whose developers can now benefit from Typed Clojure. As
a result, Typed Clojure is used in industry, experience we discuss
in this paper.



Since Clojure is a language in the
Lisp family, we apply the lessons of Typed Racket, an existing gradual type
system for Racket, to the core of Typed Clojure, consisting of an extended
$\lambda$-calculus over a variety of base types shared between all Lisp systems.
%
Furthermore, Typed Racket's \emph{occurrence typing} has proved
necessary for type checking realistic Clojure programs.

\begin{figure}[t!]
\inputminted[firstline=15]{clojure}{code/demo/src/demo/ex-intro.clj}
\caption{A simple Typed Clojure program}
\label{fig:ex1}
\end{figure}


However, Clojure goes beyond Racket in many ways, requiring several
new type system features which we detail in this paper.
%
Most significantly, Clojure supports, and Clojure developers use,
\textbf{multimethods} to structure their code in extensible
fashion. Furthermore, since Clojure is an untyped language, dispatch
within multimethods is determined by application of dynamic predicates
to argument values. 
%
Fortunately, the dynamic dispatch used by multimethods has surprising
symmetry with the conditional dispatch handled by occurrence
typing. Typed Clojure is therefore able to effectively handle complex
and highly dynamic dispatch as present in existing Clojure programs. 

But multimethods are not the only Clojure feature crucial to type
checking existing programs. As a language built on the Java Virtual
Machine, Clojure provides flexible and transparent access to existing
Java libraries, and \textbf{Clojure/Java interoperation} is found in almost
every significant Clojure code base. Typed Clojure therefore builds in
an understanding of the Java type system and handles interoperation
appropriately. Notably, Typed Clojure avoids conflating Java's
\texttt{null} with all other types, leading to automatic type-enforced
absence of null-pointer exceptions.

A simple example of these features in combination is given in
figure~\ref{fig:ex1}. Here, the \texttt{pname} multimethod dispatches
on the \texttt{class} of the argument---when it is a \texttt{String},
the first method implementation is called, for a Java \texttt{File}, the
second. The method for \texttt{String} uses Java interoperation
to call a \texttt{File} constructor, returning a non-nil \texttt{File} instance---the 
method for \texttt{File} invokes
the \texttt{.getName} method with a non-nil target, returning a nilable
type. Typed Clojure uses type information to resolve JVM method or constructor overloads,
avoiding expensive runtime reflective calls.

Finally, when not working with existing Java classes and objects, the
most common Clojure data structure is the dictionary, a
high-performance immutable table which Clojure programmers repurpose
for all manner of data types. Simply treating them as uniformly-typed
key-value mappings would be entirely insufficient for existing
programs and programming styles. Instead, Typed Clojure provides a
flexible \textbf{heterogenous map} type, in which mandatory, optional, and
absent keys can be specified. 


While these features may seem disparate, they are unified in important
ways. First, they all leverage the type system mechanisms that Typed
Clojure inherits from Typed Racket---multimethods when using 
dispatch via predicates, Java interoperation for handling
\texttt{null} tests, and heterogenous maps using union types and
reasoning about subcomponents of data. Second, and more significantly,
they are the crucial features for handling Clojure code in
practice. Typed Clojure's use in real Clojure deployments would not be
possible without effective handling of these three Clojure features. 

%\subsection{Contributions}

Our main contributions are as follows:

\begin{enumerate}
  \item We motivate and describe  Typed Clojure, an optional
    type system for Clojure that understands existing Clojure idioms.
  \item We present a sound formal model for the three crucial type
    system features that Typed Clojure relies on: multi-methods, Java
    interoperability, and heterogenous maps.
  \item We evaluate the use of Typed Clojure features on existing
    Typed Clojure code, including both open source and in-house systems.
\end{enumerate}



%% \begin{figure}
%% \inputminted[firstline=5]{clojure}{code/demo/src/demo/parent2.clj}
%% \caption{A simple Typed Clojure program}
%% \label{fig:ex1}
%% \end{figure}

%% Figure~\ref{fig:ex1} presents a simple program demonstrating many
%% aspects of our system, from simple type annotations to explicit
%% handling of Java's \java{null} (written \clj{nil}) in interoperation, as well as an
%% extended form of occurrence typing and method resolution of
%% Java interoperability based on static type information.

%% The \clj{parent} function has the type 
%% $$
%% \clj{['{:file (U nil File)} -> (U nil Str)]}
%% $$
%% which means that it takes a hash table whose \clj{:file} key maps to either
%% \clj{nil} or a \clj{File}, and it produces either \clj{nil} or a
%% \clj{String}. The \clj{parent} function uses the \clj{:file} keyword
%% as an accessor to get the file, checks that it isn't \clj{nil}, and
%% then obtains the parent by making a Java method call.

\noindent
 The remainder of this paper begins with an example-driven
 presentation of the main type system features in
 \secref{sec:overview}. We then incrementally present a core calculus
 for Typed Clojure covering all of these features together in
 \secref{sec:formal} and prove type soundness
 (\secref{sec:metatheory}). We then discuss the full implementation of
 Typed Clojure, dubbed \coretyped{}, which extends the formal model in
 many ways, and empirical analysis of significant code bases written
 in \coretyped{} in \secref{sec:experience}. Finally, we discuss
 related work and conclude.

