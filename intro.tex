\section{Clojure with static typing}

% current situation 

The popularity of dynamically-typed languages languages in software
development, combined with a recognition that types often improve
programmer productivity, software reliability, and performance, has
led to the recent development of a wide variety of optional and
gradual type systems aimed at checking existing programs written in
existing languages.  These include Microsoft's TypeScript for
JavaScript, Facebook's Hack for PHP and Flow for JavaScript, and MyPy
for Python among the optional systems, and Typed Racket, Reticulated
Python, and GradualTalk among gradually-typed system.\footnote{We
  reserve the term ``gradual typing'' for systems such as Typed Racket which soundly
  interoperate between typed and untyped code; systems like Typed Clojure or TypeScript which do not
  enforce type invariants we describe as ``optionally typed''.}
%FIXME: add citations for all those systems.

One key lesson of these systems, indeed a lesson known to early
developers of optional type systems such as StrongTalk, is that type
systems for existing languages must be designed to work with the
features and idioms of the target language. Often this takes the form
of a core language, be it of functions or classes and objects,
together with extensions to handle distinctive language features.


We synthesize these lessons to present \emph{Typed Clojure}, an
optional type system for Clojure. Typed Clojure builds on the core
type checking approach of Typed Racket, an existing gradual type
system for Racket. However, Typed Clojure extends this basic framework
in multiple ways to accommodate the unique idioms and features of
Clojure, producing an expressive synthesis of ideas and demonstrating
a surprising coincidence between the multiple dispatch approach of
Clojure and the occurrence typing framework of Typed Racket. 

The essence of Typed Clojure, of course, is Clojure, a dynamically
typed language in the Lisp family built to run on the Java Virtual
Machine (JVM) which has recently gained popularity as an alternative
JVM language.  It offers the flexibility of a Lisp dialect, including
macros, emphasizes a functional style via a
standard library of immutable data structures, and provides
interoperability with existing Java code, allowing programmers to use
existing Java libraries without leaving Clojure.
%
Since its initial release in 2007, Clojure has been widely adopted for
``backend'' development in places where its support for paralleism,
functional programming, and Lisp-influenced abstraction is desired on
the JVM. As a result, it now has an extensive base of existing untyped
programs, many of whose developers can benefit from Typed Clojure. As
a result, Typed Clojure is now used in industry, experience we discuss
in this paper.

\begin{figure}
\inputminted[firstline=5,lastline=7]{clojure}{code/demo/src/demo/parent2.clj}
\caption{A simple Typed Clojure program}
\label{fig:ex1}
\end{figure}

Figure~\ref{fig:ex1} presents a simple program demonstrating many
aspects of our system, from simple type annotations to explicit
handling of Java's \java{null} (written \clj{nil}) in interoperation, as well as an
extended form of occurrence typing and Clojure's \emph{type hints},
which are central to Typed Clojure's approach to interoperability. 

The \clj{parent} function has the type 
$$
\clj{['{:file (U nil File)} -> (U nil Str)]}
$$
which means that it takes a hash table whose \clj{:file} key maps to either
\clj{nil} or a \clj{File}, and it produces either \clj{nil} or a
\clj{String}. The \clj{parent} function uses the \clj{:file} keyword
as an accessor to get the file, checks that it isn't \clj{nil}, and
then obtains the parent by making a Java method call.
%
The annotation \clj{^File f} is a type hint on \clj{f}, which instructs the Clojure
compiler (running prior to Typed Clojure typechecking) to statically
resolve the \clj{getParent} 
call to \clj{File}'s \clj{getParent} method with signature \java{String getParent();}, rather than using reflective method calls at runtime.

In the remainder of this paper, we describe how Typed Clojure's
central innovations, including Java interoperability, multimethods,
and heterogeneously-typed immutable maps, enable this example and many
others. We begin with an example-driven presentation of the main type
system features in Section~\ref{sec:overview}. We then incrementatlly
present a core calculus for Typed Clojure covering all of these
features together in Section~\ref{sec:formal} and prove type
soundness(section \ref{sec:sound}). We then discuss the full
implementation of Typed Clojure, dubbed \coretyped{}, which extends
the formal model in many ways, and the experience gained from its use
in Section~\ref{sec:exp}. Finally, we discuss related work and
conclude.

%$$
%\abs{\x{}}{\Union{\Nil}{\File}}
%{\letexp {\hinted{\File{}}{f}} {f}
%  {\ifexp {f} 
%    {\letexp {s} {\methodstaticexp {\File{}} {\String{}} {\String{}} {getParent} {f}}
%      {\doexp {\ifexp {s}
%                {\nil{}}
%                {\errorval{input}}}
%              {\newstaticexp {\String{}} {\File{}} {\File{}} {s}}}}
%    {\nil{}}
%}}
%              $$

%(some-> f (.getParent) (File.) (.getParent))

%\begin{lstlisting}
%(ann parent [(U nil File) -> (U nil String)])
%(defn parent [^File f]
%  (when f
%    (.getParent f)))
%\end{lstlisting}

%% \begin{minted}[]{clojure}
%% (defalias Expr
%%   (U '{:op :if :test Expr :then Expr :else Expr}
%%      '{:op :const :val Any} ...))
%% (ann tree-str [Expr -> String])
%% (defmulti tree-str (fn [e :- Expr] (get :op e)))
%% (defmethod tree-str :if [{:keys [test then else]}] 
%%   (str (tree-str test) (tree-str then) (tree-str else)))
%% (defmethod tree-str :const [{:keys [val]}] 
%%   (str val))
%% \end{minted}

%% \subsection{Contributions}

%% %The main idea is....... SPJ
%% In this paper we present a practical type system for Clojure.

%% \begin{itemize}

%%   \item We formalise Typed Clojure and prove that typed code
%%     \begin{itemize}
%%       \item disallows null-pointer exceptions, (Section ?)
%%       \item statically resolves Java interoperability (Section ?)
%%     \end{itemize}
%%   \item We reveal the surprising synthesis between Clojure multimethods
%%         and occurrence typing.
%%   \item We 
%% \end{itemize}

% what are the goals of Typed Clojure?
% where do they differ from Typed Racket? why?

% Things todo
% - DONE small calculus based on previous TR formalisation
%   that demos the ``flow'' environment & not/intersection type
% - discussion and examples for flow filters
% - discussion on the not/difference type, real code where it helps
% - higher-rank polymorphism, show what it enables (eg. monads)
%   - also show more complicated example, making an extensible
%     type for clojure.core/conj, and why it's not straightforward
% - discussion on limitations of local type inference
% - demonstration of how we check multimethods
% - dealing with array covariance
% - note on how we avoid null-pointer exceptions
% - discussion on why Typed Clojure only uses the ``static'' part
%   of Typed Racket
% - the equality filter problem (and draft solution?), a proposition
%   that knows about binding aliasing. Sounds straightforward?


