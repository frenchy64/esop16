\section{Experience}
\label{sec:experience}

Typed Clojure is implemented as a Clojure library named \coretyped{}.
In contrast to Racket, Clojure does not provide extension
points to the macroexpander. To satisfy our goals of providing
Typed Clojure as a library that works with the latest version of the Clojure
compiler, \coretyped{} is implemented as an external static analysis pass
that must be explicitly invoked by the programmer.
Therefore, \coretyped{} is in a sense a linter.

This means that type checking is truly optional. 
On the positive side, \coretyped{} is flexible to the needs of a dynamically
typed programmer, encouraging experimentation with programs that may not
type check.
On the negative side, programmers must remember to type check their namespaces,
though since type checking is a function call away, it is easily integrated as editor
shortcuts or continuous integration.
Also, programs cannot depend on the static semantics of Typed Clojure, meaning that
type-based optimisation is impossible. If this were not the case, we could dispose of type-hints
altogether, and simply use static types to resolve reflection.

%\subsection{Let-aliasing}
%
%\begin{mathpar}
%  \footnotesize
%\infer [T-LocalAlias]
%{ \Theta[\x{}] = \object{}
%  \\
%  \inpropenv {\propenv{}} {\isprop {\t{}} {\object{}}}
%  \\\\
%  \s{} = {\falsy} }
%{ \judgement {\Theta; \propenv{}} 
%             {\hastype {\x{}} {\t{}}}
%             {\filterset {{\notprop {\s{}} {\object{}}}} {{\isprop {\s{}} {\object{}}}}}
%             {\object{}}
%                   }
%
%\infer [T-LetAlias]
%{ \judgement {\Theta; \propenv{}} {\hastype {\e{1}} {\s{}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
%             {\object{1}}
%  \\\\
%  \object{1} \notequal \emptyobject{}
%  \\\\
%  \judgement
%       {\Theta[\x{} \mapsto \object{1}];
%         \propenv{}}
%             {\hastype {\e{}} {\t{}}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
%             {\object{}} 
%             }
%{ \judgement {\Theta; \propenv{}} {\hastype {\letexp {\x{}} {\e{1}} {\e{}}} {\t{}}}
%             {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
%             {\object{}} 
%             }
%\end{mathpar}

\subsection{Further Extensions}

\smallsection{Datatypes, Records and Protocols}
Clojure features datatypes and protocols. Datatypes are Java classes
declared final with public final fields. They can implement Java interfaces
or protocols, which are similar to interfaces but already-defined classes
and \nil{} may extend protocols.
%
Typed Clojure can reason about most of these features,
including the ability to define polymorphic datatypes and protocols and
utilising the Java type system to help check implemented interface methods.

%\smallsection{Intersection Types}
%Typed Clojure includes simple intersection types which do no sophisticated
%reasoning with the dual subtyping rules to unions.
%
%In some cases this makes types more expressive. Say we know \clj{x} has some
%universally quantified type \clj{a} and we learn \clj{x} is a \clj{Number}.
%Without intersection types, we must choose which piece of information to forget.
%In Typed Clojure, \clj{x} is simply of type \clj{(I x Number)}.
%
\smallsection{Mutation and Polymorphism}
Clojure supports mutable references with software-transactional-memory
which Typed Clojure defines \emph{bivariantly}---with write and read type parameters
as in the atomic reference \clj{(Atom2 Int Int)} which can write and read \clj{Int}.
Typed Clojure also supports parametric polymorphism, including
Typed Racket's variable-arity polymorphism~\cite{variable-arity-cite-todo}, 
which enables us to assign a type to functions like \clj{swap!} (figure~\ref{main:fig:swap!}),
which takes a mutable \emph{atom},
a function and extra arguments, and swaps into the atom the result of
applying the function to the atom's current value and the extra arguments.

\begin{figure}
\begin{minted}{clojure}
(ann clojure.core/swap! 
  (All [w r b ...] 
    [(Atom2 w r) [r b ... b -> w] b ... b -> w]))

\end{minted}
\inputminted[firstline=5,lastline=5]{clojure}{code/demo/src/demo/atom.clj}
\caption{Type annotation and example call of \clj{swap!}}
\label{main:fig:swap!}
\end{figure}

\subsection{Limitations}
\smallsection{Java Arrays}
Java arrays are known to be statically unsound. \citet{Bra98} 
summarises the approach taken to regain runtime soundness, which involves
checking array writes at runtime.

Typed Clojure implements an experimental partial solution, making arrays \emph{bivariant},
separating the write and read types into contravariant and covariant parameters.
If the array originates from typed code, then we may track the write and read
parameters statically. Currently arrays from foreign sources
have their write parameter set to to \Bot{}, protecting typed code from writing
something of incorrect type. However there are currently no casting mechanisms to 
convince Typed Clojure the foreign array is writeable.

\smallsection{Array-backed sequences}
Typed Clojure assumes sequences are immutable. This is almost always true, however
for performance reasons,
sequences created from Java arrays (and Iterables) reflect future writes to the array 
in the `immutable' sequence. While disturbing and a clear unsoundness in Typed Clojure,
this has not yet been an issue in practice and is strongly discouraged as undefined behavior:
``Robust programs should not mutate arrays or Iterables that have seqs on them.''~\cite{CljSeqDoc}.

\smallsection{Gradual typing}
Gradual typing ensures sound interoperability between typed and untyped code by enforcing
invariants of the type system via run-time contracts.
Currently, interactions between typed and untyped Clojure code are unchecked
which can violate the expectations of Typed Clojure. We hope to add support
for gradually typing in the future.

\subsection{Case Study}
\label{sec:casestudy}

CircleCI\footnote{\url{https://circleci.com/}} provides continuous integration services built with a mixture of open-
and closed-source.
Typed Clojure has been used at CircleCI in production Clojure systems for at least two years.

CircleCI provided the first author access to the main closed-source backend system written in Clojure
and Typed Clojure.
We conducted a study of the effectiveness of Typed Clojure in practice.
There is no clear metric for quantifying typed Clojure code, since untyped code
can be freely mixed and some seemingly typed namespaces are not checked
regularly. We manually type checked all namespaces that depend on \clj{clojure.core.typed}
and considered those with type errors as untyped.
We then searched the remaining typed code for unsafe Typed Clojure operations like
var annotations with \clj{:no-check} and the \clj{tc-ignore} macro,
which instruct Typed Clojure to ignore the specified code,
and also considered those untyped.
Furthermore, we manually collected and inspected all top-level annotations and
classified them.

We determined that
CircleCI has a Clojure code base of approximately 50,000 lines, including around 10,000 
lines of typed code.
Out of 588 top-level var annotations, 270 (46\%) were checked annotations of
functions defined in typed code,
129 (22\%) annotations assigned types to external libraries 
and the remaining 189 (32\%) annotated `unchecked' user code.
HMaps were a valuable feature, with 38 (59\%) out of 64 total type aliases
featuring them; see example~\ref{example:circleci} for an instance.

Based on this and other interactions with Typed Clojure users,
it is clear the main barrier to entry to Typed Clojure for large systems is the requirement
to annotate functions outside the borders of typed code.
We conjecture that this can be addressed by making annotations available for popular libraries.




%OLD

%\subsection{Using negative filters}
%
%Occurrence typing plays an important role in Typed Racket and Typed Clojure.
%By maintaining a \emph{proposition environment} of propositions relating types to
%bindings, we can update bindings with more accurate types as programs progress.
%It follows that there is some correspondence between propositions and types,
%characterised by the \emph{update} function, which takes a type and a proposition
%and returns a type which updates the input type using the proposition.
%
%There is a straightforward relationship between ``positive'' propositions and types.
%For example 
%{\tt (update Number (is Integer 0))}
%updates Number by Integer, which is Integer, because Integer <: Number.
%
%The relationship between ``negative'' propositions and types is not always obvious.
%A common proposition in Typed Clojure is (! (U nil false) a): the proposition that
%local binding ``a'' is \emph{not} of type (U nil false).
%This problem is most visible in expressions like {\tt (filter identity coll)}, where
%``identity'' has a ``then'' proposition that has negative information: (! (U nil false) 0),
%which reads, the 0th argument of identity does not contain (U nil false).
%
%\subsubsection{Arrays}
%\label{sec:arrays}
%
%Supporting statically sound interactions with Java arrays is a goal
%of Typed Clojure. This is complicated by Java's decision to make
%arrays covariant in their argument, a well documented source of static
%unsoundness. Bracha~\cite{Bra98} summarises Java's approach to maintaining
%soundness at runtime, which involves all array writes being checked by
%runtime assertions.
%
%This approach fits Java's type system, but we can do better in a more powerful
%type system like Typed Clojure. Our goal is to catch all type-incorrect array
%writes at compile time so the type system can do more to help Clojure programmers
%use arrays, especially those being passed from foreign Java code.
%
%Our basic approach is to make our array types \emph{bivariant}. Array types
%look like {\ArrayTwo {\t{w}} {\t{r}}} and
%are reminiscent of functions or pipes: having a contravariant parameter for input (writing)
%and a covariant parameter for output (reading).
%This type can write type {\t{w}} and read type {\t{r}}.
%
%Most commonly, an array type is invariant in its parameter; it can
%write and read input of the same type.
%We can get the same effect by setting our input and output
%parameters to the same type. For example, {\ArrayTwo {\Number} {\Number}}
%(or equivalently, {\Array {\Number}})
%in Typed Clojure is similar to invariant array types of \Number in languages like Scala.
%
%The biggest gain in using a separate input parameter is the ability
%to specify \emph{read-only} arrays. Crucially, our type system features an
%explicit bottom type \lstinline|Nothing|, enabling a read-only \lstinline|Number| array
%to be of type \lstinline|(Array2 Nothing Number)|.
%
%To realise why defining read-only arrays are useful, we need to examine
%what makes array covariance unsound in Java.
%\begin{verbatim}
%FIXME
%Array covariance about the type of an array so the consumer
%of an array cannot tell the actual type of the array when examining a type
%signature.
%\end{verbatim}
%
%\begin{lstlisting}
%...
%public static Number[] getNumberArray() {
%  Number[] n = new Integer[10];
%  return n;
%}
%...
%\end{lstlisting}
%
%To the casual consumer \emph{getNumberArray} returns an array that can both
%read and write \lstinline|Number|s. However it is clear from the implementation
%that attempting to write say a \lstinline|Double| to this array will result
%in a runtime error.
%
%\begin{verbatim}
%...
%Number[] myArray = getNumberArray();
%myArray[0] = 1.1;
%/* Exception in thread "main" 
%   java.lang.ArrayStoreException: 
%   java.lang.Double */
%...
%\end{verbatim}
%
%Notice that this is a runtime error, and Java's type system has not helped
%statically prevent it.
%This could cause a similar issue for other statically-typed languages offering
%interoperability with Java. 
%
%To prevent these sorts of runtime exceptions in Typed Clojure, we declare
%all arrays from unknown sources to be \emph{read-only}. Put differently,
%the only way to define a writeable array is to create it in type-checked Clojure
%code.
%
%\begin{lstlisting}
%(let [n (CovariantArray/getNumberArray)]
%  (aset n 0 1.1))
%
%; Polymorphic static method clojure.lang.RT/aset could not be 
%; applied to arguments:
%; Domains: 
%;         (Array2 i o) clojure.core.typed/AnyInteger i
%; 
%; Arguments:
%;         (Array2 Nothing java.lang.Number) int (Value 1.1)
%; 
%; with expected type:
%;         Any
%\end{lstlisting}
%
%The type inferred for the local \lstinline|n| is \lstinline|(Array2 Nothing Number)|
%which tells the type system: it is never safe to write to this array, but
%it is safe to assume \lstinline|Number|s can be read from this array.
%
%To emphasise, Typed Clojure throws a static type error. Errors like this help Clojure programmers
%use foreign Java libraries more correctly.
%
%\begin{verbatim}
%Note that Java libraries are often large 
%and complex and programmers will probably
%enjoy the extra help from the type system.
%\end{verbatim}
