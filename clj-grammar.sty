% see mmm.sty for implementation of newmeta etc

% macros for Clojure grammars
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{xcolor}


% newmeta variables are automatically subscripted
% \x0, \x1, \x{}

%% metavariables

% constants
\newmeta\const{c}

% types
\newmeta\s{\sigma}              % these are automatically wrapped in \ma
\newmeta\sp{\sigma{'}}
\newmeta\t{\tau}
\newmeta\tp{\tau{'}}
\newmeta\tpp{\tau{''}}
\newmeta\T{T}

% expressions
\newmeta\M{M}
\newmeta\N{N}
\newmeta\P{P}
\newmeta\e{e}
\newmeta\ep{e'}
\newmeta\expd{d}
\newmeta\ReflectiveExp{R}
\newmeta\NonReflectiveExp{E}
\newmeta\MultimethodExp{M}
\newmeta\HintedExp{H}
\newmeta\HashMapExp{G}

% we write a macro for every bit of abstract syntax.  That way they
% will all look the same!

% types
\newbfop\int{int}
\newbfop\Boolean{Boolean}
\newbfop\Booleanhint{Boolean}
\newbfop\IFn{IFn}
\newbfop\MultiFn{MultiFn}
\newbfop\PMulti{Multi}
\newbfop\IPersistentMapLiteral{IPersistentMap}
\newbfop\MapLiteral{Map}
\newbfop\Uliteral{\ma{\bigcup}}
\newbfop\Iliteral{\ma{\bigcap}}
\newbfop\Not{Not}
\newbfop\Allliteral{All}
\newbfop\TFnliteral{TFn}
\newbfop\Valueliteral{Val}
\newbfop\ArrayTwoLiteral{Array2}
\newbfop\ArrayLiteral{Array}
\newbfop\ArrayPLiteral{ArrayP}
\newbfop\Throwable{Throwable}
\newbfop\Class{Class}
\newbfop\Object{Object}
\newcommand\MultiFntype[2]{(\PMulti #1\ #2)}
\newcommand\proctype[2]{(#1 \to #2)}
\newcommand\Unionsplice[1]{(\ma{\Uliteral\ #1})}
\newcommand\Union[2]{(\ma{\Uliteral\ #1\ #2})}
\newcommand\In[1]{(\ma{\Iliteral\ #1})}
\newcommand\ArrayTwo[2]{(\ma{\ArrayTwoLiteral\ #1\ #2})}
\newcommand\Array[1]{(\ArrayLiteral #1)}
\newcommand\ArrayP[1]{(\ArrayPLiteral #1)}
% \proctype is a little overkill.
%% Reynolds' package can also abstract things like (\s1 \to \s2 \to \s3).
\newcommand\Arrow[4]{\ma{#1 \xrightarrow[#4]{#3} #2}}
% TODO figure out how to make #1 : #2 closer to the :
\newcommand\ArrowOne[5]{\ma{{\hastypesmall {#1} {#2}} \xrightarrow[#5]{#4} #3}}
\newcommand\ArrowOverright[5]{\ma{{\overrightarrow{\hastypesmall {#1} {#2}}} \xrightarrow[#5]{#4} #3}}
% minus filters and object, implicitly tt | tt; empty
\newcommand\ArrowTwo[3]{\ma{{\hastypesmall {#1} {#2}} \xrightarrow\ {#3}}}

\newcommand\All[2]{(\ma{\Allliteral\ [#1]\ #2})}
\newcommand\TFn[2]{(\ma{\TFnliteral\ [#1]\ #2})}
\newcommand\Value[1]{(\ma{\Valueliteral #1})}
\newmeta\singletonmeta{s}
\newbfop\Top{\ma{\top}}
\newbfop\Bottom{\ma{\bot}}
\newbfop\Bot{\ma{\bot}}
\newbfop\Keyword{Keyword}
\newbfop\Keywordhint{Keyword}
\newbfop\Symbol{Symbol}
\newbfop\Number{Number}
\newbfop\Nil{nil}
\newbfop\True{true}
\newbfop\False{false}
\newbfop\falsy{(\ma{\cup\ \Nil\ \False})}
\newbfop\falsydiff{\ma{\trdiff{\falsy}}}
\newcommand\IPersistentMap[2]{(\ma{\IPersistentMapLiteral\ #1\ #2})}
\newcommand\Map[2]{(\ma{\MapLiteral #1\ #2})}
\newcommand\HMapInstance[0]{\ma{\IPersistentMapLiteral}}
\newbfop\HMapliteral{HMap}
\newmeta\completenessmeta{\mathcal{A}}
\newmeta\complete{\mathcal{C}}
\newmeta\partial{\mathcal{P}}
\newcommand\HMapgeneric[2]{(\ma{\HMapliteral^{\completenessmeta{}} #1\ #2})}
\newcommand\HMapc[1]{(\ma{\HMapliteral^{\complete{}} #1})}
\newcommand\HMapp[2]{(\ma{\HMapliteral^{\partial{}} #1\ #2})}
\newcommand\mandatoryset[1]{\ma{\{#1\}}}
\newcommand\mandatorysetoverright[2]{\ma{\{\overrightarrow{(#1,\ #2)}\}}}
\newcommand\notinmandatory[3]{\ma{(#1\ #2)} \not\in {#3}}
\newcommand\inmandatory[3]{\ma{(#1\ #2)} \in {#3}}
\newcommand\extendmandatoryset[3]{(#1, (#2\ #3))}
\newmeta\mandatory{p}
\newmeta\absent{a}
\newcommand\absentoverright[1]{\ma{\{{\overrightarrow{#1}}\}}}
\newcommand\inabsent[2]{\ma{#1 \in #2}}
\newcommand\notinabsent[2]{\ma{#1 \not\in #2}}
\newcommand\extendabsentset[2]{(#1, #2)}
\newbfop\Satisfiesliteral{Satisfies}
\newcommand\Satisfies[1]{(\ma{\Satisfiesliteral\ #1})}
\newbfop\Instanceliteral{InstanceOf}
\newcommand\Instance[1]{(\ma{\Instanceliteral\ #1})}
\newcommand\HVec[1]{[{#1}]}
\newcommand\makekw[1]{\ma{\metafunctionfont{\mathbin{:}#1}}}

% terms
\newmeta\x{x}                   % not sure if \x is reserved...
\newmeta\xp{x{'}}                   % not sure if \x is reserved...
\newmeta\y{y}
\newmeta\z{z}
\newmeta\v{v}
\newmeta\vp{v'}
\newmeta\class{C}
\newmeta\classp{C{'}}
\newmeta\protocol{P}
\newmeta\k{k}
\newmeta\num{n}
\newmeta\b{b}
\newcommand\operatorfont[1]{\ma{{\mathsf{#1}}}}
\newcommand\literalfont[1]{\ma{{\mathsf{#1}}}}
\newcommand\nil[0]{{\literalfont{nil}}}
\newcommand\true[0]{{\literalfont{true}}}
\newcommand\false[0]{{\literalfont{false}}}
\newcommand\assocliteral[0]{{\operatorfont{assoc}}}
\newcommand\assocexp[3]{(\assocliteral{}\ #1\ #2\ #3)}
\newmeta\dissoc{dissoc}
\newmeta\getliteral{{\operatorfont{get}}}
\newcommand\getexp[2]{(\getliteral{}\ #1\ #2)}
\newcommand\ifliteral[0]{{\operatorfont{if}}}
\newcommand\doliteral[0]{{\operatorfont{do}}}
\newcommand\letliteral[0]{{\operatorfont{let}}}
\newcommand\throwliteral[0]{{\operatorfont{throw}}}
\newcommand\newliteral[0]{{\operatorfont{new}}}
\newcommand\defmultiliteral[0]{{\operatorfont{defmulti}}}
\newcommand\defmethodliteral[0]{{\operatorfont{defmethod}}}
\newcommand\abs[3]{\ma{\l #1^{#2} . #3}}
\newcommand\absoverright[3]{\ma{\l \overrightarrow{#1^{#2}} . #3}}
\newcommand\curlymap[1]{\ma{\{#1\}}}
\newcommand\emptymap[1]{\ma{\{\}}}
\newcommand\roundpair[2]{\ma{(#1, #2)}}
\newcommand\curlymapvaloverright[2]{\ma{\{{\overrightarrow{\roundpair{#1}{#2}}}\}}}
\newcommand\extendmap[3]{\ma{#1[#2 \mapsto #3]}}
\newcommand\getmap[2]{\ma{#1[#2]}}
\newcommand\keyinmap[2]{\ma{{#1} \in dom({#2})}}
\newcommand\keynotinmap[2]{\ma{{#1} \not\in dom({#2})}}
\newcommand\comb[2]{\ma{(#1\ #2)}}
\newcommand\ifexp[3]{(\ma{\ifliteral{}\ #1\ #2\ #3})}
\newcommand\doexp[2]{(\ma{\doliteral{}\ #1\ #2})}
\newcommand\letexp[3]{(\ma{\letliteral{}\ [\ma{#1\ #2}]\ #3})}
\newcommand\appexp[2]{(\ma{#1\ #2})}
\newcommand\throwexp[1]{(\ma{\throwliteral{}\ #1})}
\newcommand\newexp[2]{(\ma{\newliteral{}\ #1\ #2})}
% deleted 2nd argument which is just the same as #3
\newcommand\newstaticexp[4]{(\ma{{\newliteral}_{[#1]}\ #3\ #4})}
\newcommand\dotliteral[0]{{\operatorfont{.}}}
\newcommand\fieldexp[2]{(\ma{\dotliteral\ #2\ #1})}
\newcommand\fieldstaticexp[4]{(\ma{\dotliteral\ #4\ {#3}^{#1}_{#2}})}
\newcommand\methodexp[3]{(\ma{\dotliteral\ #2\ (#1\ #3)})}
\newcommand\methodstaticexp[6]{(\ma{\dotliteral\ #5\ ({#4}^{#1}_{[[#2], #3]}\ #6)})}
\newcommand\createmultiexp[2]{(\ma{\defmultiliteral{}\ #1\ #2})}
\newcommand\defmultiexp[2]{(\ma{\defmultiliteral{}\ #1\ #2})}
\newcommand\defmethodexp[4]{(\ma{\defmethodliteral{}\ #1\ #2\ [#3]\ #4})}
\newcommand\extendmultiexp[3]{(\ma{\defmethodliteral{}\ #1\ #2\ #3})}
\newmeta\defliteral{{\bf def}}
\newcommand\defexp[2]{(\ma{\defliteral{}\ #1\ #2})}
\newcommand\wrong[0]{\ma{wrong}}
\newcommand\errorval[1]{\ma{error_{#1}}}
\newcommand\errorvalv[0]{\errorval{\v{}}}
\newcommand\reflerror[0]{\errorval{refl}}
\newcommand\mmerror[0]{\errorval{mm}}
\newcommand\rtvector[1]{[{#1}]}

% Java primitives
\newmeta\pint{int}
\newbfop\Integer{java.lang.Integer}
\newmeta\plong{long}
\newbfop\Long{java.lang.Long}
\newmeta\pdouble{double}
\newbfop\Double{java.lang.Double}
\newmeta\pchar{char}
\newbfop\Character{java.lang.Character}
\newmeta\pvoid{void}
\newbfop\Void{Void}
\newbfop\File{File}
\newbfop\String{String}
\newmeta\mth{mth}
\newmeta\fld{fld}

% Clojure values
\newmeta\symbol{symbol}
\newmeta\nat{nat}

% constant calls
\newbfop\ccclass{class}
\newcommand\instanceliteral[0]{\operatorfont{instance?}}
\newcommand\isaliteral[0]{{\operatorfont{isa?}}}
\newcommand\instanceapp[2]{{(\instanceliteral\ #1\ #2)}}
\newcommand\isaapp[2]{(\isaliteral\ #1\ #2)}

% constant typing
\newcommand\constanttypetwo[2]{\ma{{\delta}_{#1}(#2)}}
\newcommand\constanttype[1]{\constanttypetwo{\t{}}{#1}}
\newcommand\constantopsem[2]{\ma{{\delta}(#1, #2)}}
\newcommand\classconst[0]{\emph{class}}
\newcommand\throwconst[0]{\emph{throw}}

% differences from TR
\newcommand\trdiff[1]{\mathbin{\textcolor{blue}{#1}}}

% update function
\newcommand\metafunctionfont[1]{{\mathsf{#1}}}
\newcommand\updateliteral[0]{\ma{\metafunctionfont{update}}}
\newcommand\update[3]{\updateliteral(#1 , #2, #3)}
\newcommand\restrictliteral[0]{\ma{\metafunctionfont{restrict}}}
\newcommand\restrict[2]{\restrictliteral(#1, #2)}
\newcommand\removeliteral[0]{\ma{\metafunctionfont{remove}}}
\newcommand\remove[2]{\removeliteral(#1, #2)}
\newcommand\emptypath[0]{\ma{\epsilon}}

% class table
\newcommand\ct[0]{\mathcal{CT}}
\newmeta\ctentrymeta{ce}
\newmeta\ctmethod{m}
\newmeta\ctfield{f}
\newmeta\ctctor{c}
\newcommand\ctmethodsliteral[0]{\metafunctionfont{methods}}
\newcommand\ctfieldsliteral[0]{\metafunctionfont{fields}}
\newcommand\ctconstructorsliteral[0]{\metafunctionfont{constructors}}
\newcommand\ctmthentry[3]{\ma{[#1, [#2], #3]}}
\newcommand\ctfldentry[2]{\ma{[#1, #2]}}
\newcommand\ctctorentry[1]{\ma{[#1]}}
\newcommand\set[1]{\ma{\{#1\}}}
\newcommand\ctentry[0]{\{ \ctmethodsliteral \mapsto 
  \set{\overrightarrow{\ctmthentry{\mth{}}{\overrightarrow{\classhint{}}}{\classhint{}}}}, \ 
  \ctfieldsliteral \mapsto \{\overrightarrow{\ctfldentry{\fld{}}{\classhint{}}} \}, \ 
  \ctconstructorsliteral \mapsto \{\overrightarrow{\ctctorentry{\overrightarrow{\classhint{}}}} \}
                          \}}
\newcommand\ctlookup[2]{\ma{{#1}[#2]}}
\newcommand\ctlookuptwo[3]{\ma{\ctlookup{({\ctlookup{#1}{#2}})}{#3}}}
\newcommand\ctlookupmethods[2]{\ma{\ctlookuptwo{#1}{#2}{\ctmethodsliteral}}}
\newcommand\ctlookupfields[2]{\ma{\ctlookuptwo{#1}{#2}{\ctfieldsliteral}}}
\newcommand\ctlookupctors[2]{\ma{\ctlookuptwo{#1}{#2}{\ctconstructorsliteral}}}

% typing judgements
\newcommand\hastype[2]{\ma{#1 \mathbin{:} #2}}
\newcommand\hastypesmall[2]{\ma{#1 {:} #2}}
\newcommand\issubtype[2]{\ma{#1 \mathbin{<:} #2}}
\newcommand\issubtypein[3]{\ma{{\inpropenv{#1} {#2 \mathbin{<:} #3}}}}
\newcommand\issubobjin[3]{\ma{{\inpropenv{#1} {#2 \mathbin{<:} #3}}}}
\newcommand\notsubtypein[3]{\ma{{\inpropenv{#1} {#2 \mathbin{\not<:} #3}}}}
% 4 place relation (TR formalism)
\newcommand\judgement[4]{\ma{#1 \vdash #2\ ;\ #3\ ;\ #4}}
% 7 place relation (TC formalism)
\newcommand\judgementsev[7]{\ma{#3 \vdash #4\ ;\ #5\ ;\ #6}}
%\newcommand\judgementsev[7]{\ma{#3 \vdash_{\scriptscriptstyle{\trdiff{\ct{}}}} #4\ ;\ #5\ ;\ #6}}
% 7 place relation with color
\newcommand\judgementsevcol[7]{\judgementsev {\trdiff{#1}} {\trdiff{#2}} {#3} {#4} {#5} {#6} {\trdiff #7}}
% expands to 7 place but with 4 args (the TR formalism)
\newcommand\judgementfillcol[4]{\judgementsevcol {\mmenv} {\taenv} {#1} {#2} {#3} {#4} {\mmenv}}
% expects everything except mmenv
\newcommand\judgementfillmmcol[5]{\judgementsevcol {\mmenv} {#1} {#2} {#3} {#4} {#5} {\mmenv}}
% lookuping props in the env
% 2 place relation (same as tt | tt; empty)
\newcommand\judgementtwo[2]{\ma{#1 \vdash #2}}
\newcommand\inpropenv[2]{\ma{#1 \vdash #2}}

% operational semantics
\newmeta\openv{\rho}
\newmeta\openvp{\rho'}
\newcommand\inopenvnoeq[2]{\ma{#1 (#2)}}
\newcommand\inopenv[3]{\ma{#1 (#2) = #3}}
\newcommand\notinopenv[2]{\ma{#2 \not\in dom(#1)}}
\newcommand\extendopenv[3]{\ma{#1[#2 \mapsto #3]}}
\newcommand\opsem[3]{\ma{#1 \vdash #2 \Downarrow #3}}
\newcommand\notopsem[3]{\ma{#1 \not\vdash #2 \Downarrow #3}}
\newcommand\closure[2]{\ma{[#1, #2]_{clos}}}
% multimethod semantics
\newcommand\multi[2]{\ma{[#1, #2]_{multi}}}
\newcommand\emptydisptable[0]{\{\}}
\newmeta\disptable{m}
\newmeta\disptablep{m'}
\newcommand\extenddisptable[3]{\ma{#1[#2 \mapsto #3]}}
\newcommand\getmethodliteral[0]{\ma{\metafunctionfont{GetMethod}}}
\newcommand\getmethod[3]{\getmethodliteral(#1, #2) = #3}
\newcommand\getmethodalign[3]{\getmethodliteral(#1, #2) &=& #3}

% java reflection rewrite 
\newcommand\rewrite[3]{\ma{#1\ \vdash^{\ct{}}_{\metafunctionfont{r}} #2 \Rightarrow #3}}

% tools.analyzer judgements
\newcommand\ta[0]{\mathcal{TA}}
\newcommand\intaenv[3]{\ma{#1 (#2) = #3}}
\newcommand\tajudgement[2]{\ma{#1 \vdash_{\metafunctionfont{h}} #2}}

% type hints
\newmeta\tatypeunknown{\gamma^{?}}
\newmeta\tatype{\gamma}
\newmeta\tatypep{\gamma'}
\newmeta\classhint{C}
\newmeta\primitivehint{p}
\newmeta\unknownhint{\mathbbm{?}}
\newcommand\hinted[2]{\ma{\ \widehat{}\ #1\ #2}}

% convert tools.analyzer types to core.typed types
\newcommand\tatotc[2]{\ma{[[#1]]\ =\ #2}}

% environment
\newcommand\propenv{\ma{\Gamma}}
\newcommand\propenvp{\ma{\Gamma'}}
\newcommand\propenvc{\ma{\Gamma_c}}
\newcommand\mmenv{\Delta}
\newcommand\mmenvp{\mmenv'}
\newcommand\mmenvpp{\mmenvp'}
\newcommand\taenv{\Sigma}
\newcommand\taenvp{\taenv'}

% multimethod envs
\newcommand\adddispatchfn[2]{\ma{add\_dispatch\_fn(#1,\ #2)}}
\newcommand\getdispatchfn[2]{\ma{get\_dispatch\_fn(#1)_{#2}}}
\newcommand\inmmenv[3]{\ma{#1 (#2) = #3}}

\newcommand\metafnfont[1]{{\metafunctionfont{#1}}}

% isa? special functions
\newcommand\isacompareliteral[0]{\ma{\metafnfont{IsAProps}}}
\newcommand\isacomparetwo[2]{\ma{\isacompareliteral(#1, #2)}}
\newcommand\isacomparethree[3]{\ma{\isacompareliteral(#2, #3)}} % delete 1st argument, unusued outside of vectors
\newcommand\isacompare[4]{\ma{\isacomparethree{#1}{#2}{#3} = {#4}}}
\newcommand\isacomparealign[4]{\ma{\isacomparethree{#1}{#2}{#3} &=& {#4}}}
\newcommand\isaopsemliteral[0]{\ma{\metafnfont{IsA}}}
\newcommand\isaopsem[2]{\ma{\isaopsemliteral(#1, #2)}}

% new special functions
% Type -> [Type]
\newcommand\ctorparamsliteral[0]{\metafnfont{Constructor}}
\newcommand\ctorparamsnoeq[3]{\ma{\ctorparamsliteral(#1, #2, [#3])}}
\newcommand\ctorparams[4]{\ma{\ctorparamsnoeq{#1}{#2}{#3} = [#4]}}
\newcommand\ctorparamsalign[4]{\ma{\ctorparamsnoeq{#1}{#2}{#3} &=& [#4]}}

% field special functions
% Type Field -> Type
\newcommand\fieldtypeliteral[0]{\ma{\metafnfont{Field}}}
\newcommand\fieldtypenoeq[3]{\ma{\fieldtypeliteral(#1, #2, #3)}}
\newcommand\fieldtype[5]{\ma{\fieldtypenoeq{#1}{#2}{#3} = [#4, #5]}}
\newcommand\fieldtypealign[5]{\ma{\fieldtypenoeq{#1}{#2}{#3} &=& [#4, #5]}}

% method special functions
% Type [Type] Method -> [Type]
\newcommand\methodtypeliteral[0]{\metafnfont{Method}}
\newcommand\methodtypenoeq[4]{\ma{\methodtypeliteral(#1, #2, #3, [#4])}}
\newcommand\methodtype[7]{\ma{\methodtypenoeq{#1}{#2}{#3}{#4} = [#5, [#6], #7]}}
\newcommand\methodtypealign[7]{\ma{\methodtypenoeq{#1}{#2}{#3}{#4} &=& [#5, [#6], #7]}}

% java subtyping
\newcommand\assignable[2]{\ma{assignable(#1, #2)}}

% evaluation contexts
\newmeta\E{E}


% propositions
\newmeta\prop{\psi}
\newmeta\propp{\psi'}
\newmeta\proppp{\psi''}
\newmeta\propisnotmeta{\nu}
\newcommand\isprop[2]{\ma{{#1}_{#2}}}
\newcommand\impprop[2]{\ma{#1 \supset #2}}
\newcommand\nottype[1]{\ma{\overline{#1}}}
\newcommand\notprop[2]{\ma{{\nottype{#1}}_{#2}}}
\newcommand\andprop[2]{\ma{#1 \wedge #2}}
\newcommand\orprop[2]{\ma{#1 \vee #2}}
\newmeta\topprop{\mathbbm{tt}}
\newmeta\botprop{\mathbbm{ff}}
\newcommand\filterset[2]{\ma{#1 | #2}}
\newcommand\filtersetparen[2]{\ma{(\filterset{#1}{#2})}}
\newcommand\thenprop[1]{\ma{{#1}_+}}
\newcommand\elseprop[1]{\ma{{#1}_-}}

% polarities
\newmeta\polaritymeta{pol}
\newcommand\withpolarity[2]{\ma{{#1}^{#2}}}
\newcommand\pluspolarityliteral[0]{\metafunctionfont{pos}}
\newcommand\minuspolarityliteral[0]{\metafunctionfont{neg}}
\newcommand\pluspolarity[1]{\withpolarity{#1}{\pluspolarityliteral}}
\newcommand\minuspolarity[1]{\withpolarity{#1}{\minuspolarityliteral}}

\newcommand\notequal[0]{\ma{\not=}}

% objects
\newcommand\path[2]{\ma{#1(#2)}}
\newmeta\object{o}
\newmeta\objectp{o'}
\newmeta\emptyobject{\emptyset}
\newmeta\pathelem{\pi}
\newmeta\pathelemp{\pi'}
% abstract syntax for pathelem
\newmeta\pesyntax{pe}
\newmeta\classpe{{\bf class}}
\newcommand\keype[1]{\ma{{\bf key}_{\ma{#1}}}}

\newcommand\destructpath[2]{\ma{#1 :: #2}}

% scope replacements
\newcommand\replacefor[3]{\ma{#1 [#2 / #3]}}

% Java type conversion functions
\newcommand\javatotcliteral[0]{\ma{\metafnfont{JavaToTC}}}
\newcommand\javatotcnilliteral[0]{\ma{\javatotcliteral_{\nil{}}}}
\newcommand\javatotc[2]{\javatotcliteral(\ma{#1})\ =\ #2}
\newcommand\javatotcnil[2]{\ma{\javatotcnilliteral(\ma{#1})\ =\ #2}}
\newcommand\javatotcalign[2]{\javatotcliteral(\ma{#1})\ &=&\ #2}
\newcommand\javatotcalignnil[2]{\javatotcliteral_{\nil{}}(\ma{#1})\ &=&\ #2}

% # Runtime semantics
% ## Runtime class syntax
\newmeta\classvaluemeta{I}
\newcommand\classfieldpair[2]{#1 : #2}
\newcommand\classvalue[2]{\ma{#1\ \{#2\}}}

% ## metafunction to invoke java
% Class Target Method ArgTypes Args ReturnType ReturnValue
\newcommand\invokejavamethodliteral[0]{\ma{JVM_{invokestatic}}}
\newcommand\invokejavamethodnoeq[6]{\ma{\invokejavamethodliteral[#1, #2, #3, [#4], [#5], #6]}}
\newcommand\invokejavamethod[7]{\ma{\invokejavamethodnoeq{#1}{#2}{#3}{#4}{#5}{#6} = #7}} % Class Args ReturnValue
% Class ArgTypes Args ReturnValue
\newcommand\newjavaliteral[0]{\ma{JVM_{new}}}
\newcommand\newjavanoeq[3]{\ma{\newjavaliteral[#1, [#2], [#3]]}}
\newcommand\newjava[4]{\ma{\newjavanoeq{#1}{#2}{#3} = #4}}
% Class Target Field FieldType ReturnValue
\newcommand\getfieldliteral[0]{\ma{JVM_{getstatic}}}
\newcommand\getfieldjavanoeq[4]{\ma{\getfieldliteral[#1, #2, #3, #4]}}
\newcommand\getfieldjava[5]{\ma{\getfieldjavanoeq{#1}{#2}{#3}{#4} = #5}}
% Class Target Bool
\newcommand\instanceofjava[3]{\ma{JVM_{instanceof}[#1, #2] = #3}}

\newcommand\satisfies[2]{\ma{{#1} \models {#2}}}

\newmeta\wrongorerror{\beta}

\newcommand\consistentwith[2]{\ma{{#1}\ \text{is consistent with}\ {#2}}}
\newcommand\isconsistent[1]{\ma{{#1}\ \text{is consistent}}}
\newcommand\fv[1]{\ma{{\metafunctionfont{fv}}(#1)}}

\newcommand\istrueval[1]{\ma{\metafunctionfont{TrueVal}(#1)}}
\newcommand\isfalseval[1]{\ma{\metafunctionfont{FalseVal}(#1)}}

\newmeta\definedreduction{\alpha}

% Common typing rules
\newcommand\TLocal[0]{
\infer [T-Local]
{ \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}
  \\
  \s{} = {\falsydiff} }
{ \judgementfillcol {\propenv{}} 
                    {\hastype {\x{}} {\t{}}}
                    {\filterset {{\notprop {\s{}} {\x{}}}} {{\isprop {\s{}} {\x{}}}}}
                    {\x{}}
                   }
                 }

\newcommand\TTrue[0]{
\infer [T-True]
{}
{ \judgementfillcol {\propenv{}}
      {{\hastype {\true{}} {\True{}}}}
      {{\filterset {\topprop{}} {\botprop{}}}}
      {\emptyobject{}}
    }
  }

\newcommand\TFalse[0]{
\infer [T-False]
{}
{ \judgementfillcol {\propenv{}}
      {{\hastype {\false{}} {\False{}}}}
      {\filterset {\botprop{}} {\topprop{}}}
    {\emptyobject{}}
   }
 }

\newcommand\TNil[0]{
\infer [T-Nil]
{}
{ \judgementfillcol {\propenv{}} 
      {{\hastype {\nil{}} {\Nil{}}}} 
      {\filterset {\trdiff{\botprop{}}} {\topprop{}}}
      {\emptyobject{}} 
    }
  }

\newcommand\TDo[0]{
\infer [T-Do]
{ 
  \judgement {\propenv{}} 
             {\hastype {\e1} {\t1}} 
             {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop1}}} 
             {\object{1}}
\\\\
\judgement {\propenv{}, {\trdiff {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}}
           {\hastype {\e{}} {\t{}}} 
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}}
  }
{ \judgement
    {\propenv{}} 
    {\hastype {\doexp {\e1} {\e{}}} {\t{}}} 
    {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} {\object{}} 
             }
           }

\newcommand\TIf[0]{
\infer [T-If]
{ \judgement {\propenv{}} {\hastype {\e1} {\t{1}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
                 {\object{1}} 
             \\\\
  \judgement {\propenv{}, {\thenprop {\prop{1}}}}
                 {\hastype {\e2} {\t{}}} {\filterset {\thenprop {\prop{2}}} {\elseprop {\prop{2}}}}
                 {\object{}}
  \\\\
  \judgement {\propenv{}, {\elseprop {\prop{1}}}}
                 {\hastype {\e3} {\t{}}} {\filterset {\thenprop {\prop{3}}} {\elseprop {\prop{3}}}}
                 {\object{}}
             }
{ \judgement {\propenv{}} {\hastype {\ifexp {\e1} {\e2} {\e3}} {\t{}}} 
                 {\filterset {\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}} 
                             {\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}}
                 {\object{}} }

             }

\newcommand\TLet[0]{
\infer [T-Let]
{ \judgement {\propenv{}} {\hastype {\e{1}} {\s{}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
             {\object{1}}
             \\\\
             \propp{} = {\impprop {\notprop {\falsydiff{}} {\x{}}} {\thenprop {\prop{1}}}}
             \\\\
             \proppp{} = {\impprop {\isprop {\falsydiff{}} {\x{}}} {\elseprop {\prop{1}}}}
  \\\\
  \judgement
       {\propenv{}, {\isprop {\s{}} {\x{}}},
         {\propp{}},
         {\proppp{}}}
             {\hastype {\e{}} {\t{}}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\object{}} 
             }
{ \judgement {\propenv{}} {\hastype {\letexp {\x{}} {\e{1}} {\e{}}} {\t{}}}
             {\replacefor {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
                          {\object{1}}
                          {\x{}}}
             {\replacefor {\object{}} 
                          {\object{1}}
                          {\x{}}}
             }

           }

\newcommand\TApp[0]{
\infer [T-App]
{ \judgement {\propenv{}} {\hastype {\e{}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}}
                {\filterset {\thenprop {\prop{}}}
                            {\elseprop {\prop{}}}}
                {\object{}}
  \\\\
  \judgement {\propenv{}}
                 {\hastype {\ep{}} {\s{}}}
                 {\filterset {\thenprop {\propp{}}}
                             {\elseprop {\propp{}}}}
                 {\objectp{}} 
}
{ \judgementfillcol {\propenv{}} {\hastype {\appexp {\e{}} {\ep{}}}
                                        {\replacefor {\t{}}
                                                     {\objectp{}}
                                                     {\x{}}}}
                 {\replacefor {\filterset {\thenprop {\prop{f}}}
                                          {\elseprop {\prop{f}}}}
                              {\objectp{}}
                              {\x{}}}
                 {\replacefor {\object{f}}
                              {\objectp{}}
                              {\x{}}}
}
}

\newcommand\TAbs[0]{
\infer [T-Abs]
{ \judgement {\propenv{}, {\isprop {\s{}} {\x{}}}}
            {\hastype {\e{}} {\t{}}}
             {\filterset {\thenprop {\prop{}}}
                         {\elseprop {\prop{}}}}
             {\object{}}}
{ \judgement {\propenv{}} {\hastype {\abs {\x{}} {\s{}} {\e{}}}
                                           {\ArrowOne {\x{}} {\s{}}
                                                      {\t{}}
                                                      {\filterset {\thenprop {\prop{}}}
                                                                  {\elseprop {\prop{}}}}
                                                      {\object{}}}}
                {\filterset {\topprop{}}
                            {\botprop{}}}
                {\emptyobject{}}}
            }

\newcommand\TSubsume[0]{
\infer [T-Subsume]
{ \judgement {\propenv{}} {\hastype {\e{}} {\t{}}}
             {\filterset {\thenprop {\prop{}}}
                         {\elseprop {\prop{}}}}
             {\object}
\\\\
\inpropenv {\propenv{}, {\thenprop {\prop{}}}} {\thenprop {\propp{}}}
\\
\inpropenv {\propenv{}, {\elseprop {\prop{}}}} {\elseprop {\propp{}}}
\\\\
\inpropenv {} {\issubtype {\t{}} {\tp{}}}
\\
\inpropenv {} {\issubtype {\object{}} {\objectp{}}}
}
{ \judgement {\propenv{}} {\hastype {\e{}} {\tp{}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
             {\objectp{}}}
         }

\newcommand\TNewStatic[0]{
\infer [T-NewStatic]
{ 
  \overrightarrow{
\javatotc {\classhint{i}}
          {\t{i}}
          }
  \\
  \javatotc {\classhint{}}
            {\t{}}
  \\
  \overrightarrow{
  \judgementtwo {\propenv{}}
                    {\hastype {\e{i}} {\t{i}}}
                  }
           }
{ \judgementfillcol {\propenv{}} {\hastype {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                                                          {\class{}} {\overrightarrow{\e{i}}}} {\t{}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject}
             }
         }

\newcommand\TFieldStatic[0]{
\infer [T-FieldStatic]
{ \javatotc {\classhint{1}} {\class{}}
             \\
  \javatotcnil {\classhint{2}} {\t{}}
  \\
  \judgementtwo {\propenv{}} {\hastype {\e{1}} {\class{}}}
           }
{ \judgement {\propenv{}} {\hastype {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{1}}} {\t{}}}
             {\filterset {\topprop{}} {\topprop}}
             {\emptyobject{}}}
         }

\newcommand\TMethodStatic[0]{
\infer [T-MethodStatic]
{ 
  \overrightarrow{\javatotc {\classhint{i}} {\t{i}}}
             \\
             \javatotc {\classhint{1}} {\class{}}
             \\\\
             \javatotcnil {\classhint{2}} {\t{}}
             \\
  \judgementtwo {\propenv{}} {\hastype {\e{}} {\class{}}}
             \\
             \overrightarrow{
  \judgementtwo {\propenv{}} {\hastype {\e{i}} {\t{i}}}
                  }
           }
{ \judgementfillcol {\propenv{}} {\hastype {\methodstaticexp {\classhint{1}} 
                                                            {\overrightarrow {\classhint{i}}} 
                                                            {\classhint{2}}
                                                            {\mth{}} {\e{}} {\overrightarrow{\e{i}}}}
                                    {\t{}}}
             {\filterset {\topprop{}} {\topprop{}}}
             {\emptyobject{}}}
         }

\newcommand\TClass[0]{
\infer [T-Class]
{}
{ \judgement {\propenv{}} {\hastype{\class{}}{\Value{\class{}}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}}
         }

\newcommand\TDefMulti[0]{
\infer [T-DefMulti]
{ \s{} = {\ArrowOne {\x{}} {\t{}} {\tp{}}
                          {\filterset {\thenprop {\prop{}}}
                                      {\elseprop {\prop{}}}}
                          {\object{}}}
                          \\
  \sp{} = {\ArrowOne {\x{}} {\t{}} {\tpp{}}
                          {\filterset {\thenprop {\propp{}}}
                                      {\elseprop {\propp{}}}}
                          {\objectp{}}}
                \\\\
\judgementtwo {\propenv{}} {\hastype {\e{}} {\sp{}}}
}
{
  \judgement {\propenv{}}  
      {\hastype {\createmultiexp {\s{}}
                                 {\e{}}} 
                {\MultiFntype {\s{}} {\sp{}}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject{}}
}
}

\newcommand\TDefMethod[0]{
\infer [T-DefMethod]
{
  \t{m} = {\ArrowOne {\x{}} {\t{}} {\s{}}
                                    {\filterset {\thenprop {\prop{}}}
                                                {\elseprop {\prop{}}}}
                                    {\object{}}}
\\
\t{d} = {\ArrowOne {\x{}} {\t{}} {\sp{}}
                   {\filterset {\thenprop {\propp{}}}
                               {\elseprop {\propp{}}}}
                   {\objectp{}}}
             \\\\
\judgementtwo {\propenv{}}
                  {\hastype {\e{m}} {\MultiFntype {\t{m}} {\t{d}}}}
\\
  \isacompare{\sp{}}{\objectp{}}{\t{v}}{\filterset {\thenprop {\proppp{}}} {\elseprop {\proppp{}}}}
\\\\
\judgementtwo {\propenv{}}
           {\hastype {\e{v}} {\t{v}}}
           \\
\judgement {\propenv{}, {\isprop{\t{}} {\x{}}}, {\thenprop {\proppp{}}}}
           {\hastype {\e{b}} {\s{}}}
           {\filterset {\thenprop {\prop{}}}
                       {\elseprop {\prop{}}}}
           {\object{}}
}
{ \judgementfillcol {\propenv{}} {\hastype {\extendmultiexp {\e{m}} {\e{v}} 
                                                            {\abs {\x{}} {\t{}} {\e{b}}}}
                                           {\MultiFntype {\t{m}} {\t{d}}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject{}}
}
}

\newcommand\TIsA[0]{
\infer [T-IsA]
{
  \judgement {\propenv{}} {\hastype {\e{}} {\s{}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
                       {\object{}}
  \\
  \judgementtwo
             {\propenv{}} {\hastype {\ep{}} {\t{}}}
             \\
  \isacompare{\s{}}{\object{}}{\t{}}{\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
}
{ \judgement {\propenv{}} {\hastype {\isaapp {\e{}} {\ep{}}}
                                    {\Boolean{}}}
             {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\emptyobject}}
         }


% common Syntax
\newcommand\occurrencetypingsyntax[0]{
  \prop{}       &::=& {\isprop {\t{}} {\path {\pathelem{}} {\x{}}}}
                      \alt {\notprop {\t{}} {\path {\pathelem{}} {\x{}}}}
                      \alt {\impprop {\prop{}} {\prop{}}}
                      \alt {\andprop {\prop{}} {\prop{}}}
                      \alt {\orprop {\prop{}} {\prop{}}}
                      \alt \topprop{}
                      \alt \botprop{}
                &\mbox{Propositions} \\
  \object{}     &::=& {\path {\pathelem{}} {\x{}}}
                      \alt \emptyobject{}
                &\mbox{Objects} \\
  \pathelem{}   &::=& \overrightarrow{\pesyntax{}}
                &\mbox{Paths} \\
  \pesyntax{}   &::=& \trdiff{\classpe{}} \alt \trdiff{\keype{\k{}}}
                &\mbox{Path Elements}\\
  \propenv{}   &::=& \overrightarrow{\prop{}}
               &\mbox{Proposition Environment} \\
              }

\newcommand\classliteralallsyntax[0]{
   \class{}      &::=& \Object{}
                      \alt \Keyword{}
                      %\alt \Number{}
                      \alt \Class{}
                      \alt \Boolean{}
                      %\alt \File{}
                      %\alt \String{}
                      \alt \IFn{}
                      \alt \PMulti{}
                      \alt \HMapInstance{}
                      \alt \Void{}
                &\mbox{Class literals}
              }

\newcommand\singletonallsyntax[0]{
  \singletonmeta{}     &::=& \k{} 
                             \alt {\trdiff{\class{}}}
                             \alt {\trdiff{\Nil}}
                             \alt {\True}
                             \alt {\False}
                &\mbox{Value types}
              }

% common operational semantics

\newcommand\BLocal[0]{
\infer [B-Local]
{ \inopenv {\openv{}} {\x{}} {\v{}} }
{ \opsem {\openv{}} {\x{}} {\v{}} }
}

\newcommand\BDo[0]{
\infer [B-Do]
{ \opsem {\openv{}} {\e{1}} {\v{1}} 
  \\\\
  \opsem {\openv{}} {\e{}} {\v{}} 
}
{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\v{}} }
}


\newcommand\BLet[0]{
\infer [B-Let]
{ \opsem {\openv{}} {\e{a}} {\v{a}}
  \\\\
  \opsem {\extendopenv{\openv{}}{\x{}}{\v{a}}}
         {\e{}}
         {\v{}}
 }
{ \opsem {\openv{}} 
         {\letexp {\x{}} {\e{a}} {\e{}}}
         {\v{}}}
     }


\newcommand\BVal[0]{
\infer [B-Val]
{}
{ \opsem {\openv{}} {\v{}} {\v{}}}
}

\newcommand\BIfTrue[0]{
\infer [B-IfTrue]
{ \opsem {\openv{}} {\e{1}} {\v{1}}
  \\\\
  {\v{1}} \not= {\false{}}
  \\
  {\trdiff{{\v{1}} \not= {\nil{}}}}
  \\\\
  \opsem {\openv{}} {\e{2}} {\v{}}
}
{ \opsem {\openv{}}
         {\ifexp {\e1} {\e2} {\e3}}
         {\v{}}
       }
     }

\newcommand\BIfFalse[0]{
\infer [B-IfFalse]
{  \opsem {\openv{}} {\e{1}} {\false{}}
  \ \ \trdiff{\text{or}\ \ 
  {\opsem {\openv{}} {\e{1}} {\nil{}}}}
  \\\\
  \opsem {\openv{}} {\e{3}} {\v{}}
}
{ \opsem {\openv{}}
         {\ifexp {\e1} {\e2} {\e3}}
         {\v{}}
       }
     }

\newcommand\BAbs[0]{
\infer [B-Abs]
{}
{ \opsem {\openv{}}
         {\abs {\x{}} {\t{}} {\e{}}}
         {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}}
     }

\newcommand\BIsA[0]{
\infer [B-IsA]
{ \opsem {\openv{}} {\e{1}} {\v{1}}
  \\
  \opsem {\openv{}} {\e{2}} {\v{2}}
  \\
  \isaopsem{\v{1}}{\v{2}} = {\v{}}
}
{\opsem {\openv{}} {\isaapp {\e{1}} {\e{2}}} {\v{}}}
}

\newcommand\BBetaClosure[0]{
\infer [B-BetaClosure]
{ \opsem {\openv{}}
         {\e{f}}
         {\closure {\openv{c}} {\abs {\x{}} {\t{}} {\e{b}}}}
         \\\\
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
         \\\\
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{a}}}
         {\e{b}}
         {\v{}}
       }
{ \opsem {\openv{}}
         {\appexp {\e{f}} {\e{a}}}
         {\v{}}
       }
     }

\newcommand\BBetaMulti[0]{
\infer [B-BetaMulti]
{ \opsem {\openv{}}
         {\e{f}}
         {\multi {\v{d}} {\disptable{}}}
         \\
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
         \\
  \opsem {\openv{}}
         {\appexp {\v{d}} {\v{a}}}
         {\v{e}}
         \\\\
  \getmethod {\disptable{}}
             {\v{e}}
             {\roundpair{\v{k}}{\v{f}}}
         \\
  \opsem {\openv{}}
         {\appexp {\v{f}} {\v{a}}}
         {\v{}}
       }
{ \opsem {\openv{}}
         {\appexp {\e{f}} {\e{a}}}
         {\v{}}
       }
     }

     \newcommand\getmethodfigure[0]{
$$
\begin{array}{lr}

  \getmethod {\disptable{}}
             {\v{e}}
             {\roundpair{\v{v}}{\v{f}}}
             \\
             \ \ \ \ 
             \text{let } {\overrightarrow{\v{fs}}} = 
                \{ (\v{v}, \v{f}) | 
                    {\roundpair{\v{v}}{\v{f}}} \in \disptable{} 
                  \text{ and } 
                \isaopsem{\v{v}}{\v{e}} = {\true{}} \},
                \\
             \ \ \ \ 
             \text{ if } {\overrightarrow{\v{fs}}} = \{{\roundpair{\v{v}}{\v{f}}}\}

             \\
  \getmethod {\disptable{}}
             {\v{e}}
             {\mmerror{}} & \text{otherwise}

\end{array}
$$
     }

     \newcommand\BDefMulti[0]{
\infer [B-DefMulti]
{ \opsem {\openv{}} {\e{d}} {\v{d}}
}
{\opsem {\openv{}}
        {\createmultiexp {\t{}}
                         {\e{d}}}
        {\multi {\v{d}} {\emptydisptable}}
}
     }

     \newcommand\BDefMethod[0]{
\infer [B-DefMethod]
{ \opsem {\openv{}}
         {\e{m}}
         {\multi {\v{d}} {\disptable{}}}
         \\
  \opsem {\openv{}}
         {\e{v}}
         {\v{v}}
         \\\\
  \opsem {\openv{}}
         {\e{f}}
         {\v{f}}
         \\
         \disptablep{} = {\extenddisptable {\disptable{}} 
                                {\v{v}}
                                {\v{f}}}
}
{\opsem {\openv{}}
        {\extendmultiexp {\e{m}} {\e{v}} {\e{f}}}
        {\multi {\v{d}} {\disptablep{}}}
      }
     }

\newcommand\BDelta[0]{
\infer [B-Delta]
{ \opsem {\openv{}} {\e{}} {\const{}}
  \\\\
  \opsem {\openv{}} {\ep{}} {\v{}}
  \\\\
  \constantopsem{\const{}}{\v{}} = \vp{}
}
{ \opsem {\openv{}}
         {\appexp {\e{}} {\ep{}}}
         {\vp{}}
       }
     }

\newcommand\BField[0]{
\infer [B-Field]
{ \opsem {\openv{}}
         {\e{}} 
       {\v{1}}
         \\
         \getfieldjava{\classhint{1}} {\v{1}} {\fld{}} {\classhint{2}} {\v{}}
       }
{ \opsem {\openv{}}
         {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{}}}
         {\v{}}
   }
}

\newcommand\BMethod[0]{
\infer [B-Method]
{ \opsem {\openv{}}
         {\e{m}}
         {\v{m}}
  \\
  \overrightarrow{
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
       }
  \\\\
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{a}}} {\overrightarrow{\v{a}}}
                    {\classhint{2}}
                    {\v{}}
}
{\opsem {\openv{}}
        {\methodstaticexp {\classhint{1}} {\overrightarrow{\classhint{a}}} {\classhint{2}} {mth} {\e{m}} {\overrightarrow{\e{a}}}}
        {\v{}}
      }
}

\newcommand\BNew[0]{
\infer [B-New]
{ 
  \overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }
         \\
         \newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\v{}}
       }
{ \opsem {\openv{}}
         {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{1}} 
                        {\class{}} {\overrightarrow{\e{i}}}}
         {\v{}}}
}

% subtyping syntax
\newcommand\standardsubtyping[0]{

\infer [SO-Refl]
{}
{ \issubobjin {} {\object{}} {\object{}}}


\infer [SO-Top]
{}
{ \issubobjin {} {\object{}} {\emptyobject{}}}

\infer [S-Refl]
{}
{ \issubtypein {} {\t{}} {\t{}}}

\infer [S-Top]
{}
{ \issubtypein {} {\t{}} {\Top{}}}

\infer [S-UnionSuper]
{ \exists i.\ {\issubtypein {} {\t{}} {\s{i}}}}
{ \issubtypein {} {\t{}} {\Unionsplice{{\overrightarrow{\s{}}}^{i}}}}

% FIXME fix overrightarrow caption
\infer [S-UnionSub]
{ {\overrightarrow {\issubtypein {} {\t{i}} {\s{}}}}^{i}}
{ \issubtypein {} {\Unionsplice{\overrightarrow{\t{}}^{i}}} {\s{}}}

\infer [S-Fun]
{ \issubtypein {} {\sp{}} {\s{}}
  \\
  \issubtypein {} {\t{}} {\tp{}}
  \\\\
  \inpropenv {\thenprop {\prop{}}} {\thenprop {\propp{}}}
  \\
  \inpropenv {\elseprop {\prop{}}} {\elseprop {\propp{}}}
  \\
  \issubobjin{} {\object{}} {\objectp{}}
}
{ \issubtypein {}
    {\ArrowOne {\x{}} {\s{}}
              {\t{}}
              {\filterset {\thenprop {\prop{}}}
                          {\elseprop {\prop{}}}}
              {\object{}}}
    {\ArrowOne {\x{}} {\sp{}}
              {\tp{}}
              {\filterset {\thenprop {\propp{}}}
                          {\elseprop {\propp{}}}}
              {\objectp{}}}}

\infer [S-SKw]
{}
{\issubtypein {}
  {\Value{\k{}}}
  {\Keyword}}

\infer [S-SClass]
{}
{\issubtypein {}
  {\Value{\class{}}}
  {\Class{}}}

\infer [S-STrue]
{}
{\issubtypein {}
  {\Value{\True}}
  {\Boolean{}}}

\infer [S-SFalse]
{}
{\issubtypein {}
  {\Value{\False}}
  {\Boolean{}}}


\infer [S-Object]
{}
{\issubtypein {}
  {\class{}}
  {\Object{}}}


\infer [S-FunMono]
{}
{\issubtypein {}
  {\ArrowOne {\x{}} {\s{}}
             {\t{}}
             {\filterset {\thenprop{\prop{}}}
                         {\elseprop{\prop{}}}}
             {\object{}}}
  {\IFn{}}}

}

\newcommand\HMapsubtyping[0]{
\infer [S-HMap]
{ \forall i.\ ({\k{i}},\ \s{i}) \in \mandatory{} \text{ and } \issubtypein {} {\s{i{}}} {\t{i{}}}
  \\
  {\absent{1}} \supseteq {\absent{2}}
}
{\issubtypein {} {\HMapgeneric {\mandatory{}} {\absent{1}}}
  {\HMapgeneric {\overrightarrow{(\k{},\ \t{})}^i} {\absent{2}}}
               }

\infer [S-HMapP]
{ \forall i.\ ({\k{i}},\ \s{i}) \in \mandatory{} \text{ and } \issubtypein {} {\s{i{}}} {\t{i{}}}
}
{\issubtypein {} 
  {\HMapc {\mandatory{}}}
  {\HMapp {\overrightarrow{(\k{},\ \t{})}^i} {\absent{}}}
               }

\infer [S-HMapMono]
{}
{\issubtypein {} 
  {\HMapgeneric {\mandatory{}} {\absent{}}}
  {\HMapInstance{}}}
}

\newcommand\Multisubtyping[0]{
\infer [S-PMulti]
{ \issubtypein {} {\s{}} {\sp{}}
  \\
  \issubtypein {} {\t{}} {\tp{}}}
{ \issubtypein {} {\MultiFntype {\s{}} {\t{}}}{\MultiFntype {\sp{}} {\tp{}}}}

\infer [S-PMultiFn]
{ \issubtypein {}
  {\s{t}}
  {\ArrowOne {\x{}} {\s{}} {\t{}}
                                  {\filterset {\thenprop {\prop{}}}
                                              {\elseprop {\prop{}}}}
                                      {\object{}}}
                                      \\
  \issubtypein {}
  {\s{d}}
  {\ArrowOne {\x{}} {\s{}} {\tp{}}
                                  {\filterset {\thenprop {\propp{}}}
                                              {\elseprop {\propp{}}}}
                                      {\objectp{}}}
}
{ \issubtypein {} {\MultiFntype{\s{t}}{\s{d}}}
                  {\ArrowOne {\x{}} {\s{}} {\t{}}
                             {\filterset {\thenprop {\prop{}}}
                                         {\elseprop {\prop{}}}}
                             {\object{}}}}

\infer [S-MultiMono]
{}
{\issubtypein {}
  {\MultiFntype {\ArrowOne {\x{}} {\s{}} {\t{}}
                          {\filterset {\thenprop{\prop{}}}
                                      {\elseprop{\prop{}}}}
                          {\object{}}}
                {\ArrowOne {\x{}} {\s{}} {\tp{}}
                          {\filterset {\thenprop{\propp{}}}
                                      {\elseprop{\propp{}}}}
                          {\objectp{}}}
                }
  {\PMulti{}}
}
                       }

% isa? operational semantics

\newcommand\isaopsemfigure[0]{
  \ma{
\begin{array}{lllr}
  \isaopsem{\v{}}{\v{}} &=& {\true{}} & \text{if}\ \v{} \notequal {\class{}} \\
  \isaopsem{\class{1}}{\class{2}} &=& {\true{}} & \text{if}\ \issubtypein{}{\class{1}}{\class{2}}\\
  \isaopsem{\v{1}}{\v{2}} &=& {\false{}} & \text{otherwise}
\end{array}
  }
}

\newcommand\isapropsfigure[0]{
  \ma{
\begin{array}{lllr}
  \isacomparealign{\s{}}{\path{\classpe{}}{\path{\pathelem{}}{\x{}}}}{\Value{\class{}}}
             {\filterset{\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}
                        {\notprop{\class{}}{\path{\pathelem{}}{\x{}}}}}
                        \\
  \isacomparealign{\s{}}{\object{}}{\Value{\singletonmeta{}}}
             {\replacefor
               {\filtersetparen{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                   {\notprop{\Value{\singletonmeta{}}}{\x{}}}}
                   {\object{}}
                   {\x{}}}
                 \\
                   && \text{if}\ {\singletonmeta{}} \not= \class{}
               \\
  \isacomparealign{\s{}}{\object{}}{\t{}}
                  {\filterset{\topprop{}}
                             {\topprop{}}}
\end{array}
  }
}

% multimethod syntax

\newcommand\disptablesyntax[0]{
 \disptable{}   &::=& \{ \overrightarrow{\v{} \mapsto \v{}} \}
               &\mbox{Multimethod dispatch table}
             }
\newcommand\multimethodexpsyntax[0]{
  {\createmultiexp {\t{}} {\e{}}}
                      \alt
                              {\extendmultiexp {\e{}} {\e{}} {\e{}}}
                      \alt {\isaapp {\e{}} {\e{}}}
              }

% HMap syntax auxiliary 
\newcommand\auxhmapsyntax[0]{
  \mandatory{} &::=& \mandatorysetoverright{\k{}}{\t{}}
                &\mbox{HMap mandatory entries} \\
  \absent{} &::=& \absentoverright{\k{}}
                &\mbox{HMap absent entries} \\
  \completenessmeta{} &::=& {\complete{}} \alt {\partial{}}
                &\mbox{HMap completeness}
              }

\newcommand\hmapexpressionsyntax[0]{
                      {\getexp {\e{}} {\e{}}}
                      \alt {\assocexp {\e{}}{\e{}}{\e{}}}
                    }

% reflective Java interop syntax
\newcommand\reflectiveexpsyntax[0]{
                      {\fieldexp {\fld{}} {\e{}}}
                      \alt {\methodexp {\mth{}} {\e{}} {\overrightarrow{\e{}}}}
                      \alt {\newexp {\class{}} {\overrightarrow{\e{}}}}
}

\newcommand\fieldexpsyntax[0]{
                      {\fieldstaticexp {\classhint{}} {\classhint{}} {\fld{}} {\e{}}}
}

\newcommand\methodexpsyntax[0]{
  {\methodstaticexp {\classhint{}} {\overrightarrow{\classhint{}}} {\classhint{}} {\mth{}} {\e{}} {\overrightarrow{\e{}}}}
}

\newcommand\newexpsyntax[0]{
  {\newstaticexp {\overrightarrow {\classhint{}}} {\classhint{}} {\class{}} {\overrightarrow{\e{}}}}
}

% nonreflective Java interop syntax
\newcommand\nonreflectiveexpsyntax[0]{
  \fieldexpsyntax{}
  \alt \methodexpsyntax{}
  \alt \newexpsyntax{}
}

% small figure for nonreflective Java interop syntax
\newcommand\mininonreflectiveexpsyntax[0]{
  \fieldexpsyntax{} \alt \methodexpsyntax{} \alt \newexpsyntax{}
}

\newcommand\lethintsyntax[0]{
  {\letexp {\hinted {\classhint{}} {\x{}}} {\e{}} {\e{}}}
}

\newcommand\localhintsyntax[0]{
  \hinted{\classhint{}} {\x{}}
}

\newcommand\typehintedexpsyntax[0]{
  \localhintsyntax{}
  \alt \lethintsyntax{}
}

\newcommand\classvaluesyntax[0]{
  {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
}

% reflection resolution rewrite 

\newcommand\RLocal[0]{
\infer [R-Local]
{}
{ \rewrite {\taenv{}}
           {\x{}}
           {\x{}}
         }
       }

\newcommand\RNewElimRefl[0]{
\infer [R-NewElimRefl]
{ \overrightarrow{
    \rewrite {\taenv{}}
           {\e{i}}
           {\e{j}}}
  \\
  \overrightarrow{
  \tajudgement {\taenv{}}
               {\hastype {\e{j}} {\classhint{j}}}
             }
               \\\\
  \ctorparams {\ct{}}{\classhint{}}{\overrightarrow{\classhint{j}}}{\overrightarrow{\classhint{k}}}
             }
{ \rewrite {\taenv{}}
           {\newexp {\class{}} {\overrightarrow {\e{i}}}}
           {\newstaticexp {\overrightarrow {\classhint{k}}} {\classhint{}} {\class{}} {\overrightarrow {\e{j}}}}
}

       }

\newcommand\RLet[0]{
\infer [R-Let]
{ \rewrite {\taenv{}}
           {\e{1}}
           {\ep{1}}
           \\
  \tajudgement {\taenv{}} {\hastype {\ep{1}} {\tatype{}}}
           \\\\
  \rewrite {\taenv{}, {\hastype {\x{}} {\tatype{}}}}
           {\e{}}
           {\ep{}}
         }
{ \rewrite {\taenv{}}
           {\letexp {\x{}}
                    {\e{1}}
                    {\e{}}}
           {\letexp {\x{}}
                    {\ep{1}}
                    {\ep{}}}
}
       }

\newcommand\RLetHint[0]{
\infer [R-LetHint]
{ \rewrite {\taenv{}}
           {\e{1}}
           {\ep{1}}
           \\
  \rewrite {\taenv{}, {\hastype {\x{}} {\classhint{}}}}
           {\e{}}
           {\ep{}}
         }
{ \rewrite {\taenv{}}
           {\letexp {\hinted {\classhint{}} {\x{}}}
                    {\e{1}}
                    {\e{}}}
           {\letexp {\hinted {\classhint{}} {\x{}}}
                    {\ep{1}}
                    {\ep{}}}
}
}

\newcommand\RFieldElimRefl[0]{
\infer [R-FieldElimRefl]
{ \rewrite {\taenv{}}
           {\e{}}
           {\ep{}}
           \\
  \tajudgement {\taenv{}}
               {\hastype {\ep{}} {\classhint{}}}
               \\\\
               \fieldtype {\ct{}} {\classhint{}} {\fld{}} {\classhint{t}}{\classhint{f}}
         }
{ \rewrite {\taenv{}}
           {\fieldexp {\fld{}} {\e{}}}
           {\fieldstaticexp {\classhint{t}} {\classhint{f}} {\fld{}} {\ep{}}}
         }
       }

\newcommand\RMethodElimRefl[0]{
\infer [R-MethodElimRefl]
{ \rewrite {\taenv{}}
           {\e{}}
           {\ep{}}
           \\
  \tajudgement {\taenv{}}
               {\hastype {\ep{}} {\classhint{}}}
           \\\\
           \overrightarrow{
  \rewrite {\taenv{}}
           {\e{i}}
           {\e{j}}}
           \\
           \overrightarrow{
  \tajudgement {\taenv{}}
               {\hastype {\e{j}} {\classhint{j}}}
             }
               \\\\
  \methodtype {\ct{}}{\classhint{}} {\mth{}} {\overrightarrow{\classhint{j}}}{\classhint{t}}{\overrightarrow{\classhint{p}}}{\classhint{r}}
         }
{ \rewrite {\taenv{}}
           {\methodexp {\mth} {\e{}} {\overrightarrow {\e{i}}}}
           {\methodstaticexp {\classhint{t}} {\overrightarrow {\classhint{p}}} {\classhint{r}} {\mth{}} {\ep{}} {\overrightarrow {\e{j}}}}
  }
}

\newcommand\RAbs[0]{
\infer [R-Abs]
{ \rewrite {\taenv{}, {\hastype {\x{}} {\unknownhint{}}}}
           {\e{}}
           {\ep{}}
}
{ \rewrite {\taenv{}}
           {\abs {\x{}} {\t{}} {\e{}}}
           {\abs {\x{}} {\t{}} {\ep{}}}
         }
       }

% type hint propagation

\newcommand\TALocal[0]{
\infer [TA-Local]
{ \intaenv {\taenv{}} {\x{}} {\tatype{}}
}
{ \tajudgement {\taenv{}} {\hastype {\x{}} {\tatype{}}}
}
}

\newcommand\TANil[0]{
\infer [TA-Nil]
{}
{ \tajudgement {\taenv{}} {\hastype {\nil{}} {\unknownhint{}}}
}
}

\newcommand\TANewStatic[0]{
\infer [TA-NewStatic]
{}
{ \tajudgement {\taenv{}}
  {\hastype {\newstaticexp {\overrightarrow {\classhint{i}}} {\classhint{}} {\class{}} {\overrightarrow {\e{}}}}
                           {\classhint{}}}
}
}

\newcommand\TALetHint[0]{
\infer [TA-LetHint]
{ \tajudgement {\taenv{}, {\hastype {\x{}} {\classhint{}}}}
               {\hastype {\e{}} {\tatype{}}}
}
{ \tajudgement {\taenv{}}
      {\hastype {\letexp {\hinted{\classhint{}}{\x{}}}
                                  {\e{1}}
                                  {\e{}}}
                         {\tatype{}}}
}
}

\newcommand\TALet[0]{
\infer [TA-Let]
{ \tajudgement {\taenv{}} 
               {\hastype {\e{1}} {\tatype{1}}}
               \\\\
  \tajudgement {\taenv{}, {\hastype {\x{}} {\tatype{1}}}}
               {\hastype {\e{}} {\tatype{}}}
}
{ \tajudgement {\taenv{}}
               {\hastype {\letexp {\x{}}
                                  {\e{1}}
                                  {\e{}}}
                         {\tatype{}}}
}
}
