% see mmm.sty for implementation of newmeta etc

% macros for Clojure grammars
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{xcolor}


% newmeta variables are automatically subscripted
% \x0, \x1, \x{}

%% metavariables

% constants
\newmeta\const{c}

% types
\newmeta\s{\sigma}              % these are automatically wrapped in \ma
\newmeta\sp{\sigma{'}}
\newmeta\t{\tau}
\newmeta\tp{\tau{'}}
\newmeta\tpp{\tau{''}}
\newmeta\T{T}

% expressions
\newmeta\M{M}
\newmeta\N{N}
\newmeta\P{P}
\newmeta\e{e}
\newmeta\ep{e'}
\newmeta\expd{d}
\newmeta\ReflectiveExp{R}
\newmeta\NonReflectiveExp{E}
\newmeta\MultimethodExp{M}
\newmeta\HintedExp{H}
\newmeta\HashMapExp{G}

% we write a macro for every bit of abstract syntax.  That way they
% will all look the same!

% types
\newbfop\int{int}
\newbfop\Boolean{B}
\newbfop\Booleanhint{Boolean}
\newbfop\IFn{Fn}
\newbfop\MultiFn{MultiFn}
\newbfop\PMulti{Multi}
\newbfop\IPersistentMapLiteral{Map}
\newbfop\MapLiteral{Map}
\newbfop\Uliteral{\ma{\bigcup}}
\newbfop\Iliteral{\ma{\bigcap}}
\newbfop\Not{Not}
\newbfop\Allliteral{All}
\newbfop\TFnliteral{TFn}
\newbfop\Valueliteral{Val}
\newbfop\ArrayTwoLiteral{Array2}
\newbfop\ArrayLiteral{Array}
\newbfop\ArrayPLiteral{ArrayP}
\newbfop\Throwable{Throwable}
\newbfop\Class{Class}
\newbfop\Object{Object}
\newcommand\MultiFntype[2]{(\PMulti #1\ #2)}
\newcommand\proctype[2]{(#1 \to #2)}
\newcommand\EmptyUnion[0]{\ma{(\Uliteral)}}
\newcommand\Unionsplice[1]{(\ma{\Uliteral\ #1})}
\newcommand\Union[2]{(\ma{\Uliteral\ #1\ #2})}
\newcommand\In[1]{(\ma{\Iliteral\ #1})}
\newcommand\ArrayTwo[2]{(\ma{\ArrayTwoLiteral\ #1\ #2})}
\newcommand\Array[1]{(\ArrayLiteral #1)}
\newcommand\ArrayP[1]{(\ArrayPLiteral #1)}
% \proctype is a little overkill.
%% Reynolds' package can also abstract things like (\s1 \to \s2 \to \s3).
\newcommand\Arrow[4]{\ma{#1 \xrightarrow[#4]{#3} #2}}
% TODO figure out how to make #1 : #2 closer to the :
\newcommand\ArrowOne[5]{\ma{{\hastypesmall {#1} {#2}} \xrightarrow[#5]{#4} #3}}
\newcommand\ArrowOverright[5]{\ma{{\overrightarrow{\hastypesmall {#1} {#2}}} \xrightarrow[#5]{#4} #3}}
% minus filters and object, implicitly tt | tt; empty
\newcommand\ArrowTwo[3]{\ma{{\hastypesmall {#1} {#2}} \xrightarrow\ {#3}}}

\newcommand\coretyped[0]{\texttt{core.typed}}
\newcommand\All[2]{(\ma{\Allliteral\ [#1]\ #2})}
\newcommand\TFn[2]{(\ma{\TFnliteral\ [#1]\ #2})}
\newcommand\Value[1]{(\ma{\Valueliteral #1})}
\newcommand\ValueFalse[0]{(\ma{\Valueliteral \false})}
\newcommand\ValueNil[0]{(\ma{\Valueliteral \nil})}
\newcommand\ValueTrue[0]{(\ma{\Valueliteral \true})}
\newcommand\ValueBool[0]{(\ma{\Valueliteral \bool{}})}
\newcommand\ValueClass[0]{(\ma{\Valueliteral \class{}})}
\newcommand\ValueKw[0]{(\ma{\Valueliteral \k{}})}
\newmeta\singletonmeta{s}
\newbfop\Top{\ma{\top}}
\newbfop\Bottom{\ma{\bot}}
\newbfop\Bot{\ma{\bot}}
\newbfop\Keyword{K}
\newbfop\Keywordhint{Keyword}
\newbfop\Symbol{Symbol}
\newbfop\Number{Number}
\newbfop\Nil{nil}
\newbfop\True{true}
\newbfop\False{false}
\newbfop\falsy{(\ma{\cup\ \Nil\ \False})}
\newbfop\falsydiff{\ma{\trdiff{\falsy}}}
\newcommand\IPersistentMap[2]{(\ma{\IPersistentMapLiteral\ #1\ #2})}
\newcommand\Map[2]{(\ma{\MapLiteral #1\ #2})}
\newcommand\HMapInstance[0]{\ma{\IPersistentMapLiteral}}
\newbfop\HMapliteral{HMap}
\newmeta\completenessmeta{\mathcal{A}}
\newmeta\complete{\mathcal{C}}
\newmeta\partial{\mathcal{P}}
\newcommand\HMapcliteral[0]{\HMapliteral^{\complete{}}}
\newcommand\HMappliteral[0]{\HMapliteral^{\partial{}}}
\newcommand\HMapgenericliteral[0]{\HMapliteral^{\completenessmeta{}}}
\newcommand\HMapgeneric[2]{(\ma{\HMapgenericliteral #1\ #2})}
\newcommand\HMapc[1]{(\ma{\HMapcliteral #1})}
\newcommand\HMapcwithabsent[2]{(\ma{\HMapcliteral #1\ #2})}
\newcommand\HMapp[2]{(\ma{\HMappliteral #1\ #2})}
\newcommand\mandatoryset[1]{\ma{\{#1\}}}
\newcommand\mandatorysetoverright[2]{\ma{\{\overrightarrow{(#1,\ #2)}\}}}
\newcommand\notinmandatory[3]{\ma{(#1\ #2)} \not\in {#3}}
\newcommand\inmandatory[3]{\ma{(#1\ #2)} \in {#3}}
\newcommand\extendmandatoryset[3]{(#1, (#2\ #3))}
\newmeta\mandatory{p}
\newmeta\absent{a}
\newcommand\absentoverright[1]{\ma{\{{\overrightarrow{#1}}\}}}
\newcommand\inabsent[2]{\ma{#1 \in #2}}
\newcommand\notinabsent[2]{\ma{#1 \not\in #2}}
\newcommand\extendabsentset[2]{(#1, #2)}
\newbfop\Satisfiesliteral{Satisfies}
\newcommand\Satisfies[1]{(\ma{\Satisfiesliteral\ #1})}
\newbfop\Instanceliteral{InstanceOf}
\newcommand\Instance[1]{(\ma{\Instanceliteral\ #1})}
\newcommand\HVec[1]{[{#1}]}
\newcommand\makekw[1]{\ma{\metafunctionfont{\mathbin{:}#1}}}

% terms
\newmeta\x{x}                   % not sure if \x is reserved...
\newmeta\xp{x{'}}                   % not sure if \x is reserved...
\newmeta\y{y}
\newmeta\z{z}
\newmeta\v{v}
\newmeta\vp{v'}
\newmeta\class{C}
\newmeta\classp{C{'}}
\newmeta\protocol{P}
\newmeta\k{k}
\newmeta\num{n}
\newmeta\bool{b}
\newcommand\operatorfont[1]{\ma{{\mathsf{#1}}}}
\newcommand\literalfont[1]{\ma{{\mathsf{#1}}}}
\newcommand\nil[0]{{\literalfont{nil}}}
\newcommand\true[0]{{\literalfont{true}}}
\newcommand\false[0]{{\literalfont{false}}}
\newcommand\assocliteral[0]{{\operatorfont{assoc}}}
\newcommand\assocexp[3]{(\assocliteral{}\ #1\ #2\ #3)}
\newmeta\dissoc{dissoc}
\newmeta\getliteral{{\operatorfont{get}}}
\newcommand\getexp[2]{(\getliteral{}\ #1\ #2)}
\newcommand\ifliteral[0]{{\operatorfont{if}}}
\newcommand\doliteral[0]{{\operatorfont{do}}}
\newcommand\letliteral[0]{{\operatorfont{let}}}
\newcommand\throwliteral[0]{{\operatorfont{throw}}}
\newcommand\newliteral[0]{{\operatorfont{new}}}
\newcommand\defmultiliteral[0]{{\operatorfont{defmulti}}}
\newcommand\defmethodliteral[0]{{\operatorfont{defmethod}}}
\newcommand\abs[3]{\ma{\l #1^{#2} . #3}}
\newcommand\absoverright[3]{\ma{\l \overrightarrow{#1^{#2}} . #3}}
\newcommand\curlymap[1]{\ma{\{#1\}}}
\newcommand\emptymap[1]{\ma{\{\}}}
\newcommand\roundpair[2]{\ma{(#1, #2)}}
\newcommand\curlymapvaloverright[2]{\ma{\{{\overrightarrow{\roundpair{#1}{#2}}}\}}}
\newcommand\extendmap[3]{\ma{#1[#2 \mapsto #3]}}
\newcommand\getmap[2]{\ma{#1[#2]}}
\newcommand\keyinmap[2]{\ma{{#1} \in dom({#2})}}
\newcommand\keynotinmap[2]{\ma{{#1} \not\in dom({#2})}}
\newcommand\comb[2]{\ma{(#1\ #2)}}
\newcommand\ifexp[3]{\ma{(\ifliteral{}\ #1\ #2\ #3)}}
\newcommand\doexp[2]{\ma{(\doliteral{}\ #1\ #2)}}
\newcommand\letexp[3]{\ma{(\letliteral{}\ [\ma{#1\ #2}]\ #3)}}
\newcommand\appexp[2]{\ma{(#1\ #2)}}
\newcommand\throwexp[1]{\ma{(\throwliteral{}\ #1)}}
\newcommand\newexp[2]{\ma{(\newliteral{}\ #1\ #2)}}
% deleted 2nd argument which is just the same as #3
\newcommand\newstaticexp[4]{\ma{({\newliteral}_{[#1]}\ #3\ #4)}}
\newcommand\dotliteral[0]{{\operatorfont{.}}}
\newcommand\fieldexp[2]{\ma{(\dotliteral\ #2\ #1)}}
\newcommand\fieldstaticexp[4]{\ma{(\dotliteral\ #4\ {#3}^{#1}_{#2})}}
\newcommand\methodexp[3]{\ma{(\dotliteral\ #2\ (#1\ #3))}}
\newcommand\methodstaticexp[6]{\ma{(\dotliteral\ #5\ ({#4}^{#1}_{[[#2], #3]}\ #6))}}
\newcommand\createmultiexp[2]{\ma{(\defmultiliteral{}\ #1\ #2)}}
\newcommand\defmultiexp[2]{(\ma{\defmultiliteral{}\ #1\ #2})}
\newcommand\defmethodexp[4]{(\ma{\defmethodliteral{}\ #1\ #2\ [#3]\ #4})}
\newcommand\extendmultiexp[3]{(\ma{\defmethodliteral{}\ #1\ #2\ #3})}
\newmeta\defliteral{\textbf{def}}
\newcommand\defexp[2]{(\ma{\defliteral{}\ #1\ #2})}
\newcommand\wrong[0]{\ma{wrong}}
\newcommand\errorval[1]{\ma{\metafunctionfont{err}}}
\newcommand\errorvalv[0]{\errorval{\v{}}}
\newcommand\reflerror[0]{\errorval{refl}}
\newcommand\mmerror[0]{\errorval{mm}}
\newcommand\rtvector[1]{[{#1}]}

% Java primitives
\newmeta\pint{int}
\newbfop\Integer{java.lang.Integer}
\newmeta\plong{long}
\newbfop\Long{java.lang.Long}
\newmeta\pdouble{double}
\newbfop\Double{java.lang.Double}
\newmeta\pchar{char}
\newbfop\Character{java.lang.Character}
\newmeta\pvoid{void}
\newbfop\Void{Void}
\newbfop\File{File}
\newbfop\String{String}
\newmeta\mth{mth}
\newmeta\fld{fld}

% Clojure values
\newmeta\symbol{symbol}
\newmeta\nat{nat}

% constant calls
\newbfop\ccclass{class}
\newcommand\instanceliteral[0]{\operatorfont{instance?}}
\newcommand\isaliteral[0]{{\operatorfont{isa?}}}
\newcommand\instanceapp[2]{{(\instanceliteral\ #1\ #2)}}
\newcommand\isaapp[2]{(\isaliteral\ #1\ #2)}

% constant typing
\newcommand\constanttypetwo[2]{\ma{{\delta}_{#1}(#2)}}
\newcommand\constanttype[1]{\constanttypetwo{\t{}}{#1}}
\newcommand\constantopsem[2]{\ma{{\delta}(#1, #2)}}
\newcommand\classconst[0]{\emph{class}}
\newcommand\throwconst[0]{\emph{throw}}

% differences from TR
\newcommand\trdiff[1]{\mathbin{\textcolor{blue}{#1}}}

% update function
\newcommand\metafunctionfont[1]{{\mathsf{#1}}}
\newcommand\updateliteral[0]{\ma{\metafunctionfont{update}}}
\newcommand\update[3]{\updateliteral({#1}, {#2}, {#3})}
\newcommand\restrictliteral[0]{\ma{\metafunctionfont{restrict}}}
\newcommand\restrict[2]{\restrictliteral(#1, #2)}
\newcommand\removeliteral[0]{\ma{\metafunctionfont{remove}}}
\newcommand\remove[2]{\removeliteral(#1, #2)}
\newcommand\emptypath[0]{\ma{\epsilon}}

% class table
\newcommand\ct[0]{\ma{\mathcal{CT}}}
\newmeta\ctentrymeta{ce}
\newmeta\ctmethod{m}
\newmeta\ctfield{f}
\newmeta\ctctor{c}
\newcommand\ctmethodsliteral[0]{\metafunctionfont{methods}}
\newcommand\ctfieldsliteral[0]{\metafunctionfont{fields}}
\newcommand\ctconstructorsliteral[0]{\metafunctionfont{constructors}}
\newcommand\ctmthentry[3]{\ma{[#1, [#2], #3]}}
\newcommand\ctfldentry[2]{\ma{[#1, #2]}}
\newcommand\ctctorentry[1]{\ma{[#1]}}
\newcommand\set[1]{\ma{\{#1\}}}
\newcommand\ctentry[0]{\{ \ctmethodsliteral \mapsto 
  \set{\overrightarrow{\ctmthentry{\mth{}}{\overrightarrow{\classhint{}}}{\classhint{}}}}, \ 
  \ctfieldsliteral \mapsto \{\overrightarrow{\ctfldentry{\fld{}}{\classhint{}}} \}, \ 
  \ctconstructorsliteral \mapsto \{\overrightarrow{\ctctorentry{\overrightarrow{\classhint{}}}} \}
                          \}}
\newcommand\ctlookup[2]{\ma{{#1}[#2]}}
\newcommand\ctlookuptwo[3]{\ma{\ctlookup{({\ctlookup{#1}{#2}})}{#3}}}
\newcommand\ctlookupmethods[2]{\ma{\ctlookuptwo{#1}{#2}{\ctmethodsliteral}}}
\newcommand\ctlookupfields[2]{\ma{\ctlookuptwo{#1}{#2}{\ctfieldsliteral}}}
\newcommand\ctlookupctors[2]{\ma{\ctlookuptwo{#1}{#2}{\ctconstructorsliteral}}}

% typing judgements
\newcommand\hastype[2]{\ma{#1 \mathbin{:} #2}}
\newcommand\hastypesmall[2]{\ma{#1 {:} #2}}
\newcommand\issubtype[2]{\ma{#1 \mathbin{<:} #2}}
\newcommand\issubtypein[3]{\ma{{\inpropenv{#1} {#2 \mathbin{<:} #3}}}}
\newcommand\issubobjin[3]{\ma{{\inpropenv{#1} {#2 \mathbin{<:} #3}}}}
\newcommand\notsubtypein[3]{\ma{{\inpropenv{#1} {#2 \mathbin{\not<:} #3}}}}
% 4 place relation (TR formalism)
\newcommand\judgement[4]{\ma{#1 \vdash #2\ ;\ #3\ ;\ #4}}
% 7 place relation (TC formalism)
\newcommand\judgementsev[7]{\ma{#3 \vdash #4\ ;\ #5\ ;\ #6}}
%\newcommand\judgementsev[7]{\ma{#3 \vdash_{\scriptscriptstyle{\trdiff{\ct{}}}} #4\ ;\ #5\ ;\ #6}}
% 7 place relation with color
\newcommand\judgementsevcol[7]{\judgementsev {\trdiff{#1}} {\trdiff{#2}} {#3} {#4} {#5} {#6} {\trdiff #7}}
% expands to 7 place but with 4 args (the TR formalism)
\newcommand\judgementfillcol[4]{\judgementsevcol {\mmenv} {\taenv} {#1} {#2} {#3} {#4} {\mmenv}}
% expects everything except mmenv
\newcommand\judgementfillmmcol[5]{\judgementsevcol {\mmenv} {#1} {#2} {#3} {#4} {#5} {\mmenv}}
% lookuping props in the env
% 2 place relation (same as tt | tt; empty)
\newcommand\judgementtwo[2]{\ma{#1 \vdash #2}}
\newcommand\inpropenv[2]{\ma{#1 \vdash #2}}

% operational semantics
\newmeta\openv{\rho}
\newmeta\openvp{\rho'}
\newcommand\inopenvnoeq[2]{\ma{#1 (#2)}}
\newcommand\inopenv[3]{\ma{#1 (#2) = #3}}
\newcommand\notinopenv[2]{\ma{#2 \not\in dom(#1)}}
\newcommand\extendopenv[3]{\ma{#1[#2 \mapsto #3]}}
\newcommand\opsem[3]{\ma{#1 \vdash #2 \Downarrow #3}}
\newcommand\notopsem[3]{\ma{#1 \not\vdash #2 \Downarrow #3}}
\newcommand\closuresuffixliteral[0]{\metafunctionfont{c}}
\newcommand\closure[2]{\ma{[#1, #2]_{\closuresuffixliteral}}}
% multimethod semantics
\newcommand\multisuffixliteral[0]{\metafunctionfont{m}}
\newcommand\multi[2]{\ma{[#1, #2]_{\multisuffixliteral}}}
\newcommand\emptydisptable[0]{\{\}}
\newmeta\disptable{t}
\newmeta\disptablep{t'}
\newmeta\mapval{m}
\newcommand\extenddisptable[3]{\ma{#1[#2 \mapsto #3]}}
\newcommand\getmethodliteral[0]{\ma{\metafunctionfont{GM}}}
\newcommand\getmethoderr[3]{\getmethodliteral(#1, #2) = #3}
\newcommand\getmethod[4]{\getmethodliteral(#1, #2) = #4}

% java reflection rewrite 
\newcommand\rewrite[3]{\ma{#1\ \vdash^{\ct{}}_{\metafunctionfont{r}} #2 \Rightarrow #3}}

% tools.analyzer judgements
\newcommand\ta[0]{\mathcal{TA}}
\newcommand\intaenv[3]{\ma{#1 (#2) = #3}}
\newcommand\tajudgement[2]{\ma{#1 \vdash_{\metafunctionfont{h}} #2}}

% type hints
\newmeta\tatypeunknown{\ma{\gamma^{?}}}
\newmeta\tatype{\ma{\gamma}}
\newmeta\tatypep{\ma{\gamma'}}
\newmeta\classhint{C}
\newmeta\primitivehint{p}
\newmeta\unknownhint{\mathbbm{?}}
\newcommand\hinted[2]{\ma{\ \widehat{}\ #1\ #2}}

% convert tools.analyzer types to core.typed types
\newcommand\tatotc[2]{\ma{[[#1]]\ =\ #2}}

% environment
\newcommand\propenv{\ma{\Gamma}}
\newcommand\propenvp{\ma{\Gamma'}}
\newcommand\propenvc{\ma{\Gamma_c}}
\newcommand\mmenv{\Delta}
\newcommand\mmenvp{\mmenv'}
\newcommand\mmenvpp{\mmenvp'}
\newcommand\taenv{\ma{\Sigma}}
\newcommand\taenvp{\taenv'}

% multimethod envs
\newcommand\adddispatchfn[2]{\ma{add\_dispatch\_fn(#1,\ #2)}}
\newcommand\getdispatchfn[2]{\ma{get\_dispatch\_fn(#1)_{#2}}}
\newcommand\inmmenv[3]{\ma{#1 (#2) = #3}}

\newcommand\metafnfont[1]{{\metafunctionfont{#1}}}

% isa? special functions
\newcommand\isacompareliteral[0]{\ma{\metafnfont{IsAProps}}}
\newcommand\isacomparetwo[2]{\ma{\isacompareliteral(#1, #2)}}
\newcommand\isacomparethree[3]{\ma{\isacompareliteral(#2, #3)}} % delete 1st argument, unusued outside of vectors
\newcommand\isacompare[4]{\ma{\isacomparethree{#1}{#2}{#3} = {#4}}}
\newcommand\isacomparealign[4]{\ma{\isacomparethree{#1}{#2}{#3} &=& {#4}}}
\newcommand\isaopsemliteral[0]{\ma{\metafnfont{IsA}}}
\newcommand\isaopsem[2]{\ma{\isaopsemliteral(#1, #2)}}

% new special functions
% Type -> [Type]
\newcommand\ctorparamsliteral[0]{\metafnfont{Constructor}}
\newcommand\ctorparamsnoeq[3]{\ma{\ctorparamsliteral(#1, #2, [#3])}}
\newcommand\ctorparams[4]{\ma{\ctorparamsnoeq{#1}{#2}{#3} = [#4]}}
\newcommand\ctorparamsalign[4]{\ma{\ctorparamsnoeq{#1}{#2}{#3} &=& [#4]}}

% field special functions
% Type Field -> Type
\newcommand\fieldtypeliteral[0]{\ma{\metafnfont{Field}}}
\newcommand\fieldtypenoeq[3]{\ma{\fieldtypeliteral(#1, #2, #3)}}
\newcommand\fieldtype[5]{\ma{\fieldtypenoeq{#1}{#2}{#3} = [#4, #5]}}
\newcommand\fieldtypealign[5]{\ma{\fieldtypenoeq{#1}{#2}{#3} &=& [#4, #5]}}

% method special functions
% Type [Type] Method -> [Type]
\newcommand\methodtypeliteral[0]{\metafnfont{Method}}
\newcommand\methodtypenoeq[4]{\ma{\methodtypeliteral(#1, #2, #3, [#4])}}
\newcommand\methodtype[7]{\ma{\methodtypenoeq{#1}{#2}{#3}{#4} = [#5, [#6], #7]}}
\newcommand\methodtypealign[7]{\ma{\methodtypenoeq{#1}{#2}{#3}{#4} &=& [#5, [#6], #7]}}

% java subtyping
\newcommand\assignable[2]{\ma{assignable(#1, #2)}}

% evaluation contexts
\newmeta\E{E}


% propositions
\newmeta\prop{\psi}
\newmeta\propp{\psi'}
\newmeta\proppp{\psi''}
\newmeta\propisnotmeta{\nu}
\newcommand\isprop[2]{\ma{{#1}_{#2}}}
\newcommand\impprop[2]{\ma{#1 \supset #2}}
\newcommand\nottype[1]{\ma{\overline{#1}}}
\newcommand\notprop[2]{\ma{{\nottype{#1}}_{#2}}}
\newcommand\andprop[2]{\ma{#1 \wedge #2}}
\newcommand\orprop[2]{\ma{#1 \vee #2}}
\newmeta\topprop{\mathbbm{tt}}
\newmeta\botprop{\mathbbm{ff}}
\newcommand\filterset[2]{\ma{#1 | #2}}
\newcommand\filtersetparen[2]{\ma{(\filterset{#1}{#2})}}
\newcommand\thenprop[1]{\ma{{#1}_+}}
\newcommand\elseprop[1]{\ma{{#1}_-}}

% polarities
\newmeta\polaritymeta{pol}
\newcommand\withpolarity[2]{\ma{{#1}^{#2}}}
\newcommand\pluspolarityliteral[0]{\metafunctionfont{pos}}
\newcommand\minuspolarityliteral[0]{\metafunctionfont{neg}}
\newcommand\pluspolarity[1]{\withpolarity{#1}{\pluspolarityliteral}}
\newcommand\minuspolarity[1]{\withpolarity{#1}{\minuspolarityliteral}}

\newcommand\notequal[0]{\ma{\not=}}

% objects
\newcommand\path[2]{\ma{#1(#2)}}
\newmeta\object{o}
\newmeta\objectp{o'}
\newmeta\emptyobject{\emptyset}
\newmeta\pathelem{\pi}
\newmeta\pathelemp{\pi'}
% abstract syntax for pathelem
\newmeta\pesyntax{pe}
\newmeta\classpe{\ma{\textbf{class}}}
\newcommand\keype[1]{\ma{\textbf{key}_{\ma{#1}}}}

\newcommand\destructpath[2]{\ma{#1 :: #2}}

% scope replacements
\newcommand\replacefor[3]{\ma{#1 [#2 / #3]}}

% Java type conversion functions
\newcommand\javatotcliteral[0]{\ma{\metafnfont{Convert}}}
\newcommand\javatotcnilliteral[0]{\ma{\javatotcliteral_{\nil{}}}}
\newcommand\javatotc[2]{\javatotcliteral\ma{(#1)}\ =\ #2}
\newcommand\javatotcnil[2]{\ma{\javatotcnilliteral\ma{(#1)}\ =\ #2}}
\newcommand\javatotcalign[2]{\javatotcliteral\ma{(#1)}\ &=&\ #2}
\newcommand\javatotcalignnil[2]{\javatotcliteral_{\nil{}}\ma{(#1)}\ &=&\ #2}

% # Runtime semantics
% ## Runtime class syntax
\newmeta\classvaluemeta{I}
\newcommand\classfieldpair[2]{#1 : #2}
\newcommand\classvalue[2]{\ma{#1\ \{#2\}}}

% ## metafunction to invoke java
% Class Target Method ArgTypes Args ReturnType ReturnValue
\newcommand\JVMliteral[0]{\ma{\metafunctionfont{JVM}}}
\newcommand\invokejavamethodliteral[0]{\ma{\JVMliteral_{\metafunctionfont{invokestatic}}}}
\newcommand\invokejavamethodnoeq[6]{\ma{\invokejavamethodliteral[#1, #2, #3, [#4], [#5], #6]}}
\newcommand\invokejavamethod[7]{\ma{\invokejavamethodnoeq{#1}{#2}{#3}{#4}{#5}{#6} = #7}} % Class Args ReturnValue
% Class ArgTypes Args ReturnValue
\newcommand\newjavaliteral[0]{\ma{\JVMliteral_{\metafunctionfont{new}}}}
\newcommand\newjavanoeq[3]{\ma{\newjavaliteral[#1, [#2], [#3]]}}
\newcommand\newjava[4]{\ma{\newjavanoeq{#1}{#2}{#3} = #4}}
% Class Target Field FieldType ReturnValue
\newcommand\getfieldliteral[0]{\ma{\JVMliteral_{\metafunctionfont{getstatic}}}}
\newcommand\getfieldjavanoeq[4]{\ma{\getfieldliteral[#1, #2, #3, #4]}}
\newcommand\getfieldjava[5]{\ma{\getfieldjavanoeq{#1}{#2}{#3}{#4} = #5}}
% Class Target Bool
\newcommand\instanceofjava[3]{\ma{JVM_{instanceof}[#1, #2] = #3}}

\newcommand\satisfies[2]{\ma{{#1} \models {#2}}}

\newmeta\wrongorerror{\beta}

\newcommand\consistentwith[2]{\ma{{#1}\ \text{is consistent with}\ {#2}}}
\newcommand\isconsistent[1]{\ma{{#1}\ \text{is consistent}}}
\newcommand\fv[1]{\ma{{\metafunctionfont{fv}}(#1)}}

\newcommand\istrueval[1]{\ma{\metafunctionfont{TrueVal}(#1)}}
\newcommand\isfalseval[1]{\ma{\metafunctionfont{FalseVal}(#1)}}

\newmeta\definedreduction{\alpha}

% Common typing rules
\newcommand\TLocal[0]{
\infer [T-Local]
{ \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}
  \\
  \s{} = {\falsydiff} }
{ \judgementfillcol {\propenv{}} 
                    {\hastype {\x{}} {\t{}}}
                    {\filterset {{\notprop {\s{}} {\x{}}}} {{\isprop {\s{}} {\x{}}}}}
                    {\x{}}
                   }
                 }

\newcommand\TTrue[0]{
\infer [T-True]
{}
{ \judgementfillcol {\propenv{}}
      {{\hastype {\true{}} {\True{}}}}
      {{\filterset {\topprop{}} {\botprop{}}}}
      {\emptyobject{}}
    }
  }

\newcommand\TFalse[0]{
\infer [T-False]
{}
{ \judgementfillcol {\propenv{}}
      {{\hastype {\false{}} {\False{}}}}
      {\filterset {\botprop{}} {\topprop{}}}
    {\emptyobject{}}
   }
 }

\newcommand\TNil[0]{
\infer [T-Nil]
{}
{ \judgementfillcol {\propenv{}} 
      {{\hastype {\nil{}} {\Nil{}}}} 
      {\filterset {\trdiff{\botprop{}}} {\topprop{}}}
      {\emptyobject{}} 
    }
  }

\newcommand\TDo[0]{
\infer [T-Do]
{ 
  \judgement {\propenv{}} 
             {\hastype {\e1} {\t1}} 
             {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop1}}} 
             {\object{1}}
\\\\
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\hastype {\e{}} {\t{}}} 
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}}
  }
{ \judgement
    {\propenv{}} 
    {\hastype {\doexp {\e1} {\e{}}} {\t{}}} 
    {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} {\object{}} 
             }
           }

\newcommand\TIf[0]{
\infer [T-If]
{ \judgement {\propenv{}} {\hastype {\e1} {\t{1}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
                 {\object{1}} 
             \\\\
  \judgement {\propenv{}, {\thenprop {\prop{1}}}}
                 {\hastype {\e2} {\t{}}} {\filterset {\thenprop {\prop{2}}} {\elseprop {\prop{2}}}}
                 {\object{}}
  \\\\
  \judgement {\propenv{}, {\elseprop {\prop{1}}}}
                 {\hastype {\e3} {\t{}}} {\filterset {\thenprop {\prop{3}}} {\elseprop {\prop{3}}}}
                 {\object{}}
             }
{ \judgement {\propenv{}} {\hastype {\ifexp {\e1} {\e2} {\e3}} {\t{}}} 
                 {\filterset {\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}} 
                             {\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}}
                 {\object{}} }

             }

\newcommand\TLet[0]{
\infer [T-Let]
{ \judgement {\propenv{}} {\hastype {\e{1}} {\s{}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
             {\object{1}}
             \\\\
             \propp{} = {\impprop {\notprop {\falsydiff{}} {\x{}}} {\thenprop {\prop{1}}}}
             \\\\
             \proppp{} = {\impprop {\isprop {\falsydiff{}} {\x{}}} {\elseprop {\prop{1}}}}
  \\\\
  \judgement
       {\propenv{}, {\isprop {\s{}} {\x{}}},
         {\propp{}},
         {\proppp{}}}
             {\hastype {\e{}} {\t{}}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\object{}} 
             }
{ \judgement {\propenv{}} {\hastype {\letexp {\x{}} {\e{1}} {\e{}}} {\t{}}}
             {\replacefor {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
                          {\object{1}}
                          {\x{}}}
             {\replacefor {\object{}} 
                          {\object{1}}
                          {\x{}}}
             }

           }

\newcommand\TApp[0]{
\infer [T-App]
{ \judgement {\propenv{}} {\hastype {\e{}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}}
                {\filterset {\thenprop {\prop{}}}
                            {\elseprop {\prop{}}}}
                {\object{}}
  \\\\
  \judgement {\propenv{}}
                 {\hastype {\ep{}} {\s{}}}
                 {\filterset {\thenprop {\propp{}}}
                             {\elseprop {\propp{}}}}
                 {\objectp{}} 
}
{ \judgementfillcol {\propenv{}} {\hastype {\appexp {\e{}} {\ep{}}}
                                        {\replacefor {\t{}}
                                                     {\objectp{}}
                                                     {\x{}}}}
                 {\replacefor {\filterset {\thenprop {\prop{f}}}
                                          {\elseprop {\prop{f}}}}
                              {\objectp{}}
                              {\x{}}}
                 {\replacefor {\object{f}}
                              {\objectp{}}
                              {\x{}}}
}
}

\newcommand\TAbs[0]{
\infer [T-Abs]
{ \judgement {\propenv{}, {\isprop {\s{}} {\x{}}}}
            {\hastype {\e{}} {\t{}}}
             {\filterset {\thenprop {\prop{}}}
                         {\elseprop {\prop{}}}}
             {\object{}}}
{ \judgement {\propenv{}} {\hastype {\abs {\x{}} {\s{}} {\e{}}}
                                           {\ArrowOne {\x{}} {\s{}}
                                                      {\t{}}
                                                      {\filterset {\thenprop {\prop{}}}
                                                                  {\elseprop {\prop{}}}}
                                                      {\object{}}}}
                {\filterset {\topprop{}}
                            {\botprop{}}}
                {\emptyobject{}}}
            }

\newcommand\TSubsume[0]{
\infer [T-Subsume]
{ \judgement {\propenv{}} {\hastype {\e{}} {\t{}}}
             {\filterset {\thenprop {\prop{}}}
                         {\elseprop {\prop{}}}}
             {\object}
\\\\
\inpropenv {\propenv{}, {\thenprop {\prop{}}}} {\thenprop {\propp{}}}
\\
\inpropenv {\propenv{}, {\elseprop {\prop{}}}} {\elseprop {\propp{}}}
\\\\
\inpropenv {} {\issubtype {\t{}} {\tp{}}}
\\
\inpropenv {} {\issubtype {\object{}} {\objectp{}}}
}
{ \judgement {\propenv{}} {\hastype {\e{}} {\tp{}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
             {\objectp{}}}
         }

\newcommand\TNewStatic[0]{
\infer [T-NewStatic]
{ 
  \overrightarrow{
\javatotc {\classhint{i}}
          {\t{i}}
          }
  \\
  \javatotc {\classhint{}}
            {\t{}}
  \\\\
  \overrightarrow{
  \judgementtwo {\propenv{}}
                    {\hastype {\e{i}} {\t{i}}}
                  }
           }
{ \judgementfillcol {\propenv{}} {\hastype {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                                                          {\class{}} {\overrightarrow{\e{i}}}} {\t{}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject}
             }
         }

\newcommand\TFieldStatic[0]{
\infer [T-FieldStatic]
{ \javatotc {\classhint{1}} {\s{}}
             \\
  \javatotcnil {\classhint{2}} {\t{}}
  \\\\
  \judgementtwo {\propenv{}} {\hastype {\e{}} {\s{}}}
           }
{ \judgement {\propenv{}} {\hastype {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{}}} {\t{}}}
             {\filterset {\topprop{}} {\topprop}}
             {\emptyobject{}}}
         }

\newcommand\TMethodStatic[0]{
\infer [T-MethodStatic]
{ 
  \overrightarrow{\javatotc {\classhint{i}} {\t{i}}}
             \\
             \javatotc {\classhint{1}} {\s{}}
             \\\\
             \javatotcnil {\classhint{2}} {\t{}}
             \\
  \judgementtwo {\propenv{}} {\hastype {\e{}} {\s{}}}
             \\
             \overrightarrow{
  \judgementtwo {\propenv{}} {\hastype {\e{i}} {\t{i}}}
                  }
           }
{ \judgementfillcol {\propenv{}} {\hastype {\methodstaticexp {\classhint{1}} 
                                                            {\overrightarrow {\classhint{i}}} 
                                                            {\classhint{2}}
                                                            {\mth{}} {\e{}} {\overrightarrow{\e{i}}}}
                                    {\t{}}}
             {\filterset {\topprop{}} {\topprop{}}}
             {\emptyobject{}}}
         }

\newcommand\TClass[0]{
\infer [T-Class]
{}
{ \judgement {\propenv{}} {\hastype{\class{}}{\ValueClass}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}}
         }

\newcommand\TDefMulti[0]{
\infer [T-DefMulti]
{ \s{} = {\ArrowOne {\x{}} {\t{}} {\tp{}}
                          {\filterset {\thenprop {\prop{}}}
                                      {\elseprop {\prop{}}}}
                          {\object{}}}
                          \\
  \sp{} = {\ArrowOne {\x{}} {\t{}} {\tpp{}}
                          {\filterset {\thenprop {\propp{}}}
                                      {\elseprop {\propp{}}}}
                          {\objectp{}}}
                \\
\judgementtwo {\propenv{}} {\hastype {\e{}} {\sp{}}}
}
{
  \judgement {\propenv{}}  
      {\hastype {\createmultiexp {\s{}}
                                 {\e{}}} 
                {\MultiFntype {\s{}} {\sp{}}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject{}}
}
}

\newcommand\TDefMethod[0]{
\infer [T-DefMethod]
{
  \t{m} = {\ArrowOne {\x{}} {\t{}} {\s{}}
                                    {\filterset {\thenprop {\prop{}}}
                                                {\elseprop {\prop{}}}}
                                    {\object{}}}
\\
\t{d} = {\ArrowOne {\x{}} {\t{}} {\sp{}}
                   {\filterset {\thenprop {\propp{}}}
                               {\elseprop {\propp{}}}}
                   {\objectp{}}}
             \\\\
\judgementtwo {\propenv{}}
                  {\hastype {\e{m}} {\MultiFntype {\t{m}} {\t{d}}}}
\\
  \isacompare{\sp{}}{\objectp{}}{\t{v}}{\filterset {\thenprop {\proppp{}}} {\elseprop {\proppp{}}}}
\\\\
\judgementtwo {\propenv{}}
           {\hastype {\e{v}} {\t{v}}}
           \\
\judgement {\propenv{}, {\isprop{\t{}} {\x{}}}, {\thenprop {\proppp{}}}}
           {\hastype {\e{b}} {\s{}}}
           {\filterset {\thenprop {\prop{}}}
                       {\elseprop {\prop{}}}}
           {\object{}}
}
{ \judgementfillcol {\propenv{}} {\hastype {\extendmultiexp {\e{m}} {\e{v}} 
                                                            {\abs {\x{}} {\t{}} {\e{b}}}}
                                           {\MultiFntype {\t{m}} {\t{d}}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject{}}
}
}

\newcommand\TIsA[0]{
\infer [T-IsA]
{
  \judgement {\propenv{}} {\hastype {\e{}} {\s{}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
                       {\object{}}
  \\\\
  \judgementtwo {\propenv{}} {\hastype {\ep{}} {\t{}}}
             \\\\
  \isacompare{\s{}}{\object{}}{\t{}}{\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
}
{ \judgement {\propenv{}} {\hastype {\isaapp {\e{}} {\ep{}}}
                                    {\Boolean{}}}
             {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\emptyobject}}
         }

\newcommand\TAssoc[0]{
\infer [T-AssocHMap]
{ 
  \judgementtwo {\propenv{}} {\hastype {\e{}} {\HMapgeneric {\mandatory{}} {\absent}}}
  \\
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value{\k{}}}}
  \\
  \judgementtwo {\propenv{}} {\hastype {\e{v}} {\t{}}}
  \\
  {\k{}} \not\in {\absent{}}
}
{ \judgement {\propenv{}} 
             {\hastype {\assocexp {\e{}} {\e{k}} {\e{v}}}
                       {\HMapgeneric {\extendmandatoryset {\mandatory{}}{\k{}}{\t{}}} {\absent}}}
             {\filterset {\topprop{}} {\botprop{}}}
             {\emptyobject{}}
}
         }

\newcommand\TGetHMap[0]{
\infer [T-GetHMap]
{ \judgementtwo {\propenv{}} 
  {\hastype {\e{}} {\Unionsplice {{\overrightarrow {\HMapgeneric {\mandatory{}} {\absent{}}}}^i}}}
           \\
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}}
             \\
             {\overrightarrow{\inmandatory{\k{}}{\t{}}{\mandatory{}}}}^i
       }
{ \judgement {\propenv{}} {\hastype {\getexp {\e{}} {\e{k}}} {\Unionsplice {{\overrightarrow {\t{}}}^i}}}
             {\filterset {\topprop{}} {\topprop{}}}
             {\replacefor {\path {\keype{k}} {\x{}}}
                          {\object{}}
                          {\x{}}}
                                  }
                                }

\newcommand\TGetAbsent[0]{
\infer [T-GetHMapAbsent]
{ \judgementtwo {\propenv{}} {\hastype {\e{}} {\HMapgeneric {\mandatory{}} {\absent}}}
         \\
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}}
             \\
             {\inabsent{\k{}}{\absent{}}}
       }
{ \judgement {\propenv{}} {\hastype {\getexp {\e{}} {\e{k}}}
                                    {\Nil{}}}
             {\filterset {\topprop{}} {\topprop{}}}
             {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{}}
                          {\x{}}}
                        }
                      }

\newcommand\TGetHMapPartialDefault[0]{
\infer [T-GetHMapPartialDefault]
{ \judgementtwo {\propenv{}} {\hastype {\e{}} {\HMapp {\mandatory{}} {\absent}}}
         \\
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}}
             \\
             {\notinmandatory{\k{}}{\t{}}{\mandatory{}}}
             \\
             {\notinabsent{\k{}}{\absent{}}}
       }
{ \judgement {\propenv{}} {\hastype {\getexp {\e{}} {\e{k}}}
                                    {\Top{}}}
             {\filterset {\topprop{}} {\topprop{}}}
             {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{}}
                          {\x{}}}
                        }
}

\newcommand\TKw[0]{
\infer [T-Kw]
{}
{ \judgementfillcol {\propenv{}} 
      {\hastype {\k{}} {\ValueKw}}
      {\filterset {\topprop{}}{\botprop{}}}
      {\emptyobject{}} 
    }
}

\newcommand\TError[0]{
\infer [T-Error]
{}
{ \judgement {\propenv{}} {\hastype {\errorvalv} {\Bot}}
            {\filterset {\botprop{}} {\botprop{}}}
           {\emptyobject{}}}
}

\newcommand\pathelemsyntax[0]{
  \pesyntax{}   &::=& \trdiff{\classpe{}} \alt \trdiff{\keype{\k{}}}
                &\mbox{Path Elements}
}

\newcommand\propenvsyntax[0]{
  \propenv{}   &::=& \overrightarrow{\prop{}}
               &\mbox{Proposition Environment}
             }

% common Syntax
\newcommand\occurrencetypingsyntax[0]{
  \prop{}       &::=& {\isprop {\t{}} {\path {\pathelem{}} {\x{}}}}
                      \alt {\notprop {\t{}} {\path {\pathelem{}} {\x{}}}}
                      \alt {\impprop {\prop{}} {\prop{}}}
                &\mbox{Propositions} \\
                      &\alt& {\andprop {\prop{}} {\prop{}}}
                      \alt {\orprop {\prop{}} {\prop{}}}
                      \alt \topprop{}
                      \alt \botprop{}\\
  \object{}     &::=& {\path {\pathelem{}} {\x{}}}
                      \alt \emptyobject{}
                &\mbox{Objects} \\
  \pathelem{}   &::=& \overrightarrow{\pesyntax{}}
                &\mbox{Paths} \\
              }

\newcommand\classliteralallsyntax[0]{
   \class{}      &::=& \Object{}
                      \alt \Keyword{}
                      %\alt \Number{}
                      \alt \Class{}
                      \alt \Boolean{}
                      %\alt \File{}
                      %\alt \String{}
                      \alt \IFn{}
                      \alt \PMulti{}
                      \alt \HMapInstance{}
                      \alt \Void{}
                &\mbox{Class literals}
              }

\newcommand\singletonallsyntax[0]{
  \singletonmeta{}     &::=& \k{} 
                             \alt {\trdiff{\class{}}}
                             \alt {\trdiff{\nil}}
                             \alt \bool{}
                &\mbox{Value types}\\
  \bool{}              &::=& 
                             {\true} \alt {\false}
                &\mbox{Boolean values}
              }

% common operational semantics

\newcommand\BLocal[0]{
\infer [B-Local]
{ \inopenv {\openv{}} {\x{}} {\v{}} }
{ \opsem {\openv{}} {\x{}} {\v{}} }
}

\newcommand\BDo[0]{
\infer [B-Do]
{ \opsem {\openv{}} {\e{1}} {\v{1}} 
  \\\\
  \opsem {\openv{}} {\e{}} {\v{}} 
}
{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\v{}} }
}


\newcommand\BLet[0]{
\infer [B-Let]
{ \opsem {\openv{}} {\e{a}} {\v{a}}
  \\\\
  \opsem {\extendopenv{\openv{}}{\x{}}{\v{a}}}
         {\e{}}
         {\v{}}
 }
{ \opsem {\openv{}} 
         {\letexp {\x{}} {\e{a}} {\e{}}}
         {\v{}}}
     }


\newcommand\BVal[0]{
\infer [B-Val]
{}
{ \opsem {\openv{}} {\v{}} {\v{}}}
}

\newcommand\BIfTrue[0]{
\infer [B-IfTrue]
{ \opsem {\openv{}} {\e{1}} {\v{1}}
  \\\\
  {\v{1}} \not= {\false{}}
  \\
  {\trdiff{{\v{1}} \not= {\nil{}}}}
  \\\\
  \opsem {\openv{}} {\e{2}} {\v{}}
}
{ \opsem {\openv{}}
         {\ifexp {\e1} {\e2} {\e3}}
         {\v{}}
       }
     }

\newcommand\BIfFalse[0]{
\infer [B-IfFalse]
{  \opsem {\openv{}} {\e{1}} {\false{}}
  \ \ \trdiff{\text{or}\ \ 
  {\opsem {\openv{}} {\e{1}} {\nil{}}}}
  \\\\
  \opsem {\openv{}} {\e{3}} {\v{}}
}
{ \opsem {\openv{}}
         {\ifexp {\e1} {\e2} {\e3}}
         {\v{}}
       }
     }

\newcommand\BAbs[0]{
\infer [B-Abs]
{}
{ \opsem {\openv{}}
         {\abs {\x{}} {\t{}} {\e{}}}
         {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}}
     }

\newcommand\BIsA[0]{
\infer [B-IsA]
{ \opsem {\openv{}} {\e{1}} {\v{1}}
  \\\\
  \opsem {\openv{}} {\e{2}} {\v{2}}
  \\\\
  \isaopsem{\v{1}}{\v{2}} = {\v{}}
}
{\opsem {\openv{}} {\isaapp {\e{1}} {\e{2}}} {\v{}}}
}

\newcommand\BBetaClosure[0]{
\infer [B-BetaClosure]
{ \opsem {\openv{}}
         {\e{f}}
         {\closure {\openv{c}} {\abs {\x{}} {\t{}} {\e{b}}}}
         \\\\
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
         \\\\
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{a}}}
         {\e{b}}
         {\v{}}
       }
{ \opsem {\openv{}}
         {\appexp {\e{f}} {\e{a}}}
         {\v{}}
       }
     }

\newcommand\BBetaMulti[0]{
\infer [B-BetaMulti]
{ \opsem {\openv{}}
         {\e{}}
         {\multi {\v{d}} {\disptable{}}}
         \\\\
  \opsem {\openv{}}
         {\ep{}}
         {\vp{}}
         \\\\
  \opsem {\openv{}}
         {\appexp {\v{d}} {\vp{}}}
         {\v{e}}
         \\\\
  \getmethod {\disptable{}}
             {\v{e}}
             {\v{k}}
             {\v{f}}
         \\\\
  \opsem {\openv{}}
         {\appexp {\v{f}} {\vp{}}}
         {\v{}}
       }
{ \opsem {\openv{}}
         {\appexp {\e{}} {\ep{}}}
         {\v{}}
       }
     }

     \newcommand\getmethodfigure[0]{
$$
\begin{array}{lr}

  \getmethod {\disptable{}}
             {\v{e}}
             {\v{v}}
             {\v{f}}
             \\
             \ \ \ \ 
             \text{let } {\overrightarrow{\v{fs}}} = 
                \{ (\v{v}, \v{f}) | 
                    {\roundpair{\v{v}}{\v{f}}} \in \disptable{} 
                  \text{ and } 
                \isaopsem{\v{v}}{\v{e}} = {\true{}} \},
                \\
             \ \ \ \ 
             \text{ if } {\overrightarrow{\v{fs}}} = \{{\roundpair{\v{v}}{\v{f}}}\}

             \\
  \getmethoderr {\disptable{}}
             {\v{e}}
             {\mmerror{}} & \text{otherwise}

\end{array}
$$
     }

     \newcommand\BDefMulti[0]{
\infer [B-DefMulti]
{ \opsem {\openv{}} {\e{}} {\v{d}}
  \\\\ 
  \v{} = {\multi {\v{d}} {\emptydisptable}}
}
{\opsem {\openv{}}
        {\createmultiexp {\t{}}
                         {\e{}}}
        {\v{}}
}
     }

     \newcommand\BDefMethod[0]{
\infer [B-DefMethod]
{ \opsem {\openv{}}
         {\e{}}
         {\multi {\v{d}} {\disptable{}}}
         \\\\
  \opsem {\openv{}}
         {\ep{}}
         {\v{v}}
         \\\\
  \opsem {\openv{}}
         {\e{f}}
         {\v{f}}
         \\\\
         \v{} = 
        {\multi {\v{d}} {\extenddisptable {\disptable{}} 
                                {\v{v}}
                                {\v{f}}}}
}
{\opsem {\openv{}}
        {\extendmultiexp {\e{}} {\ep{}} {\e{f}}}
        {\v{}}
      }
     }

\newcommand\BDelta[0]{
\infer [B-Delta]
{ \opsem {\openv{}} {\e{}} {\const{}}
  \\\\
  \opsem {\openv{}} {\ep{}} {\v{}}
  \\\\
  \constantopsem{\const{}}{\v{}} = \vp{}
}
{ \opsem {\openv{}}
         {\appexp {\e{}} {\ep{}}}
         {\vp{}}
       }
     }

\newcommand\BField[0]{
\infer [B-Field]
{ \opsem {\openv{}}
         {\e{}} 
       {\v{1}}
         \\\\
         \getfieldjava{\classhint{1}} {\v{1}} {\fld{}} {\classhint{2}} {\v{}}
       }
{ \opsem {\openv{}}
         {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{}}}
         {\v{}}
   }
}

\newcommand\BMethod[0]{
\infer [B-Method]
{ \opsem {\openv{}}
         {\e{m}}
         {\v{m}}
  \\
  \overrightarrow{
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
       }
  \\\\
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{a}}} {\overrightarrow{\v{a}}}
                    {\classhint{2}}
                    {\v{}}
}
{\opsem {\openv{}}
        {\methodstaticexp {\classhint{1}} {\overrightarrow{\classhint{a}}} {\classhint{2}} {mth} {\e{m}} {\overrightarrow{\e{a}}}}
        {\v{}}
      }
}

\newcommand\BNew[0]{
\infer [B-New]
{ 
  \overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }
         \\\\
         \newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\v{}}
       }
{ \opsem {\openv{}}
         {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{1}} 
                        {\class{}} {\overrightarrow{\e{i}}}}
         {\v{}}}
}

\newcommand\BAssoc[0]{
\infer [B-Assoc]
{\opsem {\openv{}}
        {\e{}} {\mapval{}}
        \\\\
 \opsem {\openv{}} {\e{k}} {\k{}}
        \\\\
 \opsem {\openv{}} {\e{v}} {\v{v}}
 \\\\
 {\v{}} = {\extendmap{\mapval{}}
                {\k{}}{\v{v}}}
}
{
 \opsem {\openv{}}
        {\assocexp {\e{}} {\e{k}} {\e{v}}} 
      {\v{}}
                }
              }


\newcommand\BGet[0]{
\infer [B-Get]
{\opsem {\openv{}}
        {\e{}} {\mapval{}}
        \\\\
 \opsem {\openv{}}
        {\ep{}} {\k{}}
        \\\\
 \keyinmap{\k{}}{\mapval{}}
        \\\\
 \getmap{\mapval{}}
        {\k{}}
        =
        {\v{}}
}
{
 \opsem {\openv{}}
        {\getexp {\e{}} {\ep{}}}
        {\v{}}
}
}

\newcommand\BGetMissing[0]{
\infer [B-GetMissing]
{\opsem {\openv{}}
        {\e{}} {\mapval{}}
        \\\\
 \opsem {\openv{}}
        {\ep{}} {\k{}}
        \\\\
 \keynotinmap{\k{}}{\mapval{}}
}
{
 \opsem {\openv{}}
        {\getexp {\e{}} {\ep{}}}
        {\nil{}}
}
}


% subtyping syntax
\newcommand\standardsubtyping[0]{

  \begin{array}{l}
\infer [SO-Refl]
{}
{ \issubobjin {} {\object{}} {\object{}}}\\\\

\infer [SO-Top]
{}
{ \issubobjin {} {\object{}} {\emptyobject{}}}
  \end{array}

  \begin{array}{l}
\infer [S-Refl]
{}
{ \issubtypein {} {\t{}} {\t{}}}\\\\

\infer [S-Top]
{}
{ \issubtypein {} {\t{}} {\Top{}}}
  \end{array}

\infer [S-UnionSuper]
{ \exists i.\ {\issubtypein {} {\t{}} {\s{i}}}}
{ \issubtypein {} {\t{}} {\Unionsplice{{\overrightarrow{\s{}}}^{i}}}}

% FIXME fix overrightarrow caption
\infer [S-UnionSub]
{ {\overrightarrow {\issubtypein {} {\t{i}} {\s{}}}}^{i}}
{ \issubtypein {} {\Unionsplice{\overrightarrow{\t{}}^{i}}} {\s{}}}

\infer [S-FunMono]
{}
{\issubtypein {}
  {\ArrowOne {\x{}} {\s{}}
             {\t{}}
             {\filterset {\thenprop{\prop{}}}
                         {\elseprop{\prop{}}}}
             {\object{}}}
  {\IFn{}}}

\begin{array}{l}
\infer [S-Object]
{}
{\issubtypein {}
  {\class{}}
  {\Object{}}}\\\\

\infer [S-SClass]
{}
{\issubtypein {}
  {\ValueClass}
  {\Class{}}}
\end{array}

\begin{array}{l}
\infer [S-SBool]
{}
{\issubtypein {}
  {\ValueBool}
  {\Boolean{}}}\\\\

\infer [S-SKw]
{}
{\issubtypein {}
  {\ValueKw}
  {\Keyword}}
\end{array}

\infer [S-Fun]
{ \issubtypein {} {\sp{}} {\s{}}
  \\
  \issubtypein {} {\t{}} {\tp{}}
  \\
  \inpropenv {\thenprop {\prop{}}} {\thenprop {\propp{}}}
  \\
  \inpropenv {\elseprop {\prop{}}} {\elseprop {\propp{}}}
  \\
  \issubobjin{} {\object{}} {\objectp{}}
}
{ \issubtypein {}
    {\ArrowOne {\x{}} {\s{}}
              {\t{}}
              {\filterset {\thenprop {\prop{}}}
                          {\elseprop {\prop{}}}}
              {\object{}}}
    {\ArrowOne {\x{}} {\sp{}}
              {\tp{}}
              {\filterset {\thenprop {\propp{}}}
                          {\elseprop {\propp{}}}}
              {\objectp{}}}}



}

\newcommand\HMapsubtyping[0]{
\infer [S-HMap]
{ \forall i.\ ({\k{i}},\ \s{i}) \in \mandatory{} \text{ and } \issubtypein {} {\s{i{}}} {\t{i{}}}
  \\
  {\absent{1}} \supseteq {\absent{2}}
}
{\issubtypein {} {\HMapgeneric {\mandatory{}} {\absent{1}}}
  {\HMapgeneric {\overrightarrow{(\k{},\ \t{})}^i} {\absent{2}}}
               }

\infer [S-HMapP]
{ \forall i.\ ({\k{i}},\ \s{i}) \in \mandatory{} \text{ and } \issubtypein {} {\s{i{}}} {\t{i{}}}
}
{\issubtypein {} 
  {\HMapc {\mandatory{}}}
  {\HMapp {\overrightarrow{(\k{},\ \t{})}^i} {\absent{}}}
               }

\infer [S-HMapMono]
{}
{\issubtypein {} 
  {\HMapgeneric {\mandatory{}} {\absent{}}}
  {\HMapInstance{}}}
}

\newcommand\Multisubtyping[0]{
\infer [S-PMultiFn]
{ \issubtypein {}
  {\s{t}}
  {\ArrowOne {\x{}} {\s{}} {\t{}}
                                  {\filterset {\thenprop {\prop{}}}
                                              {\elseprop {\prop{}}}}
                                      {\object{}}}
                                      \\\\
  \issubtypein {}
  {\s{d}}
  {\ArrowOne {\x{}} {\s{}} {\tp{}}
                                  {\filterset {\thenprop {\propp{}}}
                                              {\elseprop {\propp{}}}}
                                      {\objectp{}}}
}
{ \issubtypein {} {\MultiFntype{\s{t}}{\s{d}}}
                  {\ArrowOne {\x{}} {\s{}} {\t{}}
                             {\filterset {\thenprop {\prop{}}}
                                         {\elseprop {\prop{}}}}
                             {\object{}}}}
\infer [S-PMulti]
{ \issubtypein {} {\s{}} {\sp{}}
  \\
  \issubtypein {} {\t{}} {\tp{}}}
{ \issubtypein {} {\MultiFntype {\s{}} {\t{}}}{\MultiFntype {\sp{}} {\tp{}}}}

\infer [S-MultiMono]
{}
{\issubtypein {}
  {\MultiFntype {\ArrowOne {\x{}} {\s{}} {\t{}}
                          {\filterset {\thenprop{\prop{}}}
                                      {\elseprop{\prop{}}}}
                          {\object{}}}
                {\ArrowOne {\x{}} {\s{}} {\tp{}}
                          {\filterset {\thenprop{\propp{}}}
                                      {\elseprop{\propp{}}}}
                          {\objectp{}}}
                }
  {\PMulti{}}
}
                       }

% isa? operational semantics

\newcommand\isaopsemfigure[0]{
  \ma{
\begin{array}{lllr}
  \isaopsem{\v{}}{\v{}} &=& {\true{}} & \v{} \notequal {\class{}} \\
  \isaopsem{\class{}}{\classp{}} &=& {\true{}} & \issubtypein{}{\class{}}{\classp{}}\\
  \isaopsem{\v{}}{\vp{}} &=& {\false{}} & \text{otherwise}
\end{array}
  }
}

\newcommand\isapropsfigure[0]{
  \ma{
\begin{array}{lllr}
  \isacomparealign{\s{}}{\path{\classpe{}}{\path{\pathelem{}}{\x{}}}}{\Value{\class{}}}
             {\filterset{\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}
                        {\notprop{\class{}}{\path{\pathelem{}}{\x{}}}}}
                        \\
  \isacomparealign{\s{}}{\object{}}{\Value{\singletonmeta{}}}
             {\replacefor
               {\filtersetparen{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                   {\notprop{\Value{\singletonmeta{}}}{\x{}}}}
                   {\object{}}
                   {\x{}}}\\
                   && \ \text{if}\ {\singletonmeta{}} \not= \class{}
               \\
  \isacomparealign{\s{}}{\object{}}{\t{}}
                  {\filterset{\topprop{}}
                             {\topprop{}}}
\end{array}
  }
}

% multimethod syntax

\newcommand\disptablesyntax[0]{
 \disptable{}   &::=& \{ \overrightarrow{\v{} \mapsto \v{}} \}
               &\mbox{Multimethod dispatch table}
             }
\newcommand\multimethodexpsyntax[0]{
  {\createmultiexp {\t{}} {\e{}}}
                      \alt
                              {\extendmultiexp {\e{}} {\e{}} {\e{}}}
                      \alt {\isaapp {\e{}} {\e{}}}
              }

% HMap syntax auxiliary 
\newcommand\auxhmapsyntax[0]{
  \mandatory{} &::=& \mandatorysetoverright{\k{}}{\t{}}
                &\mbox{HMap mandatory entries} \\
  \absent{} &::=& \absentoverright{\k{}}
                &\mbox{HMap absent entries} \\
  \completenessmeta{} &::=& {\complete{}} \alt {\partial{}}
                &\mbox{HMap completeness}
              }

\newcommand\hmapexpressionsyntax[0]{
                      {\getexp {\e{}} {\e{}}}
                      \alt {\assocexp {\e{}}{\e{}}{\e{}}}
                    }

% reflective Java interop syntax
\newcommand\reflectiveexpsyntax[0]{
                      {\fieldexp {\fld{}} {\e{}}}
                      \alt {\methodexp {\mth{}} {\e{}} {\overrightarrow{\e{}}}}
                      \alt {\newexp {\class{}} {\overrightarrow{\e{}}}}
}

\newcommand\fieldexpsyntax[0]{
                      {\fieldstaticexp {\classhint{}} {\classhint{}} {\fld{}} {\e{}}}
}

\newcommand\methodexpsyntax[0]{
  {\methodstaticexp {\classhint{}} {\overrightarrow{\classhint{}}} {\classhint{}} {\mth{}} {\e{}} {\overrightarrow{\e{}}}}
}

\newcommand\newexpsyntax[0]{
  {\newstaticexp {\overrightarrow {\classhint{}}} {\classhint{}} {\class{}} {\overrightarrow{\e{}}}}
}

% nonreflective Java interop syntax
\newcommand\nonreflectiveexpsyntax[0]{
  \fieldexpsyntax{}
  \alt \methodexpsyntax{}
  \alt \newexpsyntax{}
}

% small figure for nonreflective Java interop syntax
\newcommand\mininonreflectiveexpsyntax[0]{
  \fieldexpsyntax{} \alt \methodexpsyntax{} \alt \newexpsyntax{}
}

\newcommand\lethintsyntax[0]{
  {\letexp {\hinted {\classhint{}} {\x{}}} {\e{}} {\e{}}}
}

\newcommand\localhintsyntax[0]{
  \hinted{\classhint{}} {\x{}}
}

\newcommand\typehintedexpsyntax[0]{
  \localhintsyntax{}
  \alt \lethintsyntax{}
}

\newcommand\classvaluesyntax[0]{
  {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
}

\newcommand\openvsyntax[0]{
  \openv{}     &::=& \{\overrightarrow{\x{} \mapsto \v{}}\}
                &\mbox{Value environments}
}

\newcommand\tatypesyntax[0]{
  \tatype{}     &::=& \unknownhint{} \alt \classhint{}
                &\mbox{Type Hints}
              }

\newcommand\typehintenvsyntax[0]{
  \taenv{}    &::=& \{ \overrightarrow{ \hastype{\x{}} {\tatype{}}} \}
               &\mbox{Type Hint Environment}
             }

\newcommand\classtableallsyntax[0]{
  \ctentrymeta{} &::=& \ctentry
               &\mbox{Class descriptors} \\
  \ct{}   &::=& \{ \overrightarrow{\classhint{} \mapsto \ctentrymeta{}} \}
               &\mbox{Class Table}
             }

\newcommand\classvaluesyntaxentry[0]{
  \classvaluemeta{} 
          &::=& \classvaluesyntax{}
               &\mbox{Class Values}
}

% reflection resolution rewrite 

\newcommand\RLocal[0]{
\infer [R-Local]
{}
{ \rewrite {\taenv{}}
           {\x{}}
           {\x{}}
         }
       }

\newcommand\RNewElimRefl[0]{
\infer [R-NewElimRefl]
{ \overrightarrow{
    \rewrite {\taenv{}}
           {\e{i}}
           {\e{j}}}
  \\
  \overrightarrow{
  \tajudgement {\taenv{}}
               {\hastype {\e{j}} {\classhint{j}}}
             }
               \\\\
  \ctorparams {\ct{}}{\classhint{}}{\overrightarrow{\classhint{j}}}{\overrightarrow{\classhint{k}}}
             }
{ \rewrite {\taenv{}}
           {\newexp {\class{}} {\overrightarrow {\e{i}}}}
           {\newstaticexp {\overrightarrow {\classhint{k}}} {\classhint{}} {\class{}} {\overrightarrow {\e{j}}}}
}

       }

\newcommand\RLet[0]{
\infer [R-Let]
{ \rewrite {\taenv{}}
           {\e{1}}
           {\ep{1}}
           \\
  \tajudgement {\taenv{}} {\hastype {\ep{1}} {\tatype{}}}
           \\\\
  \rewrite {\taenv{}, {\hastype {\x{}} {\tatype{}}}}
           {\e{}}
           {\ep{}}
         }
{ \rewrite {\taenv{}}
           {\letexp {\x{}}
                    {\e{1}}
                    {\e{}}}
           {\letexp {\x{}}
                    {\ep{1}}
                    {\ep{}}}
}
       }

\newcommand\RLetHint[0]{
\infer [R-LetHint]
{ \rewrite {\taenv{}}
           {\e{1}}
           {\ep{1}}
           \\
  \rewrite {\taenv{}, {\hastype {\x{}} {\classhint{}}}}
           {\e{}}
           {\ep{}}
         }
{ \rewrite {\taenv{}}
           {\letexp {\hinted {\classhint{}} {\x{}}}
                    {\e{1}}
                    {\e{}}}
           {\letexp {\hinted {\classhint{}} {\x{}}}
                    {\ep{1}}
                    {\ep{}}}
}
}

\newcommand\RFieldElimRefl[0]{
\infer [R-FieldElimRefl]
{ \rewrite {\taenv{}}
           {\e{}}
           {\ep{}}
           \\
  \tajudgement {\taenv{}}
               {\hastype {\ep{}} {\classhint{}}}
               \\\\
               \fieldtype {\ct{}} {\classhint{}} {\fld{}} {\classhint{t}}{\classhint{f}}
         }
{ \rewrite {\taenv{}}
           {\fieldexp {\fld{}} {\e{}}}
           {\fieldstaticexp {\classhint{t}} {\classhint{f}} {\fld{}} {\ep{}}}
         }
       }

\newcommand\RMethodElimRefl[0]{
\infer [R-MethodElimRefl]
{ \rewrite {\taenv{}}
           {\e{}}
           {\ep{}}
           \\
  \tajudgement {\taenv{}}
               {\hastype {\ep{}} {\classhint{}}}
           \\\\
           \overrightarrow{
  \rewrite {\taenv{}}
           {\e{i}}
           {\e{j}}}
           \\
           \overrightarrow{
  \tajudgement {\taenv{}}
               {\hastype {\e{j}} {\classhint{j}}}
             }
               \\\\
  \methodtype {\ct{}}{\classhint{}} {\mth{}} {\overrightarrow{\classhint{j}}}{\classhint{t}}{\overrightarrow{\classhint{p}}}{\classhint{r}}
         }
{ \rewrite {\taenv{}}
           {\methodexp {\mth} {\e{}} {\overrightarrow {\e{i}}}}
           {\methodstaticexp {\classhint{t}} {\overrightarrow {\classhint{p}}} {\classhint{r}} {\mth{}} {\ep{}} {\overrightarrow {\e{j}}}}
  }
}

\newcommand\RAbs[0]{
\infer [R-Abs]
{ \rewrite {\taenv{}, {\hastype {\x{}} {\unknownhint{}}}}
           {\e{}}
           {\ep{}}
}
{ \rewrite {\taenv{}}
           {\abs {\x{}} {\t{}} {\e{}}}
           {\abs {\x{}} {\t{}} {\ep{}}}
         }
       }

% type hint propagation

\newcommand\TALocal[0]{
\infer [TA-Local]
{ \intaenv {\taenv{}} {\x{}} {\tatype{}}
}
{ \tajudgement {\taenv{}} {\hastype {\x{}} {\tatype{}}}
}
}

\newcommand\TANil[0]{
\infer [TA-Nil]
{}
{ \tajudgement {\taenv{}} {\hastype {\nil{}} {\unknownhint{}}}
}
}

\newcommand\TANewStatic[0]{
\infer [TA-NewStatic]
{}
{ \tajudgement {\taenv{}}
  {\hastype {\newstaticexp {\overrightarrow {\classhint{i}}} {\classhint{}} {\class{}} {\overrightarrow {\e{}}}}
                           {\classhint{}}}
}
}

\newcommand\TALetHint[0]{
\infer [TA-LetHint]
{ \tajudgement {\taenv{}, {\hastype {\x{}} {\classhint{}}}}
               {\hastype {\e{}} {\tatype{}}}
}
{ \tajudgement {\taenv{}}
      {\hastype {\letexp {\hinted{\classhint{}}{\x{}}}
                                  {\e{1}}
                                  {\e{}}}
                         {\tatype{}}}
}
}

\newcommand\TALet[0]{
\infer [TA-Let]
{ \tajudgement {\taenv{}} 
               {\hastype {\e{1}} {\tatype{1}}}
               \\\\
  \tajudgement {\taenv{}, {\hastype {\x{}} {\tatype{1}}}}
               {\hastype {\e{}} {\tatype{}}}
}
{ \tajudgement {\taenv{}}
               {\hastype {\letexp {\x{}}
                                  {\e{1}}
                                  {\e{}}}
                         {\tatype{}}}
}
}

\newcommand\javanewassumption[1]{
\begin{assumption}[\newjavaliteral] \label{#1:assumption:new}
  If\ $\forall i.\ {\v{i}} = {\classvalue{\classhint{i}}{\overrightarrow{\classfieldpair{\fld{j}} {\v{j}}}}}\ or\ {\v{i}}= {\nil}$
  and {\v{i}}
  then either
  \begin{itemize}
  \item $\newjava {\classhint{}}
                {\overrightarrow{\classhint{i}}}
                {\overrightarrow{\v{i}}}
                {\classvalue{\classhint{}}{\overrightarrow {\classfieldpair{\fld{k}} {\v{k}}}}}$, or
  \item 
        $\newjava {\classhint{}}
                {\overrightarrow{\classhint{i}}}
                {\overrightarrow{\v{i}}}
                {\errorval{\v{e}}}$, or
  \item $\newjavanoeq {\classhint{}}
                {\overrightarrow{\classhint{i}}}
                {\overrightarrow{\v{i}}}$
                is undefined.
  \end{itemize}
\end{assumption}
}


% java assumptions
\newcommand\javaassumptionsall[1]{
\javanewassumption{#1}

\begin{assumption}[\getfieldliteral] \label{#1:assumption:field}
  If\ {\v{1}} = ${\classvalue{\classhint{1}}{{\classfieldpair{\fld{}}{\v{f}}, {\overrightarrow{\classfieldpair{\fld{l}} {\v{l}}}}}}}$,
  then either
  \begin{itemize}
    \item
      \getfieldjava{\classhint{1}} {\v{1}} {\fld{}} {\classhint{2}}{\v{f}},
                  and either
                  \begin{itemize}
                    \item
                  \v{f} = ${\classvalue{\classhint{2}}{\overrightarrow{\classfieldpair{\fld{m}} {\v{m}}}}}$
                   or 
                    \item
                  \v{f} = \nil, or
                  \end{itemize}
    \item
      \getfieldjava{\classhint{1}} {\v{1}} {\fld{}} {\classhint{2}} {\errorval{\v{e}}}.
  \end{itemize}
\end{assumption}

\begin{assumption}[\invokejavamethodliteral] \label{#1:assumption:method}
  If\ {\v{1}} = {\classvalue{\classhint{1}}{\overrightarrow{\classfieldpair{\fld{l}} {\v{l}}}}},
  $\forall i.\ {\v{i}}={\classvalue{\classhint{i}}{\overrightarrow{\classfieldpair{\fld{j}} {\v{j}}}}}\ or\ {\v{i}}={\nil}$
         then either
         \begin{itemize}
           \item
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{i}}} {\overrightarrow{\v{i}}}
                    {\classhint{2}}
                    {\v{}}
                  and either
                  \begin{itemize}
                    \item
                  \v{} = ${\classvalue{\classhint{2}}{\overrightarrow{\classfieldpair{\fld{m}} {\v{m}}}}}$
                  or\ 
                  \v{} = \nil, or
                  \end{itemize}
          \item
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{i}}} {\overrightarrow{\v{i}}}
                    {\classhint{2}}
                    {\errorval{\v{e}}}, or
          \item 
  \invokejavamethodnoeq {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{i}}} {\overrightarrow{\v{i}}}
                    {\classhint{2}}
                    is undefined.
        \end{itemize}
\end{assumption}
}

\newcommand\istruefalsedefinitions[1]{
\begin{definition} \label{#1:definition:istrueval}
  \istrueval{\v{}} iff {\v{}} $\not=$ \false\ and {\v{}} $\not=$ \nil.

\end{definition}

\begin{definition} \label{#1:definition:isfalseval}
  \isfalseval{\v{}} iff {\v{}} $=$ \false\ or {\v{}} $=$ \nil.

\end{definition}
}

\newcommand\soundnesslemmahypothesis[0]{
If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}},
\satisfies{\openv{}}{\propenv{}}, 
\isconsistent{\openv{}},
and \opsem {\openv{}} {\e{}} {\a{}} 
then either
\begin{itemize}
  \item
    \opsem {\openv{}} {\e{}} {\v{}} 
and all of the following hold:
\begin{enumerate}
  \item either \object{} = \emptyobject{} or \inopenv {\openv{}} {\object{}} {\v{}},
  \item either {\istrueval{\v{}}} and {\satisfies{\openv{}}{\thenprop{\prop{}}}} or 
               {\isfalseval{\v{}}} and {\satisfies{\openv{}}{\elseprop{\prop{}}}},
  \item \judgement{}{\hastype{\v{}}{\t{}}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
        for some \thenprop{\propp{}}, \elseprop{\propp{}} and {\objectp{}}, and
  \item \consistentwith{\v{}}{\openv{}}, or
\end{enumerate}

  \item
\opsem {\openv{}} {\e{}} {\errorvalv{}}.
\end{itemize}
}

\newcommand\soundnesstheorembody[1]{
If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}
and \opsem {\openv{}} {\e{}} {\v{}} 
then \judgement{}{\hastype{\v{}}{\t{}}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
        for some \thenprop{\propp{}}, \elseprop{\propp{}} and {\objectp{}}
      }

\newcommand\soundnesstheoremnoproof[1]{
\begin{theorem}[Type soundness] \label{#1:theorem:soundnessnoproof}
\soundnesstheorembody{#1}

\end{theorem}

}

\newcommand\soundnesstheorem[1]{
\begin{theorem}[Type soundness] \label{#1:theorem:soundness}
\soundnesstheorembody{#1}
\begin{proof}
  Corollary of lemma \ref{#1:lemma:soundness}.
\end{proof}

\end{theorem}

}

\newcommand\wrongtheorembody[1]{
  If {\judgement {} {\hastype {\e{}} {\t{}}} {\filterset {\thenprop{\prop{}}}{\elseprop{\prop{}}}} {\object{}}}
  then \notopsem{}{\e{}}{\wrong{}}.
}

\newcommand\wrongtheoremnoproof[1]{
\begin{theorem}[Well-typed programs don't go wrong] \label{#1:theorem:wrongnoproof}
\wrongtheorembody{#1}
\end{theorem}
}

\newcommand\wrongtheorem[1]{
\begin{theorem}[Well-typed programs don't go wrong] \label{#1:theorem:wrong}
\wrongtheorembody{#1}

\begin{proof}
  Corollary of lemma~\ref{#1:lemma:soundness}, since by lemma~\ref{#1:lemma:soundness}
  when {\judgement {} {\hastype {\e{}} {\t{}}} {\filterset {\thenprop{\prop{}}}{\elseprop{\prop{}}}} {\object{}}}, 
 either
    \opsem {} {\e{}} {\v{}} or
    \opsem {} {\e{}} {\errorvalv{}}, therefore \notopsem{}{\e{}}{\wrong{}}.
\end{proof}
\end{theorem}
}

\newcommand\nilinvoketheorembody[1]{
  If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}} then \e{} is not
  \appexp{\nil{}}{\ep{}}, 
  \fieldexp{\fld{}}{\nil{}}, or
  $\methodexp{\mth{}}{\nil{}}{\overrightarrow{\ep{}}}$.
}

\newcommand\nilinvoketheoremnoproof[1]{
\begin{theorem}[\nil{} invocation is disallowed in typed code] \label{#1:theorem:nilinvokenoproof}
  \nilinvoketheorembody{#1}

\end{theorem}
}

\newcommand\nilinvoketheorem[1]{
\begin{theorem}[\nil{} invocation is disallowed in typed code] \label{#1:theorem:nilinvoke}
  \nilinvoketheorembody{#1}

\begin{proof}
  Corollary of lemma \ref{#1:lemma:soundness}.
\end{proof}

\end{theorem}
}

\newcommand\consistentwithonlydef[1]{
\begin{definition} \label{#1:definition:consistentwith}
  \consistentwith{\v{}}{\openv{}}
  iff $\forall$ \closure{\openv{1}}{\abs{\x{}}{\s{}}{\e{}}} in \v{},
  if \judgement{}{\hastype{\closure{\openv{1}}{\abs{\x{}}{\s{}}{\e{}}}}{\t{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
  and $\forall$ \objectp{} in \t{}, either 
  \objectp{} = \emptyobject{}, or 
  \objectp{} = {\path{\pathelemp{}}{\x{}}},
  or 
\inopenvnoeq{\openv{}}{\objectp{}} = {\inopenvnoeq{\openv{1}}{\objectp{}}}.

% In code like
% (let [x true]
%   ((let [x 1]
%      (fn [a] x))
%    2))
% this property guarantees that the x's don't get confused.
\end{definition}
}

\newcommand\consistentwithdefinition[1]{
\consistentwithonlydef{#1}

\begin{definition} \label{#1:definition:isconsistent}
  \isconsistent{\openv{}}
  iff

  $\forall \v{} \in rng(\openv{})$, \consistentwith{\v{}}{\openv{}}.
\end{definition}
}

% class table lookup
\newcommand\classtablelookupfigure[0]{
\begin{figure*}
$$
\begin{altgrammar}

  \methodtypealign
  {\ct{}}
  {\classhint{}}
  {\mth{}}
  {\overrightarrow{\classhint{p}}}
  {\classhint{}}
  {\overrightarrow{\classhint{p}}}
  {\classhint{r}}
  & \text{if}\ \ctmthentry{\mth{}}{\overrightarrow{\classhint{p}}}{\classhint{r}} \in {\ctlookupmethods{\ct{}}{\classhint{}}}
      \\
  \fieldtypealign 
  {\ct{}}
  {\classhint{}}
  {\fld{}}
  {\classhint{}}
  {\classhint{f}}
  & \text{if}\ \ctfldentry{\fld{}}{\classhint{f}} \in {\ctlookupfields{\ct{}}{\classhint{}}}
      \\
  \ctorparamsalign 
      {\ct{}}
      {\classhint{}}
      {\overrightarrow{\class{p{}}}}
      {\overrightarrow{\class{p{}}}}
  & \text{if}\ \ctctorentry{\overrightarrow{\class{p{}}}} \in {\ctlookupctors{\ct{}}{\classhint{}}}
\end{altgrammar}
$$
\caption{Class table lookup}
\end{figure*}
}

% convert Java types
\newcommand\convertjavatypefigure[2]{
\begin{#1}
#2
$$
\begin{altgrammar}
\javatotcalign {\Void{}} {\Nil}
\\
\javatotcalignnil {\Void{}} {\Nil}
\\
\javatotcalign {\class{}} \class{}
\\
\javatotcalignnil {\class{}} {\Union {\Nil} {\class{}}}

\end{altgrammar}
$$
\caption{Java Type Conversion}
\end{#1}
}

% constants syntax
\newcommand\constantssyntax[0]{
  {\const{}}           &::=& \classconst %\alt \throwconst

                &\mbox{Constants}
              }

\newcommand\updatefigure[0]{
\update{\HMapgeneric {\mandatory} {\absent}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\HMapgeneric {\extendmandatoryset{\mandatory}{\k{}}{\update{\t{}}{\propisnotmeta{}}{\pathelem{}}}}{\absent}}
& {\inmandatory{\k{}}{\t{}}{\mandatory{}}}
%& Present Key
\\
\update{\HMapgeneric {\mandatory} {\absent}}{\t{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\Bottom{}}
& {\notsubtypein {} {\Nil{}} {\t{}}}\ \text{and}\ {\inabsent{\k{}}{\absent{}}}
%& Bad absent +
\\
\update{\HMapgeneric {\mandatory} {\absent}}{\nottype{\t{}}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\Bottom{}}
& {\issubtypein {} {\Nil{}} {\t{}}}\ \text{and}\ {\inabsent{\k{}}{\absent{}}}
%& Bad absent -
\\
\update{\HMapgeneric {\mandatory} {\absent}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\HMapgeneric {\mandatory} {\absent}}
& {\inabsent{\k{}}{\absent{}}}
%& Consistent absent
\\
\update{\HMapp {\mandatory} {\absent}}{\t{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\Union {\HMapp {\extendmandatoryset {\mandatory} {\k{}}
                                     {\t{}}}
                {\absent}}
        {\HMapp {\mandatory} {\extendabsentset{\absent}{\k{}}}}}
& {\issubtypein {} {\Nil{}} {\t{}}},\ 
{\notinmandatory{\k{}}{\s{}}{\mandatory{}}}\ \text{and}\ {\notinabsent{\k{}}{\absent{}}}
\\
\update{\HMapp {\mandatory} {\absent}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\HMapp {\extendmandatoryset {\mandatory} {\k{}}{\update{\Top}{\propisnotmeta{}}{\pathelem{}}}} {\absent}}
& 
{\notinmandatory{\k{}}{\s{}}{\mandatory{}}}\ \text{and}\ {\notinabsent{\k{}}{\absent{}}}

\\
\update{\HMapp {\mandatory} {\absent}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
{\HMapp {\extendmandatoryset {\mandatory} {\k{}}{\update{\Top}{\propisnotmeta{}}{\pathelem{}}}} {\absent}}
\\
\update{\Unionsplice{{\overrightarrow{\HMapgeneric {\mandatory} {\absent}}}^i}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}
&=&
\Unionsplice{{\overrightarrow{\update{\HMapgeneric {\mandatory} {\absent}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\keype{\k{}}}}}}^i}


% ClassPE
\\
\update{\t{}}{\Value{\class{}}}{\destructpath{\pathelem{}}{\classpe{}}}
&=& \update{\t{}}{\class{}}{\pathelem{}}
\\
\update{\t{}}{\nottype{\Value{\class{}}}}{\destructpath{\pathelem{}}{\classpe{}}}
&=& \update{\t{}}{\nottype{\class{}}}{\pathelem{}}
& \text{if}\ \not\exists \classp{}.\ {\issubtypein{}{\classp{}}{\class{}}}\ \text{and}\ {\classp{}} \not= \class{}
\\
\update{\t{}}{\s{}}{\destructpath{\pathelem{}}{\classpe{}}}
&=& \update{\t{}}{\Object}{\pathelem{}}
& \text{if}\ \issubtypein{}{\s{}}{\Object{}}
\\
\update{\t{}}{\nottype{\s{}}}{\destructpath{\pathelem{}}{\classpe{}}}
&=& \update{\t{}}{\Nil{}}{\pathelem{}}
& \text{if}\ \issubtypein{}{\Object{}}{\s{}}
\\
\update{\t{}}{\s{}}{\destructpath{\pathelem{}}{\classpe{}}}
&=& \update{\t{}}{\Nil}{\pathelem{}}
& \text{if}\ \issubtypein{}{\s{}}{\Nil{}}
\\
\update{\t{}}{\nottype{\s{}}}{\destructpath{\pathelem{}}{\classpe{}}}
&=& \update{\t{}}{\Object}{\pathelem{}}
& \text{if}\ \issubtypein{}{\Nil{}}{\s{}}

% What if \s{} is a union of class singletons?
% this just seems wrong
%\\
%\update{\t{}}{\s{}}{\classpe{}}
%&=& \restrict{\t{}}{\s{}}
%
%\\
%\update{\t{}}{\nottype{\s{}}}{\classpe{}}
%&=& \remove{\t{}}{\s{}}

% Don't need base case covers \Top
\\
\update{\t{}}{\propisnotmeta{}}{\destructpath {\pathelem{}} {\classpe{}}}
&=& {\t{}}

\\
\update{\t{}}{\s{}}{\emptypath{}}
&=&
\restrict{\t{}}{\s{}}
\\
\update{\t{}}{\nottype{\s{}}}{\emptypath{}}
&=&
\remove{\t{}}{\s{}}

              }

\newcommand\restrictremovefigure[0]{
\restrict{\t{}} {\s{}} &=& \Bot{}\\
                       & & \text{if} \not\exists \v{}.\  
                          {\judgement {} {\hastype {\v{}} {\t{}}} {\prop{1}}{\object{1}}}\\
                       & &\text{and}\ 
                          {\judgement {} {\hastype {\v{}} {\s{}}} {\prop{2}}{\object{2}}}
                          \\
\restrict{\Unionsplice{\overrightarrow{{\t{}}}}}{\s{}} &=& 
\Unionsplice{\overrightarrow{\restrict{{\t{}}}{\s{}}}}
\\
\restrict{\t{}}{\s{}} &=& {\t{}} & \text{if}\ {\issubtypein {} {\t{}} {\s{}}}
\\
\restrict{\t{}}{\s{}} &=& {\s{}} & \text{otherwise}
\\\\
\remove{\t{}}{\s{}} &=& {\Bot{}} & \text{if}\ {\issubtypein {} {\t{}} {\s{}}}
\\
\remove{\Unionsplice{\overrightarrow{{\t{}}}}}{\s{}} &=& 
\Unionsplice{\overrightarrow{\remove{{\t{}}}{\s{}}}}
\\
\remove{\t{}}{\s{}} &=& {\t{}} & \text{otherwise}
}

\newcommand\constanttypefigure[0]{
\begin{array}{lllr}
  \constanttype{\classconst} &=& {\ArrowOne {\x{}} {\Top{}}
                                      {\Union{\nil{}}{\Class{}}}
                                      {\filterset {\topprop{}}
                                                  {\topprop{}}}
                                      {\path {\classpe{}} {\x{}}}}
%                                      \\
%
%  \constanttype{\throwconst} &=& {\ArrowOne {\x{}} {\Top{}}
%                                      {\Bot{}}
%                                      {\filterset {\botprop{}}
%                                                  {\botprop{}}}
%                                      {\emptyobject{}}}
%
\end{array}
}

\newcommand\constantsemfigure[0]{
\begin{figure}
\begin{mathpar}

\begin{array}{lllr}

\constantopsem{\classconst}{\classvalue{\class{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}} &=& \class{}\\
\constantopsem{\classconst}{\class{}} &=& \Class{}\\
\constantopsem{\classconst}{\true{}} &=& \Boolean{}\\
\constantopsem{\classconst}{\false{}} &=& \Boolean{}\\
\constantopsem{\classconst}{\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}} &=& \IFn{}\\
\constantopsem{\classconst}{\multi {\v{d}} {\disptable{}}} &=& \PMulti{}\\
\constantopsem{\classconst}{\mapval{}} &=& \HMapInstance{}\\
\constantopsem{\classconst}{\k{}} &=& \Keyword{}\\
%\constantopsem{\classconst}{\num{}} &=& \Number{}\\
\constantopsem{\classconst}{\nil{}} &=& \nil{}
  %\constantopsem{\classconst}{\v{}} &=& \wrong{} & otherwise\\
%  \\\\
%\constantopsem{\throwconst}{\v{}} &=& \errorval{\v{}}\\


\end{array}
\end{mathpar}
\caption{Primitives}
\end{figure}
}

% proof system
\newcommand\LUpdate[0]{
\infer [L-Update]
{ \inpropenv {\propenv{}} {\isprop {\t{}} {\path {\pathelemp{}} {\x{}}}}
\\
  \inpropenv {\propenv{}} {\isprop {\propisnotmeta{}} {{\pathelem{}}({\path {\pathelemp{}} {\x{}}})}}}
{ \inpropenv {\propenv{}} {\isprop {\update {\t{}} {\propisnotmeta{}} {\pathelem{}}} {\path {\pathelemp{}} {\x{}}}}}
}
