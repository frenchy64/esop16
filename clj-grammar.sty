% see mmm.sty for implementation of newmeta etc

% macros for Clojure grammars
\usepackage{mathpartir}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{xcolor}


% newmeta variables are automatically subscripted
% \x0, \x1, \x{}

%% metavariables

% constants
\newmeta\const{c}

% types
\newmeta\s{\sigma}              % these are automatically wrapped in \ma
\newmeta\sp{\sigma{'}}
\newmeta\t{\tau}
\newmeta\tp{\tau{'}}
\newmeta\tpp{\tau{''}}
\newmeta\T{T}

% expressions
\newmeta\M{M}
\newmeta\N{N}
\newmeta\P{P}
\newmeta\e{e}
\newmeta\ep{e'}
\newmeta\expd{d}
\newmeta\ReflectiveExp{R}
\newmeta\NonReflectiveExp{E}
\newmeta\MultimethodExp{M}
\newmeta\HintedExp{H}
\newmeta\HashMapExp{G}

% we write a macro for every bit of abstract syntax.  That way they
% will all look the same!

% types
\newbfop\int{int}
\newbfop\Boolean{Boolean}
\newbfop\Booleanhint{Boolean}
\newbfop\IFn{IFn}
\newbfop\MultiFn{MultiFn}
\newbfop\PMulti{Multi}
\newbfop\IPersistentMapLiteral{IPersistentMap}
\newbfop\MapLiteral{Map}
\newbfop\Uliteral{\ma{\bigcup}}
\newbfop\Iliteral{\ma{\bigcap}}
\newbfop\Not{Not}
\newbfop\Allliteral{All}
\newbfop\TFnliteral{TFn}
\newbfop\Valueliteral{Value}
\newbfop\ArrayTwoLiteral{Array2}
\newbfop\ArrayLiteral{Array}
\newbfop\ArrayPLiteral{ArrayP}
\newbfop\Throwable{Throwable}
\newbfop\Class{Class}
\newcommand\MultiFntype[2]{(\PMulti #1\ #2)}
\newcommand\proctype[2]{(#1 \to #2)}
\newcommand\Unionsplice[1]{(\ma{\Uliteral\ #1})}
\newcommand\Union[2]{(\ma{\Uliteral\ #1\ #2})}
\newcommand\In[1]{(\ma{\Iliteral\ #1})}
\newcommand\ArrayTwo[2]{(\ma{\ArrayTwoLiteral\ #1\ #2})}
\newcommand\Array[1]{(\ArrayLiteral #1)}
\newcommand\ArrayP[1]{(\ArrayPLiteral #1)}
% \proctype is a little overkill.
%% Reynolds' package can also abstract things like (\s1 \to \s2 \to \s3).
\newcommand\Arrow[4]{\ma{#1 \xrightarrow[#4]{#3} #2}}
% TODO figure out how to make #1 : #2 closer to the :
\newcommand\ArrowOne[5]{\ma{{\hastypesmall {#1} {#2}} \xrightarrow[#5]{#4} #3}}
\newcommand\ArrowOverright[5]{\ma{{\overrightarrow{\hastypesmall {#1} {#2}}} \xrightarrow[#5]{#4} #3}}
% minus filters and object, implicitly tt | tt; empty
\newcommand\ArrowTwo[3]{\ma{{\hastypesmall {#1} {#2}} \xrightarrow\ {#3}}}

\newcommand\All[2]{(\ma{\Allliteral\ [#1]\ #2})}
\newcommand\TFn[2]{(\ma{\TFnliteral\ [#1]\ #2})}
\newcommand\Value[1]{(\ma{\Valueliteral #1})}
\newbfop\Top{\ma{\top}}
\newbfop\Bottom{\ma{\bot}}
\newbfop\Bot{\ma{\bot}}
\newbfop\Keyword{Keyword}
\newbfop\Keywordhint{Keyword}
\newbfop\Symbol{Symbol}
\newbfop\Number{Number}
\newbfop\Nil{nil}
\newbfop\True{true}
\newbfop\False{false}
\newbfop\falsy{(\ma{\cup\ \Nil\ \False})}
\newbfop\falsydiff{\ma{\trdiff{\falsy}}}
\newcommand\IPersistentMap[2]{(\ma{\IPersistentMapLiteral\ #1\ #2})}
\newcommand\Map[2]{(\ma{\MapLiteral #1\ #2})}
\newcommand\HMapInstance[0]{\ma{\IPersistentMapLiteral}}
\newbfop\HMapliteral{HMap}
\newmeta\completenessmeta{\mathcal{A}}
\newmeta\complete{\mathcal{C}}
\newmeta\partial{\mathcal{P}}
\newcommand\HMapgeneric[2]{(\ma{\HMapliteral^{\completenessmeta{}} #1\ #2})}
\newcommand\HMapc[1]{(\ma{\HMapliteral^{\complete{}} #1})}
\newcommand\HMapp[2]{(\ma{\HMapliteral^{\partial{}} #1\ #2})}
\newcommand\mandatoryset[1]{\ma{\{#1\}}}
\newcommand\mandatorysetoverright[2]{\ma{\{\overrightarrow{(#1,\ #2)}\}}}
\newcommand\notinmandatory[3]{\ma{(#1\ #2)} \not\in {#3}}
\newcommand\inmandatory[3]{\ma{(#1\ #2)} \in {#3}}
\newcommand\extendmandatoryset[3]{(#1, (#2\ #3))}
\newmeta\mandatory{p}
\newmeta\absent{a}
\newcommand\absentoverright[1]{\ma{\{{\overrightarrow{#1}}\}}}
\newcommand\inabsent[2]{\ma{#1 \in #2}}
\newcommand\notinabsent[2]{\ma{#1 \not\in #2}}
\newcommand\extendabsentset[2]{(#1, #2)}
\newbfop\Satisfiesliteral{Satisfies}
\newcommand\Satisfies[1]{(\ma{\Satisfiesliteral\ #1})}
\newbfop\Instanceliteral{InstanceOf}
\newcommand\Instance[1]{(\ma{\Instanceliteral\ #1})}
\newcommand\HVec[1]{[{#1}]}

% terms
\newmeta\x{x}                   % not sure if \x is reserved...
\newmeta\xp{x{'}}                   % not sure if \x is reserved...
\newmeta\v{v}
\newmeta\vp{v'}
\newmeta\class{C}
\newmeta\classp{C{'}}
\newmeta\protocol{P}
\newmeta\k{k}
\newmeta\num{n}
\newmeta\b{b}
\newcommand\operatorfont[1]{\ma{{\mathsf{#1}}}}
\newcommand\literalfont[1]{\ma{{\mathsf{#1}}}}
\newcommand\nil[0]{{\literalfont{nil}}}
\newcommand\true[0]{{\literalfont{true}}}
\newcommand\false[0]{{\literalfont{false}}}
\newcommand\assocliteral[0]{{\operatorfont{assoc}}}
\newcommand\assocexp[3]{(\assocliteral{}\ #1\ #2\ #3)}
\newmeta\dissoc{dissoc}
\newmeta\getliteral{{\operatorfont{get}}}
\newcommand\getexp[2]{(\getliteral{}\ #1\ #2)}
\newcommand\ifliteral[0]{{\operatorfont{if}}}
\newcommand\doliteral[0]{{\operatorfont{do}}}
\newcommand\letliteral[0]{{\operatorfont{let}}}
\newcommand\throwliteral[0]{{\operatorfont{throw}}}
\newcommand\newliteral[0]{{\operatorfont{new}}}
\newcommand\defmultiliteral[0]{{\operatorfont{defmulti}}}
\newcommand\defmethodliteral[0]{{\operatorfont{defmethod}}}
\newcommand\abs[3]{\ma{\l #1^{#2} . #3}}
\newcommand\absoverright[3]{\ma{\l \overrightarrow{#1^{#2}} . #3}}
\newcommand\curlymap[1]{\ma{\{#1\}}}
\newcommand\emptymap[1]{\ma{\{\}}}
\newcommand\curlymapvaloverright[2]{\ma{\{{\overrightarrow{(#1\ #2)}}\}}}
\newcommand\extendmap[3]{\ma{#1[#2 \rightarrow #3]}}
\newcommand\getmap[2]{\ma{#1[#2]}}
\newcommand\keyinmap[2]{\ma{{#1} \in dom({#2})}}
\newcommand\keynotinmap[2]{\ma{{#1} \not\in dom({#2})}}
\newcommand\comb[2]{\ma{(#1\ #2)}}
\newcommand\ifexp[3]{(\ma{\ifliteral{}\ #1\ #2\ #3})}
\newcommand\doexp[2]{(\ma{\doliteral{}\ #1\ #2})}
\newcommand\letexp[3]{(\ma{\letliteral{}\ [\ma{#1\ #2}]\ #3})}
\newcommand\appexp[2]{(\ma{#1\ #2})}
\newcommand\throwexp[1]{(\ma{\throwliteral{}\ #1})}
\newcommand\newexp[2]{(\ma{\newliteral{}\ #1\ #2})}
\newcommand\newstaticexp[4]{(\ma{{\newliteral}_{[[#1], #2]}\ #3\ #4})}
\newcommand\dotliteral[0]{{\operatorfont{.}}}
\newcommand\fieldexp[2]{(\ma{\dotliteral\ #2\ #1})}
\newcommand\fieldstaticexp[4]{(\ma{\dotliteral\ #4\ {#3}^{#1}_{#2}})}
\newcommand\methodexp[3]{(\ma{\dotliteral\ #2\ (#1\ #3)})}
\newcommand\methodstaticexp[6]{(\ma{\dotliteral\ #5\ ({#4}^{#1}_{[[#2], #3]}\ #6)})}
\newcommand\createmultiexp[2]{(\ma{\defmultiliteral{}\ #1\ #2})}
\newcommand\defmultiexp[2]{(\ma{\defmultiliteral{}\ #1\ #2})}
\newcommand\defmethodexp[4]{(\ma{\defmethodliteral{}\ #1\ #2\ [#3]\ #4})}
\newcommand\extendmultiexp[3]{(\ma{\defmethodliteral{}\ #1\ #2\ #3})}
\newmeta\defliteral{{\bf def}}
\newcommand\defexp[2]{(\ma{\defliteral{}\ #1\ #2})}
\newcommand\wrong[0]{\ma{wrong}}
\newcommand\errorval[1]{\ma{error_{#1}}}
\newcommand\errorvalv[0]{\errorval{\v{}}}
\newcommand\reflerror[0]{\errorval{refl}}
\newcommand\mmerror[0]{\errorval{mm}}
\newcommand\rtvector[1]{[{#1}]}

% Java primitives
\newmeta\pint{int}
\newbfop\Integer{java.lang.Integer}
\newmeta\plong{long}
\newbfop\Long{java.lang.Long}
\newmeta\pdouble{double}
\newbfop\Double{java.lang.Double}
\newmeta\pchar{char}
\newbfop\Character{java.lang.Character}
\newmeta\pvoid{void}
\newbfop\Void{Void}
\newbfop\File{File}
\newbfop\String{String}
\newmeta\mth{mth}
\newmeta\fld{fld}

% Clojure values
\newmeta\symbol{symbol}
\newmeta\nat{nat}

% constant calls
\newbfop\ccclass{class}
\newcommand\instanceliteral[0]{\operatorfont{instance?}}
\newcommand\isaliteral[0]{{\operatorfont{isa?}}}
\newcommand\instanceapp[2]{{(\instanceliteral\ #1\ #2)}}
\newcommand\isaapp[2]{(\isaliteral\ #1\ #2)}

% constant typing
\newcommand\constanttypetwo[2]{\ma{{\delta}_{#1}(#2)}}
\newcommand\constanttype[1]{\constanttypetwo{\t{}}{#1}}
\newcommand\constantopsem[2]{\ma{{\delta}(#1, #2)}}
\newcommand\classconst[0]{\emph{class}}
\newcommand\throwconst[0]{\emph{throw}}

% differences from TR
\newcommand\trdiff[1]{\mathbin{\textcolor{blue}{#1}}}

% update function
\newcommand\metafunctionfont[1]{{\mathsf{#1}}}
\newcommand\updateliteral[0]{\metafunctionfont{update}}
\newcommand\update[3]{\updateliteral(#1 , #2, #3)}
\newcommand\restrictliteral[0]{\metafunctionfont{restrict}}
\newcommand\restrict[2]{\restrictliteral(#1, #2)}
\newcommand\removeliteral[0]{\metafunctionfont{remove}}
\newcommand\remove[2]{\removeliteral(#1, #2)}
\newcommand\emptypath[0]{\epsilon}

% class table
\newcommand\ct[0]{\mathcal{CT}}
\newcommand\ctlookup[1]{\ct(\ma{#1})}
\newmeta\ctentrymeta{ce}
\newmeta\ctmethod{m}
\newmeta\ctfield{f}
\newmeta\ctctor{c}
\newcommand\ctentry[0]{\{ methods \Rightarrow \{ \overrightarrow{\mth{} \Rightarrow [\overrightarrow{\classhint{}}, \classhint{}] } \}, \ 
                          fields \Rightarrow \{\overrightarrow{\fld{} \Rightarrow \classhint{}} \}, \ 
                          constructors \Rightarrow \{ [\overrightarrow{\classhint{}}] \}
                          \}}

% typing judgements
\newcommand\hastype[2]{\ma{#1 \mathbin{:} #2}}
\newcommand\hastypesmall[2]{\ma{#1 {:} #2}}
\newcommand\issubtype[2]{\ma{#1 \mathbin{<:} #2}}
\newcommand\issubtypein[3]{\ma{{\inpropenv{#1} {#2 \mathbin{<:} #3}}}}
\newcommand\issubobjin[3]{\ma{{\inpropenv{#1} {#2 \mathbin{<:} #3}}}}
\newcommand\notsubtypein[3]{\ma{{\inpropenv{#1} {#2 \mathbin{\not<:} #3}}}}
% 4 place relation (TR formalism)
\newcommand\judgement[4]{\ma{#1 \vdash #2\ ;\ #3\ ;\ #4}}
% 7 place relation (TC formalism)
\newcommand\judgementsev[7]{\ma{#3 \vdash #4\ ;\ #5\ ;\ #6}}
%\newcommand\judgementsev[7]{\ma{#3 \vdash_{\scriptscriptstyle{\trdiff{\ct{}}}} #4\ ;\ #5\ ;\ #6}}
% 7 place relation with color
\newcommand\judgementsevcol[7]{\judgementsev {\trdiff{#1}} {\trdiff{#2}} {#3} {#4} {#5} {#6} {\trdiff #7}}
% expands to 7 place but with 4 args (the TR formalism)
\newcommand\judgementfillcol[4]{\judgementsevcol {\mmenv} {\taenv} {#1} {#2} {#3} {#4} {\mmenv}}
% expects everything except mmenv
\newcommand\judgementfillmmcol[5]{\judgementsevcol {\mmenv} {#1} {#2} {#3} {#4} {#5} {\mmenv}}
% lookuping props in the env
% 2 place relation (same as tt | tt; empty)
\newcommand\judgementtwo[2]{\ma{#1 \vdash #2}}
\newcommand\inpropenv[2]{\ma{#1 \vdash #2}}

% operational semantics
\newmeta\openv{\rho}
\newcommand\inopenv[3]{\ma{#1 (#2) = #3}}
\newcommand\extendopenv[3]{\ma{#1[#2 \rightarrow #3]}}
\newcommand\opsem[3]{\ma{#1 \vdash #2 \Downarrow #3}}
\newcommand\notopsem[3]{\ma{#1 \not\vdash #2 \Downarrow #3}}
\newcommand\closure[2]{\ma{[#1, #2]_{closure}}}
% multimethod semantics
\newcommand\multi[2]{\ma{[#1, #2]_{multi}}}
\newcommand\emptydisptable[0]{\{\}}
\newmeta\disptable{m}
\newmeta\disptablep{m'}
\newcommand\extenddisptable[3]{\ma{#1[#2 \rightarrow #3]}}
\newcommand\getmethodliteral[0]{\ma{\metafunctionfont{GetMethod}}}
\newcommand\getmethod[3]{\getmethodliteral(#1, #2) = #3}
\newcommand\getmethodalign[3]{\getmethodliteral(#1, #2) &=& #3}

% java reflection rewrite 
\newcommand\rewrite[3]{\ma{#1\ \vdash #2 \Rightarrow #3}}

% tools.analyzer judgements
\newcommand\ta[0]{\mathcal{TA}}
\newcommand\intaenv[3]{\ma{#1 (#2) = #3}}
\newcommand\tajudgement[2]{\ma{#1 \vdash #2}}

% type hints
\newmeta\tatypeunknown{\gamma^{?}}
\newmeta\tatype{\gamma}
\newmeta\tatypep{\gamma'}
\newmeta\classhint{C}
\newmeta\primitivehint{p}
\newmeta\unknownhint{\mathbbm{?}}
\newcommand\hinted[2]{\ma{\ \widehat{}\ #1\ #2}}

% convert tools.analyzer types to core.typed types
\newcommand\tatotc[2]{\ma{[[#1]]\ =\ #2}}

% environment
\newcommand\propenv{\ma{\Gamma}}
\newcommand\propenvp{\ma{\Gamma'}}
\newcommand\propenvc{\ma{\Gamma_c}}
\newcommand\mmenv{\Delta}
\newcommand\mmenvp{\mmenv'}
\newcommand\mmenvpp{\mmenvp'}
\newcommand\taenv{\Sigma}
\newcommand\taenvp{\taenv'}

% multimethod envs
\newcommand\adddispatchfn[2]{\ma{add\_dispatch\_fn(#1,\ #2)}}
\newcommand\getdispatchfn[2]{\ma{get\_dispatch\_fn(#1)_{#2}}}
\newcommand\inmmenv[3]{\ma{#1 (#2) = #3}}

\newcommand\metafnfont[1]{{\metafunctionfont{#1}}}

% isa? special functions
\newcommand\isacompareliteral[0]{\ma{\metafnfont{IsAProps}}}
\newcommand\isacompare[4]{\ma{\isacompareliteral(#1, #2, #3) = {#4}}}
\newcommand\isacomparethree[3]{\ma{\isacompareliteral(#1, #2, #3)}}
\newcommand\isacomparealign[4]{\ma{\isacompareliteral(#1, #2, #3) &=& {#4}}}
\newcommand\isaopsemliteral[0]{\ma{\metafnfont{IsA}}}
\newcommand\isaopsem[2]{\ma{\isaopsemliteral(#1, #2)}}

% new special functions
% Type -> [Type]
\newcommand\ctorparamsliteral[0]{\metafnfont{Constructor}}
\newcommand\ctorparams[3]{\ma{\ctorparamsliteral(#1,\ #2)\ =\ #3}}
\newcommand\ctorparamsalign[3]{\ma{\ctorparamsliteral(#1,\ #2)\ &=&\ #3}}

% field special functions
% Type Field -> Type
\newcommand\fieldtypeliteral[0]{\metafnfont{Field}}
\newcommand\fieldtype[3]{\ma{\fieldtypeliteral(#1,\ #2)\ =\ #3}}
\newcommand\fieldtypealign[3]{\ma{\fieldtypeliteral(#1,\ #2)\ &=&\ #3}}

% method special functions
% Type [Type] Method -> [Type]
\newcommand\methodtypeliteral[0]{\metafnfont{Method}}
\newcommand\methodtype[4]{\ma{\methodtypeliteral(#1,\ #2)\ =\ [#3, #4]}}
\newcommand\methodtypealign[4]{\ma{\methodtypeliteral(#1,\ #2)\ &=&\ [#3, #4]}}

% java subtyping
\newcommand\assignable[2]{\ma{assignable(#1, #2)}}

% evaluation contexts
\newmeta\E{E}


% propositions
\newmeta\prop{\psi}
\newmeta\propp{\psi'}
\newmeta\proppp{\psi''}
\newmeta\propisnotmeta{\nu}
\newcommand\isprop[2]{\ma{{#1}_{#2}}}
\newcommand\impprop[2]{\ma{#1 \supset #2}}
\newcommand\nottype[1]{\ma{\overline{#1}}}
\newcommand\notprop[2]{\ma{{\nottype{#1}}_{#2}}}
\newcommand\andprop[2]{\ma{#1 \wedge #2}}
\newcommand\orprop[2]{\ma{#1 \vee #2}}
\newmeta\topprop{\mathbbm{tt}}
\newmeta\botprop{\mathbbm{ff}}
\newcommand\filterset[2]{\ma{#1 | #2}}
\newcommand\filtersetparen[2]{\ma{(\filterset{#1}{#2})}}
\newcommand\thenprop[1]{\ma{{#1}_+}}
\newcommand\elseprop[1]{\ma{{#1}_-}}
\newcommand\flowprop[1]{\ma{{#1}_\rightarrow}}

% objects
\newcommand\path[2]{\ma{#1(#2)}}
\newmeta\object{o}
\newmeta\objectp{o'}
\newmeta\emptyobject{\emptyset}
\newmeta\pathelem{\pi}
% abstract syntax for pathelem
\newmeta\pesyntax{pe}
\newmeta\classpe{{\bf class}}
\newcommand\keype[1]{{\bf key}_{\ma{#1}}}

\newcommand\destructpath[2]{\ma{#1 :: #2}}

% scope replacements
\newcommand\replacefor[3]{\ma{#1 [#2 / #3]}}

% Java type conversion functions
\newcommand\javatotcliteral[0]{\ma{\metafnfont{JavaToTC}}}
\newcommand\javatotc[2]{\javatotcliteral(\ma{#1})\ =\ #2}
\newcommand\javatotcnil[2]{\ma{\javatotcliteral_{\nil{}}(\ma{#1})\ =\ #2}}
\newcommand\javatotcalign[2]{\javatotcliteral(\ma{#1})\ &=&\ #2}
\newcommand\javatotcalignnil[2]{\javatotcliteral_{\nil{}}(\ma{#1})\ &=&\ #2}

% # Runtime semantics
% ## Runtime class syntax
\newmeta\classvaluemeta{I}
\newcommand\classfieldpair[2]{#1 : #2}
\newcommand\classvalue[2]{\ma{#1\ \{#2\}}}

% ## metafunction to invoke java
% Class Target Method ArgTypes Args ReturnType ReturnValue
\newcommand\invokejavamethodliteral[0]{\ma{JVM_{invokestatic}}}
\newcommand\invokejavamethod[7]{\ma{\invokejavamethodliteral[#1, #2, #3, [#4], [#5], #6] = #7}} % Class Args ReturnValue
% Class ArgTypes Args ReturnValue
\newcommand\newjavaliteral[0]{\ma{JVM_{new}}}
\newcommand\newjava[4]{\ma{\newjavaliteral[#1, [#2], [#3]] = #4}}
% Class Target Field FieldType ReturnValue
\newcommand\getfieldliteral[0]{\ma{JVM_{getstatic}}}
\newcommand\getfieldjava[5]{\ma{\getfieldliteral[#1, #2, #3, #4] = #5}}
% Class Target Bool
\newcommand\instanceofjava[3]{\ma{JVM_{instanceof}[#1, #2] = #3}}

\newcommand\satisfies[2]{\ma{{#1} \models {#2}}}
