We thank the reviewers for their detailed feedback.  We're glad the
reviewers found Typed Clojure to be "an extremely useful
contribution", "a nice approach to obtain a practical system", and
that our approach is "interesting and well illustrated."

The reviewers primary concerns are with two issues:

1. Is the design, implementation, and evaluation of Typed Clojure a
   significant new contribution?

Review B notes "occurrence typing scales to Clojure without having to
investigate dramatically new results", citing this as a disadvantage.

We disagree---the effectiveness of occurrence typing at handling
Clojure idioms is a strength of our design. Furthermore, while the
relationship between occurrence typing and Clojure now seems
intuitive, the full extent of their synthesis was not initially
obvious.

For example, our work uncovers a strong link between occurrence typing
-- a typing mechanism originally designed for local conditionals --
and Clojure's multimethods, an elaborate control-flow mechanism that
includes arbitrary dynamic dispatch. The ability to reuse the logical
reasoning of occurrence typing for multimethods is both novel and
crucial for Typed Clojure's success. Review A describes this as "not
extremely novel", perhaps because occurrence typing already exists. We
argue that the ability to reuse existing technology in unanticipated
ways is often more valuable than whole-cloth reinvention.

Furthermore, Typed Clojure synthesizes occurrence typing and
heterogeneous maps into a subtle (Figure 9 HMap rules) but extremely
compositional result.  As noted by Review A, heterogeneous maps in
this style are not new -- Krishnamurthi et al's (DLS 2013) TeJaS, a
type system for JavaScript supports similar -- however the combination
with occurrence typing produces novel results which are used in
practice in Typed Clojure--see Example 9 for a demonstration..

2. What questions does the evaluation section answer?

Typed Clojure is fortunate to have real-world users, and we are thus
able to evaluate its effectiveness in these settings. We set out to
answer 3 questions:
  (Q1) Is Typed Clojure viable for use in real-world code?
  (Q2) Are the features detailed in the paper needed for typing
  real-world Clojure programs?
  (Q3) What problems do Typed Clojure users encounter?

As the reviews point out, the importance of the evaluation, and the
questions it answers, are not sufficiently clear in the paper; we will
address this in a revised version.

To answer Q1, we demonstrate the utility of our work by checking
thousands of lines of non-trivial code. While the reviews correctly
point out that much of CircleCI's code base is not typed, the portion
that is contains thousands of lines of production code.

To answer Q2, we see that multimethods, heterogenous maps, and Java
interoperability are all widely used in our sample. Even though
multimethods are not defined in the feeds2imap code, they are
called. The small number of multimethods defined in the CircleCI code
may be misleading---the numbers are similar to 11 interfaces in Java,
with 89 concrete implemenations.

Our answer to Q3 is necessarily more subjective, but describes the
limitations that users encountered and future work to address them.


% Unfortunately extending occurrence
% typing to account for null, HMaps and multimethods is not extremely novel. 

We disagree. These features combine in ways that are sufficient to demonstrate,
the advantages of the unified framework of occurrence typing, distilled in Example 9.

% There were some curious things about the case studies.
% 
% + feeds2imap doesn't as far as I can tell, use multimethods
%   or particularly fancy HMaps, hence does not provide much
%   evidence about 2,3 above.

Correct, feeds2imap contains no typed or untyped multimethod definitions,
and uses HMaps in standard ways.

% + circleCI is very large (55KLoc) -- and hence, likely more complex.
%   (And the authors indicate there are various things that fall outside
%   the scope of Typed Clojure at the moment.) However, even in this large
%   code base, there are only 11 checked multimethods? The paper says:

%   However, only 40% of it is typed, and of that only 20% of the definitions
%   are actually checked? 
%   So only 8% of the definitions are type checked.

While correct, 407 functions are still typed.
CircleCI was gradually porting to Typed Clojure where extra checking was deemed desirable.

We determined difficulty of checking a barrier to checking
the CircleCI code base. This motivates future work on gradual typing, which should
check the remaining invariants at runtime with less difficulty.

%   "The CircleCI code base contains 11 checked multimethods.
%    All 11 dispatch functions are on a HMap key containing a
%    keyword, in a similar style to Example 8. Correspondingly,
%    all 89 methods are associated with a keyword dispatch value."
% 
%   Which 89 methods? I was a bit confused by that sentence here
%   so a clarification would be welcome.

11 multimethods are typed, which contain 89 defmethods.

% At any rate, I was not ready to accept the conclusions drawn
% in the "Lessons" paragraph because multimethods didn't seem
% that pervasive across the whole code base (but yes null is
% everywhere, and so are records/HMaps.) The paper says:
% 
%   "(the features) are used on average more than once per typed function"
% 
% but this could also be because only a small fraction of all functions
% are typed functions?
%
% To strengthen the paper I suggest the authors additionally
% measure, how prevalent these features are in the untyped
% code as well, 

In emperically we have found these to be important idioms, but we will
include an analysis of idioms in typical untyped code.

% and perhaps give a qualitative analysis of
% the kinds of idioms outside the scope of typed clojure.

The major limitations of Typed Clojure are given in 5.2, we found particular

% The numeric data (various percentages, etc.) would be easier to
% follow as some sort of stacked graph or pie chart or some such.
% Then there are reports from two case studies. These reports are not accessible and do not make it easy to compare even the two case studies: there are no tables and numbers are interspersed with the narrative. 

We will change the presentation to be visual.

% The main merit of the paper is that the authors have pulled through the technical essence of TypedRacket (i.e., occurrence typing) and applied it to Clojure. They show how to integrate features particular to Clojure (multimethods and immutable maps) in such a system. 

% I think this is a nice approach to obtain a practical system.

% First, I was enthusiastic about the system.
% However, at the end of the day, the Clojure-specific features does not add much technical innovation to the TypedRacket system. Indeed, the authors note a number of times that the treatment of multimethods falls out more or less for free from occurrence typing. Examining the typing rules shows that much of the typing for multimethods and maps are specialized versions of the occurrence typing rules. 
% Thus, the message I get is that occurrence typing scales to Clojure without having to investigate dramatically new results.

1. showing this approach scales to clojure is a novel contribution
2. we make novel technical contributions by showing how to use occurrence typing
   to handle multimethods, not previously anticipated or understood.
3. the fact that it works out, shows that it's good approach.

The fact we can reuse the mechanism of logical propositions from conditional,
to use  for MM is a STRENGTH, not a weakness.

QUESTION: Is HMap novel relative to TeJas??

% The authors do not pose clear questions at the beginning of the evaluation section, so the direction is never 100% clear. 

% It would be useful to distill some more specific research questions to drive an empirical evaluation with potentially stronger conclusions.

% The hypothesis is a bit weak: that Clojure programs do indeed use the features discussed in this paper.

% How does Typed Clojure integrate into the Clojure compiler?

Typed Clojure can be optionally integrated into the compilation pipeline for. We assume
this while presenting the language for presentational purposes.

% p5r "difference betweem (Val K) and K"
% 
% Is this a general observation or is it specific to K?

General, we are describing the different between the types of class literals and
types of instances of a class. We will change K to an arbitrary C.

% The (Multi ...) type is close to unreadable.

Unfortunately we are unsure how to make multimethod types more readable.

% I was looking for the subtyping Multi <: Fn.

See S-PMultiFn (Figure 8), described Section 3.4, "Subtyping".

% p10 r, Lemma 1
% 
% I was expecting some relation between the \psi+- and the \psi'+-

To aid with the proof, we split this part of the lemma into 4 parts.
The 2nd part talks about \psi+, and the 3rd part only talks about the type, where
we choose any \psi+' that fits.

% p11r Evaluation
% 
% Not conclusive:
% * lists numbers in an unsystematic way
% * does not clearly pose or answer specific research questions
% * my take-home is that TC is implemented and runs on nontrivial code bases. The quality of the typings is unclear. I also would have expected a report of the limitations found during the experiments (e.g., idioms that were not well handled by the typechecker).

% One unanswered practical question is this: how long does the typechecker run?

Typechecking is expensive. <TODO how expensive?>

%   Section 2.3: the notation ':-' is used without introduction,
%   which I'm guessing means "is of type"?

Yes, we will clarify this.

%   Section 2.4. Is the 'Kw' type built-in?

Yes, it is an alias for the Java class clojure.lang.Keyword.

% Page 5, first line: To me, the "its" here is ambiguous: does it refer
% to the control flow, or the occurrence typing?

"occurrence typing automatically understands control flow that combines atomic tests
already understood by occurrence typing."

% Page 5, "Expressions". "All binding forms introduce fresh
% variables". Isn't that a tautology?

We intend the name of the binding to be 'fresh'. Otherwise nested 'let's typed by
T-Let with repeated names will combine in unsound ways.

We will clarify this in the paper.

% Weaknesses
% 
% * The paper could do a better job in isolating the key contributions of the work.

% This paper would be stronger if the critical type system advances could be clearly distilled that are (1) needed for Clojure features but also (2) are somehow more general insights.

% In Section 3, is perhaps too much focus on "what" and not enough "why" to provide context for what is new and novel versus what is standard. 
% As an example of this early in the section, the paragraph about "Objects" is explicit and detailed about its components 
% but not its role in the type system. Is it simply a way to name heap objects as an access path? Or is it something more?

Precisely, yes. The justification will be elaborated, and Section 3 will focus more or the "why".

% Section 3.6 is potentially an important subsection that discusses the symbolic reasoning, but unfortunately it is very terse and is disconnected from the thread of the story.

We will discuss only the important examples in 3.6 in greater detail.
