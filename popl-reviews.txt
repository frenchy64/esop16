We thank the reviewers for their detailed feedback.  We're glad the
reviewers found Typed Clojure to be "an extremely useful
contribution", "a nice approach to obtain a practical system", and
that our approach is "interesting and well illustrated."

The reviewers primary concerns are with two issues:

1. Is the design, implementation, and evaluation of Typed Clojure a
   significant new contribution?

Review B notes "occurrence typing scales to Clojure without having to
investigate dramatically new results", citing this as a disadvantage.

We disagree---the effectiveness of occurrence typing at handling
Clojure idioms is a strength of our design. Furthermore, while the
relationship between occurrence typing and Clojure now seems
intuitive, the full extent of their synthesis was not initially
obvious.

For example, our work uncovers a strong link between occurrence typing
-- a typing mechanism originally designed for local conditionals --
and Clojure's multimethods, an elaborate control-flow mechanism that
includes arbitrary dynamic dispatch. The ability to reuse the logical
reasoning of occurrence typing for multimethods is both novel and
crucial for Typed Clojure's success. Review A describes this as "not
extremely novel", perhaps because occurrence typing already exists. We
argue that the ability to reuse existing technology in unanticipated
ways is often more valuable than whole-cloth reinvention.

Furthermore, Typed Clojure synthesizes occurrence typing and
heterogeneous maps into a subtle (Figure 9 HMap rules) but extremely
compositional result.  As noted by Review A, heterogeneous maps in
this style are not new -- Krishnamurthi et al's (DLS 2013) TeJaS, a
type system for JavaScript supports similar -- however the combination
with occurrence typing produces novel results which are used in
practice in Typed Clojure--see Example 9 for a demonstration..

2. What questions does the evaluation section answer?

Typed Clojure is fortunate to have real-world users, and we are thus
able to evaluate its effectiveness in these settings. We set out to
answer 3 questions:
  (Q1) Is Typed Clojure viable for use in real-world code?
  (Q2) Are the features detailed in the paper needed for typing
  real-world Clojure programs?
  (Q3) What problems do Typed Clojure users encounter?

As the reviews point out, the importance of the evaluation, and the
questions it answers, are not sufficiently clear in the paper; we will
address this in a revised version.

To answer Q1, we demonstrate the utility of our work by checking
thousands of lines of non-trivial code. While the reviews correctly
point out that much of CircleCI's code base is not typed, the portion
that is contains thousands of lines of production code.

To answer Q2, we see that multimethods, heterogenous maps, and Java
interoperability are all widely used in our sample. Even though
multimethods are not defined in the feeds2imap code, they are
called. The small number of multimethods defined in the CircleCI code
may be misleading---the numbers are similar to 11 interfaces in Java,
with 89 concrete implemenations.

Our answer to Q3 is necessarily more subjective, but describes the
limitations that users encountered and future work to address them.


% + feeds2imap doesn't as far as I can tell, use multimethods
%   or particularly fancy HMaps, hence does not provide much
%   evidence about 2,3 above.

Correct, feeds2imap contains no typed or untyped multimethod definitions,
and uses HMaps in standard ways.

% + circleCI is very large (55KLoc)
%   However, even in this large code base, there are only 11 checked multimethods?

The entire CircleCI codebase contains only 41 multimethods. They are used almost exclusively
to dispatch on very general HMap types (in a similar style as Example 8). For example functions that create
and query cloud containers are multimethods dispatching on the container's operating system.

These 11 multimethods account for 89 defmethod expressions, which indicate the polymorphic nature
of these particular multimethods --- averaging 8 defmethods per defmulti.

Why are there only 11 multimethods amongst 1834 functions in typed code?
Functions are used instead in other places where the HMap type is sufficient (ie. no dispatch
is necessary) -- like an internal library for managing SSH keys (a subset is presented as Example 7). 

%   However, only 40% of it is typed, and of that only 20% of the definitions
%   are actually checked? 
%   So only 8% of the definitions are type checked.

This is a good estimation. While correct, 407 top-level definitions are still typed.
CircleCI was gradually porting to Typed Clojure where extra checking was deemed desirable.

We determined difficulty of checking a barrier to checking
the CircleCI code base. This motivates future work on gradual typing, which should
check the remaining invariants at runtime with less difficulty.

%   "The CircleCI code base contains 11 checked multimethods.
%    All 11 dispatch functions are on a HMap key containing a
%    keyword, in a similar style to Example 8. Correspondingly,
%    all 89 methods are associated with a keyword dispatch value."
% 
%   Which 89 methods? I was a bit confused by that sentence here
%   so a clarification would be welcome.

11 multimethods are typed, which contain 89 defmethods.

% At any rate, I was not ready to accept the conclusions drawn
% in the "Lessons" paragraph because multimethods didn't seem
% that pervasive across the whole code base (but yes null is
% everywhere, and so are records/HMaps.) The paper says:
% 
%   "(the features) are used on average more than once per typed function"
% 
% but this could also be because only a small fraction of all functions
% are typed functions?

We feel the ~400 typed functions in CircleCI is significant enough to extrapolate from.
Since they contained ~100 Java interactions and ~300 heterogeneous map usages,

% To strengthen the paper I suggest the authors additionally
% measure, how prevalent these features are in the untyped
% code as well, 

We will include an analysis of idioms in typical untyped code.
Anecdotally, we have found these to be important idioms.

% and perhaps give a qualitative analysis of
% the kinds of idioms outside the scope of typed clojure.

The major limitations of Typed Clojure are given in 5.2, we found particular

% The numeric data (various percentages, etc.) would be easier to
% follow as some sort of stacked graph or pie chart or some such.
% Then there are reports from two case studies. These reports are not accessible and do not make it easy to compare even the two case studies: there are no tables and numbers are interspersed with the narrative. 

We will change the presentation to be visual.

% The hypothesis is a bit weak: that Clojure programs do indeed use the features discussed in this paper.

This is a crucial observation from our experiments. It suggests to us that our effort in design, implementation, and
theory for Java interoperability, heterogeneous maps, and multimethods have a greater pay off than had
we chosen to concentrate on more obscure Clojure idioms.

% How does Typed Clojure integrate into the Clojure compiler?

This is unclear and will be clarified in the prose.

Typed Clojure can be optionally integrated into the compilation pipeline (via nREPL, an extensible REPL).
We assume this setup for presentational purposes --- chiefly to avoid mentioning Clojure "type hints"
which complicate the paper significantly.

% p5r "difference betweem (Val K) and K"
% 
% Is this a general observation or is it specific to K?

We will change K to an arbitrary C.

This is a general observation, we are describing the difference between the types of class literals and
types of instances of a class. 

% The (Multi ...) type is close to unreadable.

Unfortunately we are unsure how to make multimethod types more readable.

% I was looking for the subtyping Multi <: Fn.

Please see S-PMultiFn (Figure 8), described Section 3.4, "Subtyping".
Multimethods are subtypes of their interface types.

% p10 r, Lemma 1
% 
% I was expecting some relation between the \psi+- and the \psi'+-

To aid with the proof, we split this part of the lemma into 4 parts.
The 2nd part talks about \psi+, and the 3rd part only talks about the type, where
we choose any \psi+' that fits.

% Not conclusive:
% * lists numbers in an unsystematic way
% * does not clearly pose or answer specific research questions
% * my take-home is that TC is implemented and runs on nontrivial code bases. The quality of the typings is unclear. I also would have expected a report of the limitations found during the experiments (e.g., idioms that were not well handled by the typechecker).

% One unanswered practical question is this: how long does the typechecker run?

Typechecking is expensive. <TODO how expensive?>

%   Section 2.3: the notation ':-' is used without introduction,
%   which I'm guessing means "is of type"?

Yes, we will clarify this.

%   Section 2.4. Is the 'Kw' type built-in?

Yes, it is an alias for the Java class clojure.lang.Keyword.

% Page 5, first line: To me, the "its" here is ambiguous: does it refer
% to the control flow, or the occurrence typing?

"occurrence typing automatically understands control flow that combines atomic tests
already understood by occurrence typing."

% Page 5, "Expressions". "All binding forms introduce fresh
% variables". Isn't that a tautology?

We intend the name of the binding to be 'fresh'. Otherwise nested 'let's typed by
T-Let with repeated names will combine in unsound ways.

We will clarify this in the paper.

% Weaknesses
% 
% * The paper could do a better job in isolating the key contributions of the work.

% This paper would be stronger if the critical type system advances could be clearly distilled that are (1) needed for Clojure features but also (2) are somehow more general insights.

% In Section 3, is perhaps too much focus on "what" and not enough "why" to provide context for what is new and novel versus what is standard. 
% As an example of this early in the section, the paragraph about "Objects" is explicit and detailed about its components 
% but not its role in the type system. Is it simply a way to name heap objects as an access path? Or is it something more?

Precisely, yes. The justification will be elaborated, and Section 3 will focus more or the "why".

% Section 3.6 is potentially an important subsection that discusses the symbolic reasoning, but unfortunately it is very terse and is disconnected from the thread of the story.

We will discuss only the important examples in 3.6 in greater detail.
