We thank the reviewers for their detailed and thorough feedback.
We are glad the reviewers appeared to enjoy our paper:

"Typed Clojure is undoubtedly an extremely useful contribution" - Review A

"The challenges of optional typing for Clojure is interesting and well illustrated by the paper." - Review D

"this is a nice approach to obtain a practical system." - Review B

Reviewers had concerns with two major issues.

1. Does this work qualify as a significant new contribution?

Our main contribution is the theory, implementation and evaluation of a practical type system for 
Clojure based on occurrence typing.

Review B correctly notes
  "occurrence typing scales to Clojure without having to investigate dramatically new results",
but cites this as a disadvantage.

We believe this is a strong advantage: Typed Clojure is built on strong theoretical foundations.
The relationship between occurrence typing and Clojure now seems intuitive, but the full extent
of their synthesis was non-obvious.

Our work uncovered a strong link between occurrence typing -- a flow typing mechanism originally designed
for local conditials -- and Clojure's multimethods, an elaborate control-flow mechanism that includes
arbitrary dispatch.

We investigated the intersection of flow typing and heterogeneous maps. 
Our result is subtle (Figure 9 HMap rules) but extremely compositional.
As noted by Review A, heterogeneous maps in this style are not new -- Krishnamurthi et al's (DLS 2013) TeJaS, 
a type system for JavaScript supports similar -- however this is the first combined treatment with flow typing.

Review A claims "extending occurrence typing to account for [heterogeneous maps and multimethods]
is not extremely novel".

"the work on multimethods is novel to this setting, and my favorite part of the paper."

but discounts its novelty as 
even though .

Our treatment of multimethods 
  a. cleanly extends occurrence typing 
  b. 

The compositionality of heterogeneous maps with flow typing is best illustrated with 
Example 9, a 

2. What does the evaluation section show?

We demonstrate the utility of our work by checking thousands of lines of non-trivial code.
Some reviewers felt our evaluation lacked direction and analysis.

To clarify, we wanted to answer these questions:
  a. Is our implementation sufficient to type check real Clojure code?

     We 
      
     feeds2imap is an example of a typical Clojure library. It wraps a Java library and uses keyword
     maps to transport data.

  b. How often are the featured idioms used in typed code?


Review A raised concerns on the low numbers of Typed Clojure's key features in the case studies.
As noted by Review A, this did not validate 

The smaller study feeds2imap contains no typed or untyped multimethod definitions

The larger study contains code used from industry.

Two conclusions:
 a. Typing realistic Clojure programs requires all the features we've described.
 b. Typed Clojure is sufficient to scale to some large Clojure code bases, but there
    remain limitations.

% + feeds2imap doesn't as far as I can tell, use multimethods
%   or particularly fancy HMaps, hence does not provide much
%   evidence about 2,3 above.

Correct, feeds2imap contains no typed or untyped multimethod definitions,
and uses HMaps in standard ways.

% + circleCI is very large (55KLoc)
%   However, even in this large code base, there are only 11 checked multimethods?

The entire CircleCI codebase contains only 41 multimethods. They are used almost exclusively
to dispatch on very general HMap types (in a similar style as Example 8). For example functions that create
and query cloud containers are multimethods dispatching on the container's operating system.

These 11 multimethods account for 89 defmethod expressions, which indicate the polymorphic nature
of these particular multimethods --- averaging 8 defmethods per defmulti.

Why are there only 11 multimethods amongst 1834 functions in typed code?
Functions are used instead in other places where the HMap type is sufficient (ie. no dispatch
is necessary) -- like an internal library for managing SSH keys (a subset is presented as Example 7). 

%   However, only 40% of it is typed, and of that only 20% of the definitions
%   are actually checked? 
%   So only 8% of the definitions are type checked.

This is a good estimation. While correct, 407 top-level definitions are still typed.
CircleCI was gradually porting to Typed Clojure where extra checking was deemed desirable.

We determined difficulty of checking a barrier to checking
the CircleCI code base. This motivates future work on gradual typing, which should
check the remaining invariants at runtime with less difficulty.

%   "The CircleCI code base contains 11 checked multimethods.
%    All 11 dispatch functions are on a HMap key containing a
%    keyword, in a similar style to Example 8. Correspondingly,
%    all 89 methods are associated with a keyword dispatch value."
% 
%   Which 89 methods? I was a bit confused by that sentence here
%   so a clarification would be welcome.

11 multimethods are typed, which contain 89 defmethods.

% At any rate, I was not ready to accept the conclusions drawn
% in the "Lessons" paragraph because multimethods didn't seem
% that pervasive across the whole code base (but yes null is
% everywhere, and so are records/HMaps.) The paper says:
% 
%   "(the features) are used on average more than once per typed function"
% 
% but this could also be because only a small fraction of all functions
% are typed functions?

We feel the ~400 typed functions in CircleCI is significant enough to extrapolate from.
Since they contained ~100 Java interactions and ~300 heterogeneous map usages,

% To strengthen the paper I suggest the authors additionally
% measure, how prevalent these features are in the untyped
% code as well, 

We will include an analysis of idioms in typical untyped code.
Anecdotally, we have found these to be important idioms.

% and perhaps give a qualitative analysis of
% the kinds of idioms outside the scope of typed clojure.

The major limitations of Typed Clojure are given in 5.2, we found particular

% The numeric data (various percentages, etc.) would be easier to
% follow as some sort of stacked graph or pie chart or some such.
% Then there are reports from two case studies. These reports are not accessible and do not make it easy to compare even the two case studies: there are no tables and numbers are interspersed with the narrative. 

We will change the presentation to be visual.

% The hypothesis is a bit weak: that Clojure programs do indeed use the features discussed in this paper.

This is a crucial observation from our experiments. It suggests to us that our effort in design, implementation, and
theory for Java interoperability, heterogeneous maps, and multimethods have a greater pay off than had
we chosen to concentrate on more obscure Clojure idioms.

% How does Typed Clojure integrate into the Clojure compiler?

This is unclear and will be clarified in the prose.

Typed Clojure can be optionally integrated into the compilation pipeline (via nREPL, an extensible REPL).
We assume this setup for presentational purposes --- chiefly to avoid mentioning Clojure "type hints"
which complicate the paper significantly.

% p5r "difference betweem (Val K) and K"
% 
% Is this a general observation or is it specific to K?

We will change K to an arbitrary C.

This is a general observation, we are describing the difference between the types of class literals and
types of instances of a class. 

% The (Multi ...) type is close to unreadable.

Unfortunately we are unsure how to make multimethod types more readable.

% I was looking for the subtyping Multi <: Fn.

Please see S-PMultiFn (Figure 8), described Section 3.4, "Subtyping".
Multimethods are subtypes of their interface types.

% p10 r, Lemma 1
% 
% I was expecting some relation between the \psi+- and the \psi'+-

To aid with the proof, we split this part of the lemma into 4 parts.
The 2nd part talks about \psi+, and the 3rd part only talks about the type, where
we choose any \psi+' that fits.

% Not conclusive:
% * lists numbers in an unsystematic way
% * does not clearly pose or answer specific research questions
% * my take-home is that TC is implemented and runs on nontrivial code bases. The quality of the typings is unclear. I also would have expected a report of the limitations found during the experiments (e.g., idioms that were not well handled by the typechecker).

% One unanswered practical question is this: how long does the typechecker run?

Typechecking is expensive. <TODO how expensive?>

%   Section 2.3: the notation ':-' is used without introduction,
%   which I'm guessing means "is of type"?

Yes, we will clarify this.

%   Section 2.4. Is the 'Kw' type built-in?

Yes, it is an alias for the Java class clojure.lang.Keyword.

% Page 5, first line: To me, the "its" here is ambiguous: does it refer
% to the control flow, or the occurrence typing?

"occurrence typing automatically understands control flow that combines atomic tests
already understood by occurrence typing."

% Page 5, "Expressions". "All binding forms introduce fresh
% variables". Isn't that a tautology?

We intend the name of the binding to be 'fresh'. Otherwise nested 'let's typed by
T-Let with repeated names will combine in unsound ways.

We will clarify this in the paper.

% Weaknesses
% 
% * The paper could do a better job in isolating the key contributions of the work.

% This paper would be stronger if the critical type system advances could be clearly distilled that are (1) needed for Clojure features but also (2) are somehow more general insights.

% In Section 3, is perhaps too much focus on "what" and not enough "why" to provide context for what is new and novel versus what is standard. 
% As an example of this early in the section, the paragraph about "Objects" is explicit and detailed about its components 
% but not its role in the type system. Is it simply a way to name heap objects as an access path? Or is it something more?

Precisely, yes. The justification will be elaborated, and Section 3 will focus more or the "why".

% Section 3.6 is potentially an important subsection that discusses the symbolic reasoning, but unfortunately it is very terse and is disconnected from the thread of the story.

We will discuss only the important examples in 3.6 in greater detail.
