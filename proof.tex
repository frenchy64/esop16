\section{Soundness for Typed Clojure}

\begin{lemma}
If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}},
\satisfies{\openv{}}{\propenv{}} and \opsem {\openv{}} {\e{}} {\v{}} then all of the following hold:
\begin{enumerate}
  \item either \object{} = \emptyobject{} or \inopenv {\openv{}} {\object{}} {\v{}},
  \item either \v{} $\not=$ \false\ (or \nil) and {\satisfies{\openv{}}{\thenprop{\prop{}}}} or 
               \v{}     = \false\ (or \nil) and {\satisfies{\openv{}}{\elseprop{\prop{}}}}, and
  \item \judgement{}{\hastype{\v{}}{\t{}}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
        for some \thenprop{\propp{}}, \elseprop{\propp{}} and {\objectp{}}.

\begin{proof}
By induction on the derivation of the typing judgement.

\begin{case}[T-True]
\e{} = \true

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \true\ 
and \thenprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\thenprop{\prop{}}} by M-Top. Part 3 
holds trivially with \t{} = \True via B-True.

\end{case}

\begin{case}[T-False]
\e{} = \false

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \false\ 
and \elseprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\elseprop{\prop{}}} by M-Top. Part 3 
holds trivially with \t{} = \False via B-False.

\end{case}

\begin{case}[T-Nil]
\e{} = \nil

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \nil\ 
and \elseprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\elseprop{\prop{}}} by M-Top. Part 3 
holds trivially with \t{} = \Nil via B-Nil.

\end{case}

\begin{case}[T-Local]
\e{} = \x{}, \object{} = \x{}, \inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}}

Part 1 follows from \inopenv{\openv{}}{\x{}} {\v{}} via B-Local.
Part 2 considers two cases: if \v{} is not \false\ or \nil, then 
\satisfies{\openv{}}{\notprop{\falsy}{\x{}}} holds via M-NotType; if \v{} is \false\ or \nil, then 
\satisfies{\openv{}}{\isprop{\falsy}{\x{}}} holds via M-Type.
Part 3 holds trivially as \x{} reduces directly to \v{} via B-Local.

\end{case}

\begin{case}[T-Do]
\e{} = {\doexp {\e1} {\e2}}

Proving part 1 is trivial: \e{} uses the same object as \e{2} and \e{}
evaluates to the result of \e{2}.
Part 2 follows as the propositions of \e{2} are always used and its
result is always used.
Part 3 is similar as the type of \e{2} is always used.

\end{case}

\begin{case}[T-NewStatic]
  \e{} = {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                                                          {\class{}} {\overrightarrow{\e{i}}}}

Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 requires some explanation. The two false values in Typed Clojure
cannot be constructed with \newliteral, so the only case is \v{} $\not=$ \false\ (or \nil)
where \thenprop{\prop{}} = \topprop{} so \satisfies{\openv{}}{\thenprop{\prop{}}}.
Part 3 holds as B-New reduces to a \emph{non-nilable}
instance of \class{} via \newjavaliteral, and \javatotc{\classhint{}}{\t{}}.
\end{case}

\begin{case}[T-FieldStatic]
  \e{} = {\fieldstaticexp {\classhint{1}} {\classhint{2}} {fld} {\e{}}}

Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \getfieldliteral 
in B-Field, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{case}

\begin{case}[T-MethodStatic]
  \e{} = {\methodstaticexp {\classhint{1}} 
                          {\overrightarrow {\classhint{i}}} 
                          {\classhint{2}}
                          {\mth{}} {\e{}} {\overrightarrow{\e{i}}}}

Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \invokejavamethodliteral 
in B-Method, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.

\end{case}

\end{proof}

\end{enumerate}
\end{lemma}
