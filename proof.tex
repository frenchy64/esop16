\section{Soundness for Typed Clojure}

{\javaassumptionsall{appendix}}

\begin{lemma} \label{appendix:lemma:envagree}
  If \openv{} and \openvp{} agree on \fv{\prop{}}
  and \satisfies{\openv{}}{\prop{}}
  then \satisfies{\openvp{}}{\prop{}}.
\begin{proof}
  Since the relevant parts of \openv{} and \openvp{} agree, the proof follows trivially.
\end{proof}
\end{lemma}

\begin{lemma} \label{appendix:lemma:substfilter}
  If 
  \begin{itemize}
    \item \prop{1} = {\replacefor {\prop{2}} {\object{}} {\x{}}},
    \item
  {\satisfies{\openv{2}}{\prop{2}}},
    \item
  $\forall v \in \fv{\prop{2}} - \x{}$.
                              {\inopenvnoeq{\openv{1}}{v}} = {\inopenvnoeq {\openv{2}}{v}},
    \item
  and {\inopenvnoeq{\openv{2}}{\x{}}} = {\inopenvnoeq{\openv{1}}{\object{}}}
  \end{itemize}
  then \satisfies{\openv{1}}{\prop{1}}.

  \begin{proof}
    By induction on the derivation of the model judgement.
  \end{proof}
\end{lemma}

\begin{lemma} \label{appendix:lemma:satisfies}
  If \satisfies{\openv{}}{\propenv{}} and \inpropenv{\propenv{}}{\prop{}} then \satisfies{\openv{}}{\prop{}}.

  \begin{proof}
    By structural induction on \inpropenv{\propenv{}}{\prop{}}.
%    \begin{itemize}
%      \item[]
%        \begin{case}[L-True]
%
%          Holds by M-Top.
%        \end{case}
%      \item[]
%        \begin{case}[L-False]
%          {\inpropenv{\propenv{}}{\botprop{}}}
%
%          ??? TODO
%        \end{case}
%      \item[]
%        \begin{case}[L-AndI]
%          \inpropenv{\propenv{}}{\andprop{\prop{1}}{\prop{2}}}, \satisfies{\openv{}}{\propenv{}}
%
%          By inversion on the proof system we know \inpropenv{\propenv{}}{\prop{1}}
%          and
%          \inpropenv{\propenv{}}{\prop{2}}.
%
%          By the induction hypothesis we know \satisfies{\openv{}}{\prop{1}}
%          and
%          \satisfies{\openv{}}{\prop{2}}.
%
%          By M-And we know \satisfies{\openv{}}{\andprop{\prop{1}}{\prop{2}}}
%          and we are done.
%        \end{case}
%      \item[]
%        \begin{case}[L-AndE]
%          \inpropenv{\propenv{},{\andprop{\prop{1}}{\prop{2}}}}{\prop{}}, \satisfies{\openv{}}{\propenv{},{\andprop{\prop{1}}{\prop{2}}}}
%
%
%          By inversion on the proof system we know  either
%          \inpropenv{\propenv{},{\prop{1}}}{\prop{}}
%          or
%          \inpropenv{\propenv{},{\prop{2}}}{\prop{}}.
%
%          %TODO
%         % By the induction hypothesis we know 
%         % either
%         % \satisfies{\openv{}}{\prop{1}}
%         % and
%         % \satisfies{\openv{}}{\prop{2}}.
%        \end{case}
%    \end{itemize}
  \end{proof}
\end{lemma}

\begin{lemma} \label{appendix:lemma:goodobjects+ve}
  If \inpropenv{\propenv{}}{\isprop{\t{}}{\path{\pathelem{}}{\x{}}}},
  \satisfies{\openv{}}{\propenv{}}
  and \inopenv{\openv{}}{\path{\pathelem{}}{\x{}}}{\v{}}
  then
  \judgementselfrewrite{}{\v{}}{\t{}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
  for some {\thenprop{\propp{}}}, {\elseprop{\propp{}}} and {\objectp{}}.
  \begin{proof}
    Corollary of lemma~\ref{appendix:lemma:satisfies}.
  \end{proof}
\end{lemma}

\begin{lemma}[Paths are independent] \label{appendix:lemma:pathindependent}
  If \inopenvnoeq{\openv{}}{\object{}} = \inopenvnoeq{\openv{1}}{\objectp{}}
  then \inopenvnoeq{\openv{}}{\path{\pathelem{}}{\object{}}} =
       \inopenvnoeq{\openv{1}}{\path{\pathelem{}}{\objectp{}}}
 \begin{proof}
   By induction on \pathelem{}.
   \begin{case}[\pathelem{} = \emptypath{}]
     \inopenvnoeq{\openv{}}{\object{}} = {\inopenvnoeq{\openv{}}{\objectp{}}}

     As 
     \inopenvnoeq{\openv{}}{\path{\emptypath{}}{\object{}}} = \inopenvnoeq{\openv{}}{\object{}}
     and
     \inopenvnoeq{\openv{}}{\path{\emptypath{}}{\objectp{}}} = \inopenvnoeq{\openv{}}{\objectp{}}
     we can conclude 
     \inopenvnoeq{\openv{}}{\path{\emptypath{}}{\object{}}} = \inopenvnoeq{\openv{}}{\path{\emptypath{}}{\objectp{}}}.
   \end{case}
   \begin{case}[\pathelem{} = {\destructpath{\pesyntax{}}{\pathelem{1}}}]
     \inopenvnoeq{\openv{}}{\object{}} = {\inopenvnoeq{\openv{}}{\objectp{}}}

     By cases on \pesyntax{}.

     \begin{itemize}
       \item[]
   \begin{subcase}[\pesyntax{} = {\keype{\k{}}}] 

%     TODO
     By the induction hypothesis on {\pathelem{1}}
     we know {\inopenvnoeq{\openv{}}{\path{\pathelem{1}}{\object{}}}} =
             {\inopenvnoeq{\openv{1}}{\path{\pathelem{1}}{\objectp{}}}}.
             By the definition of path translation 
             {\inopenvnoeq{\openv{}}{\path{\pathelem{1}}{\object{}}}} = {\getexp {{\openv{}}(\object{})}{\k{}}}
             and 
             {\inopenvnoeq{\openv{}}{\path{\pathelem{1}}{\objectp{}}}} = {\getexp {{\openv{}}(\objectp{})}{\k{}}}
   \end{subcase} 
     \end{itemize}
%     TODO
   \end{case}
 \end{proof}
\end{lemma}

\begin{lemma}[\classconst]\label{appendix:lemma:classconst}
  If
  {\opsem{\openv{}}{\appexp{\classconst{}}{\openv{}({\path{\pathelem{}}{\x{}}})}}{\class{}}} then
  {\satisfies{\openv{}}{\isprop{\class{}}{\path{\pathelem{}}{\x{}}}}}.

  \begin{proof}
    Induction on the definition of {\classconst{}}.
  \end{proof}
\end{lemma}

{\consistentwithdefinition{appendix}}

{\istruefalsedefinitions{appendix}}

\begin{lemma} \label{appendix:lemma:soundness}
{\soundnesslemmahypothesis}
\begin{proof}
By induction on the derivation of the typing judgement.

\begin{case}[T-True]
  \e{} = \true, \t{} = \True, \thenprop{\prop{}} = \topprop{}, \elseprop{\prop{}} = \botprop{}, \object{} = \emptyobject{}

  \begin{itemize}
    \item[] 
      \begin{subcase}[B-Val]
        \v{} = \true{}

        Proving part 1 is trivial: \object{} is \emptyobject. 
        To prove part 2, we note that \v{} = \true\ 
        and \thenprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\thenprop{\prop{}}} by M-Top.
        Part 3 holds as \e{} can only be reduced to itself via B-Val.
        Part 4 holds vacuously.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-HMap] \e{} = {\curlymapvaloverright{\v{k}}{\v{v}}},
  \t{} = {\HMapc {\mandatory{}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}},
  $\overrightarrow{\judgementtwo {} {\v{k}}{\Value \k{}}}$,
  $\overrightarrow{\judgementtwo {} {\v{v}}{\t{v}}}$,
  \mandatory{} = \mandatorysetoverright{\k{}}{\t{v}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\curlymapvaloverright{\v{k}}{\v{v}}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Kw] \e{} = {\k{}},
  \t{} = {\Value{\k{}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\k{}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-False]
\e{} = \false, \t{} = \False, \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{}

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val]
      \v{} = \false{}

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \false\ 
and \elseprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\elseprop{\prop{}}} by M-Top. 
Part 3 holds as \e{} can only be reduced to itself via B-Val.
Part 4 holds vacuously.
\end{subcase}

\end{itemize}
\end{case}

\begin{case}[T-Class] \e{} = {\class{}},
  \t{} = {\Value{\class{}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\class{}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Instance] \e{} = {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}},
  \t{} = {\class{}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{i}} {\v{i}}}}}

        Similar to T-True.

        Part 4 holds by the induction hypothesis on ${\overrightarrow{\v{i}}}$.
      \end{subcase}
  \end{itemize}
\end{case}


\begin{case}[T-Nil]
\e{} = \nil, \t{} = \Nil, \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{},

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val] 
      \v{} = \nil{}

      Similar to T-False.
\end{subcase}

\end{itemize}

\end{case}

\begin{case}[T-Local]
  \e{} = \x{}, \thenprop{\prop{}} = {\notprop {\falsy{}} {\x{}}},
  \elseprop{\prop{}} = {\isprop {\falsy{}} {\x{}}},
\object{} = \x{}, 
\inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}},

\begin{itemize}
  \item[]
\begin{subcase}[B-Local]
{ \inopenv {\openv{}} {\x{}} {\v{}} },
{ \opsem {\openv{}} {\x{}} {\v{}} }

Part 1 follows from \inopenv{\openv{}}{\x{}} {\v{}} by B-Local.

Part 2 considers two cases: if \v{} is not \false\ or \nil, then 
\satisfies{\openv{}}{\notprop{\falsy}{\x{}}} holds by M-NotType; if \v{} is \false\ or \nil, then 
\satisfies{\openv{}}{\isprop{\falsy}{\x{}}} holds by M-Type.

We prove part 3 by observing
\inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}}
and
\satisfies{\openv{}}{\propenv{}},
so
{ \inopenv {\openv{}} {\x{}} {\v{}} }
by B-Local
gives us the desired result.

Part 4 holds vacuously.
\end{subcase}
\end{itemize}

\end{case}

\begin{case}[T-Do]
\e{} = {\doexp {\e1} {\e2}},
  \judgement {\propenv{}} 
             {\e1} {\t1}
             {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop1}}} 
             {\object{1}},
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\e{2}} {\t{}}
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}},

\begin{itemize}
  \item[] \begin{subcase}[B-Do]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\v{}}

For all parts we note 
    since {\e{1}} can be either a true or false value
    then
    {\satisfies{\openv{}}{{\propenv{}},{\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}}
    by M-Or,
    which together with 
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\e{2}} {\t{}}
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}},
    and
  \opsem {\openv{}} {\e{2}} {\v{}}
    allows us to apply the induction hypothesis on \e{2}.

To prove part 1 we use the induction hypothesis on \e{2}
to show either \object{} = \emptyobject{} 
or \inopenv {\openv{}} {\object{}} {\v{}}, since \e{} always
evaluates to the result of \e{2}.

For part 2 we use the induction hypothesis on \e{2}
to show if \v{} $\not=$ \false\ (or \nil) then
        {\satisfies{\openv{}}{\thenprop{\prop{}}}}
        or
  if \v{} = \false\ (or \nil) then
        {\satisfies{\openv{}}{\elseprop{\prop{}}}}.

Parts 3 and 4 follow from the induction hypothesis on \e{2}.
    \end{subcase}
  \item[]

\begin{subcase}[BE-Do1]
  \opsem {\openv{}} {\e{1}} {\errorval{\v{e}}},
  \opsem {\openv{}} {\e{}} {\errorval{\v{}}}

        Trivially reduces to an error.
\end{subcase}
  \item[]
\begin{subcase}[BE-Do2]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\errorvalv{}},
  \opsem {\openv{}} {\e{}} {\errorvalv{}}

        As above.
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-NewStatic]
  \e{} = {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                                                          {\class{}} {\overrightarrow{\e{i}}}},
  \object{} = \emptyobject{},
\thenprop{\prop{}} = \topprop{},
\elseprop{\prop{}} = \botprop{},
   $\overrightarrow{
\javatotc {\classhint{i}}
          {\t{i}}
          }$,
  \javatotc {\classhint{}}
            {\t{}},
            $
  \overrightarrow{
  \judgementtwo {\propenv{}}
                    {\e{i}} {\t{i}}
                  }$

\begin{itemize}
  \item[]
\begin{subcase}[B-New]
  $
  \overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }$,
         $\newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\v{}}$

Part 1 follows \object{} = \emptyobject{}.

Part 2 requires some explanation. The two false values in Typed Clojure
cannot be constructed with \newliteral, so the only case is \v{} $\not=$ \false\ (or \nil)
where \thenprop{\prop{}} = \topprop{} so \satisfies{\openv{}}{\thenprop{\prop{}}}.

Part 3 holds as B-New reduces to a \emph{non-nilable}
instance of \class{} via \newjavaliteral (by assumption~\ref{appendix:assumption:new}), and \javatotc{\classhint{}}{\t{}}.

\end{subcase}
  \item[]

\begin{subcase}[BE-New1] $\overrightarrow{
  \opsem {\openv{}}
         {\e{i-1}}
         {\v{i-1}}
       }$,
  \opsem {\openv{}}
         {\e{i}}
         {\errorvalv{}},
  \opsem {\openv{}} {\e{}} {\errorvalv{}}

        Trivially reduces to an error.

\end{subcase}
  \item[]

\begin{subcase}[BE-New2] 
  $\overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }$,
         \newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\errorvalv{}},
        \opsem {\openv{}} {\e{}} {\errorvalv{}}

        As above.

\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-FieldStatic]
  \e{} = {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{1}}},
  \javatotc {\classhint{1}} {\class{}},
  \javatotcnil {\classhint{2}} {\t{}},
  \judgementtwo {\propenv{}} {\e{1}} {\class{}}

\begin{itemize}
  \item[]
\begin{subcase}[B-Field]
  \opsem {\openv{}}
         {\e{1}} 
         {\classvalue{\classhint{1}} {\classfieldpair{\fld{}} {\v{}}}}


Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \getfieldliteral (assumption~\ref{appendix:assumption:field})
in B-Field, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{subcase}
  \item[]
\begin{subcase}[BE-Field]
  \opsem {\openv{}}
         {\e{1}} 
         {\errorvalv{}},
  \opsem {\openv{}}
         {\e{}}
         {\errorvalv{}}

         Trivially reduces to an error.

\end{subcase}

\end{itemize}
\end{case}

\begin{case}[T-MethodStatic]
  \e{} = ${\methodstaticexp {\classhint{1}} 
                          {\overrightarrow {\classhint{i}}} 
                          {\classhint{2}}
                          {\mth{}} {\e{m}} {\overrightarrow{\e{a}}}}$,
  \thenprop{\prop{}} = \topprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{},
  $\overrightarrow{\javatotc {\classhint{i}} {\t{i}}}$,
             \javatotc {\classhint{1}} {\class{}},
             \javatotcnil {\classhint{2}} {\t{}},
  \judgementtwo {\propenv{}} {\e{m}} {\class{}},
             $\overrightarrow{
  \judgementtwo {\propenv{}} {\e{a}} {\t{a}}
                  }$

\begin{itemize}
  \item[]
\begin{subcase}[B-Method]
  \opsem {\openv{}}
         {\e{m}}
         {\v{m}},
  $\overrightarrow{
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}}$,
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{a}}} {\overrightarrow{\v{a}}}
                    {\classhint{2}}
                    {\v{}}


Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \invokejavamethodliteral (assumption~\ref{appendix:assumption:method})
in B-Method, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{subcase}

  \item[]
\begin{subcase}[BE-Method1]
  \opsem {\openv{}}
         {\e{m}}
         {\errorval{\v{}}},
  \opsem {\openv{}}
         {\e{}}
         {\errorval{\v{}}}

         Trivially reduces to an error.
\end{subcase}
  \item[]
\begin{subcase}[BE-Method2]
  \opsem {\openv{}}
         {\e{m}}
         {\v{m}},
 $\overrightarrow{
  \opsem {\openv{}}
         {\e{n-1}}
         {\v{n-1}}
       }$,
  \opsem {\openv{}}
         {\e{n}}
         {\errorval{\v{}}},
  \opsem {\openv{}}
         {\e{}}
         {\errorval{\v{}}}

  As above.
\end{subcase}
  \item[]
\begin{subcase}[BE-Method3]
  \opsem {\openv{}}
         {\e{m}}
         {\v{m}},
  $\overrightarrow{
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
       }$,
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{a}}} {\overrightarrow{\v{a}}}
                    {\classhint{2}}
                    {\errorvalv{}},
  \opsem {\openv{}} {\e{}} {\errorvalv{}}

  As above.

\end{subcase}
\end{itemize}

\end{case}

\begin{case}[T-DefMulti]
  \e{} = {\createmultiexp {\s{}} {\e{d}}},
  \t{} = {\MultiFntype {\s{}} {\t{d}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \s{} = {\ArrowOne {\x{}} {\t{1}} {\t{2}}
                          {\filterset {\thenprop {\prop{1}}}
                                      {\elseprop {\prop{1}}}}
                          {\object{1}}},
  \t{d} = {\ArrowOne {\x{}} {\t{1}} {\t{3}}
                          {\filterset {\thenprop {\prop{2}}}
                                      {\elseprop {\prop{2}}}}
                          {\object{2}}},
  \judgementtwo {\propenv{}} {\e{d}} {\t{d}}


\begin{itemize}
  \item[]
\begin{subcase}[B-DefMulti]
  \v{} = {\multi {\v{d}} {\emptydisptable}},
  \opsem {\openv{}} {\e{d}} {\v{d}}


Part 1 and 2 hold for the same reasons as T-True.
For part 3 we show \judgementtwo{}{\multi {\v{d}} {\emptydisptable}}{\MultiFntype {\s{}} {\t{d}}}
by T-Multi, since \judgementtwo {} {\v{d}} {\t{d}} by the inductive hypothesis on {\e{d}}
and {\emptydisptable} vacuously satisfies the other premises of T-Multi, so we are done.

\end{subcase}
  \item[]
\begin{subcase}[BE-DefMulti] \opsem {\openv{}} {\e{d}} {\errorvalv{}},
        \opsem {\openv{}} {\e{}} {\errorvalv{}}

        Trivially reduces to an error.

\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-DefMethod]
        \ 

        \begin{enumerate}
          \item
  \e{} = {\extendmultiexp {\e{m}} {\e{v}} {\e{f}}},
          \item
  \e{f} = {\abs {\x{}} {\t{1}} {\e{b}}},
          \item
  \t{} = {\MultiFntype {\t{m}} {\t{d}}},
          \item
  \thenprop{\prop{}} = {\topprop{}},
          \item
  \elseprop{\prop{}} = {\botprop{}},
          \item
  \object{} = {\emptyobject{}},
          \item
  \t{m} = {\ArrowOne {\x{}} {\t{1}} {\s{}}
                     {\filterset {\thenprop {\prop{m}}}
                                 {\elseprop {\prop{m}}}}
                     {\object{m}}},
          \item
  \t{d} = {\ArrowOne {\x{}} {\t{1}} {\sp{}}
                     {\filterset {\thenprop {\prop{d}}}
                                 {\elseprop {\prop{d}}}}
                     {\object{d}}},
          \item
  \judgementtwo {\propenv{}} {\e{m}} {\MultiFntype {\t{m}} {\t{d}}},
          \item
  \isacompare{\sp{}}{\object{d}}{\t{v}}{\filterset {\thenprop {\prop{i}}} {\elseprop {\prop{i}}}},
          \item
  \judgementtwo {\propenv{}}
               {\e{v}} {\t{v}},
          \item
  \judgement {\propenv{}, {\isprop{\t{1}} {\x{}}}, {\thenprop {\prop{i}}}}
           {\e{b}} {\s{}}
           {\filterset {\thenprop {\prop{m}}}
                       {\elseprop {\prop{m}}}}
           {\object{m}}
        \end{enumerate}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-DefMethod]
        \ 
        
        \begin{enumerate}[resume]
          \item
       \v{} = {\multi {\v{d}} {\disptablep{}}},
          \item
        \opsem {\openv{}}
               {\e{m}}
               {\multi {\v{d}} {\disptable{}}},
          \item
  \opsem {\openv{}}
         {\e{v}}
         {\v{v}},
          \item
  \opsem {\openv{}}
         {\e{f}}
         {\v{f}},
          \item
         \disptablep{} = {\extenddisptable {\disptable{}} 
                                {\v{v}}
                                {\v{f}}}
        \end{enumerate}

                                Part 1 and 2 hold for the same reasons as T-True, noting that the propositions
                                and object agree with T-Multi.

For part 3 we show
\judgementtwo{}{\multi {\v{d}} {\extenddisptable {\disptable{}}{\v{v}}{\v{f}}}}{\MultiFntype {\t{m}} {\t{d}}}
by noting \judgementtwo {} {\v{d}} {\t{d}},
  \judgementtwo{}{\v{v}}{\Top{}}
  and
  \judgementtwo{}{\v{f}}{\t{m}}, and since \disptable{} is in the correct form by the inductive
  hypothesis on {\e{m}} we can satisfy all premises of T-Multi, so we are done.


      \end{subcase}

    \item[]
      \begin{subcase}[BE-DefMethod1]
        \opsem {\openv{}}
               {\e{m}}
               {\errorval{\v{}}},
        \opsem {\openv{}}
                  {\e{}}
                {\errorval{\v{}}}

                Trivially reduces to an error.

      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod2]
        \opsem {\openv{}}
         {\e{m}}
         {\multi {\v{d}} {\disptable{}}},
  \opsem {\openv{}}
         {\e{v}}
         {\errorval{\v{}}},
        \opsem {\openv{}}
                  {\e{}}
                {\errorval{\v{}}}

                As above.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod3]
        \opsem {\openv{}}
         {\e{m}}
         {\multi {\v{d}} {\disptable{}}},
  \opsem {\openv{}}
         {\e{v}}
         {\v{v}},
  \opsem {\openv{}}
         {\e{f}}
         {\errorval{\v{}}},
        \opsem {\openv{}}
                  {\e{}}
                {\errorval{\v{}}}

                As above.

      \end{subcase}
  \end{itemize}
\end{case}

      %TODO
\begin{case}[T-App]
  \ 

  \begin{itemize}
    \item
  \e{} = {\appexp {\e{1}} {\e{2}}},
    \item
  \t{} = {\replacefor {\t{f}}
                      {\object{2}}
                      {\x{}}},
    \item
  {\thenprop {\prop{}}} = 
                 {\replacefor {\thenprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
    \item
  {\elseprop {\prop{}}} = 
                 {\replacefor {\elseprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
    \item
  \object{} = {\replacefor {\object{f}}
                           {\object{2}}
                           {\x{}}},
    \item
  \judgement {\propenv{}} {\e{1}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                {\object{1}},
    \item
  \judgement {\propenv{}}
                 {\e{2}} {\s{}}
                 {\filterset {\thenprop {\prop{2}}}
                             {\elseprop {\prop{2}}}}
                 {\object{2}},
  \end{itemize}
%                 IHe1 = $\forall{\openv{1}},
%                               {\v{1}},
%                               {\thenprop {\prop{1}}},
%                               {\elseprop {\prop{1}}},
%                               {\object{1}}.
%                               {\judgement
%                                 {\propenv{}}
%                                 {\hastype
%                                   {\e{1}}
%                                   {\ArrowOne {\x{}} {\s{}}
%                                     {\t{f}}
%                                     {\filterset 
%                                       {\thenprop {\prop{f}}}
%                                       {\elseprop {\prop{f}}}}
%                                     {\object{f}}}}
%                                {\filterset {\thenprop {\prop{1}}}
%                                            {\elseprop {\prop{1}}}}
%                                {\object{1}}}
%\Rightarrow
%                                                       {\satisfies{\openv{1}}{\propenv{}}}
%                                                       \Rightarrow
%  \opsem {\openv{}}
%         {\e{1}}
%         {\v{1}}
%         \Rightarrow
%         (1: \object{1} = \emptyobject{} \vee \inopenv{\openv{1}}{\object{1}}{\v{1}})
%         \wedge
%       (2: (\v{1} \not= \false\ (or\ \nil) \wedge \satisfies{\openv{1}}{\thenprop{\prop{1}}})
%          \vee
%            (\v{1} = \false\ (or\ \nil) \wedge \satisfies{\openv{1}}{\elseprop{\prop{1}}}))
%            \wedge
%          (3: \exists {\thenprop{\propp{1}}},{\elseprop{\propp{1}}},{\objectp{1}}.
%          \judgement{}{\hastype{\v{1}}{\ArrowOne {\x{}} {\s{}}
%                                     {\t{f}}
%                                     {\filterset 
%                                       {\thenprop {\prop{f}}}
%                                       {\elseprop {\prop{f}}}}
%                                   {\object{f}}}}
%                        {\filterset{\thenprop{\propp{1}}}{\elseprop{\propp{1}}}}
%                      {\objectp{1}})
%                                                       $









\begin{itemize}
  \item[]
\begin{subcase}[B-BetaClosure]
  \ 

  \begin{itemize}
    \item
  \opsem{\openv{}}{\e{}}{\v{}},
    \item
  \opsem {\openv{}}
         {\e{1}}
         {\closure {\openv{c}} {\abs {\x{}} {\s{}} {\e{b}}}},
    \item
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}},
    \item
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
         {\e{b}}
         {\v{}}
     \end{itemize}

         By inversion on \e{1} from T-Clos
         there is some environment {\propenvc{}} such that
         \begin{itemize}
           \item
              \satisfies{\openv{c}}{\propenvc{}} and
            \item
  \judgement {\propenvc{}} {\abs {\x{}} {\s{}} {\e{b}}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                {\object{1}},
         \end{itemize}
         and also by inversion on \e{1} from T-Abs
         \begin{itemize}
           \item
  { \judgement {\propenvc{}, {\isprop {\s{}} {\x{}}}}
              {\e{b}} {\t{f}}
               {\filterset {\thenprop {\prop{f}}}
                           {\elseprop {\prop{f}}}}
               {\object{f}}}.
         \end{itemize}

         To prove part 1, we consider cases on the form of \object{f}:

         \begin{itemize}
           \item if \object{f} = \emptyobject{}, then \object{} = \emptyobject{} by substitution,
           \item if \object{f} = {\path {\pathelem{f}} {\x{}}}, 
             we consider cases on the form of \object{2}:
             \begin{itemize}
               \item if \object{2} = \emptyobject{}, then \object{} = \emptyobject{},
               \item otherwise \object{2} = {\path {\pathelem{2}} {\y{}}}, where,
                 because
                \object{} = {\replacefor {\path {\pathelem{f}} {\x{}}}
                                         {\object{2}}
                                         {\x{}}},
                 by substitution
                 \object{} = {\path {\pathelem{f}} {\object{2}}}.
                 To prove \inopenv{\openv{}}{\object{}}{\v{}}
                 we note 
                 \inopenv {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
                          {\x{}}
                          {\v{2}}
                          and 
                 \inopenv{\openv{}}{\object{2}}{\v{2}},
                 which implies 
                 \inopenvnoeq {\extendopenv {\openv{c}} {\x{}} {\v{2}}}{\x{}} = 
                 \inopenvnoeq{\openv{}}{\object{2}},
                 and by applying lemma~\ref{appendix:lemma:pathindependent}
                 we can derive
                 \inopenvnoeq{\openv{}}{\path{\pathelem{f}}{\object{2}}} =
                 \inopenvnoeq{\extendopenv {\openv{c}} {\x{}} {\v{2}}}
                             {\path {\pathelem{f}} {\x{}}}.
                 By the induction hypothesis on {\e{b}}
                 we know
                 \inopenv {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
                          {\path {\pathelem{f}} {\x{}}}
                          {\v{}}
                 so we can conclude
                 \inopenv{\openv{}}{\path{\pathelem{f}}{\object{2}}}{\v{}}.

             \end{itemize}
           \item otherwise \object{f} = {\path {\pathelem{f}} {\y{}}} where $\x{} \not= \y{}$,
             and \object{} = \object{f} by substitution.
             We note \consistentwith{\closure {\openv{c}} {\abs {\x{}} {\s{}} {\e{b}}}}{\openv{}} 
             by the induction hypothesis on {\e{1}},
             so 
             \inopenv{\openv{c}}{\y{}}{\inopenvnoeq{\openv{}}{\y{}}},
           and because {\x{}} $\not=$ {\y{}}
            we also know
             \inopenvnoeq{\extendopenv {\openv{c}} {\x{}} {\v{2}}}{\y{}} = 
             \inopenvnoeq{\openv{}}{\y{}}.

             We apply lemma~\ref{appendix:lemma:pathindependent} with this fact
             to derive
             \inopenvnoeq {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
                          {\path {\pathelem{f}} {\y{}}}
                          = 
             \inopenvnoeq{\openv{}}{\path{\pathelem{f}}{\y{}}},
                      and since
             \inopenv {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
                      {\path {\pathelem{f}} {\y{}}}{\v{}}
                      by the induction hypothesis on \e{b}
                      we can conclude 
                      \inopenv{\openv{}}{\path{\pathelem{f}}{\object{2}}}{\v{}}.
         \end{itemize}


         To prove part 2, we consider both cases:
         \begin{itemize}
           \item if \v{} $\not=$ \false\ (or \nil) then \satisfies{\openv{}}{\thenprop{\prop{}}}.

                              By the induction hypothesis on \e{b}
                              we know
              \satisfies{\extendopenv {\openv{c}} {\x{}} {\v{2}}}
                        {\thenprop {\prop{f}}}.

                        By the induction hypothesis on {\e{1}}
                        we know
\consistentwith{\closure {\openv{c}} {\abs {\x{}} {\s{}} {\e{b}}}}{\openv{}},
so we know $\forall v \in \fv{\thenprop{\prop{}}} - \x{}$,
                              {\inopenvnoeq{\openv{c}}{v}} = {\inopenvnoeq {\openv{}}{v}}.

                              By the induction hypothesis on \e{2} we know {\inopenv {\openv{}}{\object{2}}{\v{2}}}
                              and since {\inopenv {\extendopenv {\openv{c}} {\x{}} {\v{2}}}{\x{}}{\v{2}}}
                              then 
                            \inopenvnoeq{\extendopenv {\openv{c}} {\x{}} {\v{2}}}{\x{}} = \inopenvnoeq{\openv{}}{\object{2}}.

                              Then with the premises
                              \begin{enumerate}
                                \item
  {\thenprop {\prop{}}} =
                 {\replacefor {\thenprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
                            \item
                              \satisfies{\extendopenv {\openv{c}} {\x{}} {\v{2}}}{\thenprop {\prop{f}}},
                            \item
                              $\forall v \in \fv{\thenprop{\prop{}}} - \x{}$.
                              {\inopenvnoeq{\extendopenv {\openv{c}} {\x{}} {\v{2}}}{v}} = {\inopenvnoeq {\openv{}}{v}},
                            \item
                              and
                            \inopenvnoeq{\extendopenv {\openv{c}} {\x{}} {\v{2}}}{\x{}} = \inopenvnoeq{\openv{}}{\object{2}}
                              \end{enumerate}
                              we can apply
                            lemma~\ref{appendix:lemma:substfilter},
                            to derive \satisfies{\openv{}}{\thenprop{\prop{}}}
                            and we are done.
           \item if \v{} $=$ \false\ (or \nil) then \satisfies{\openv{}}{\elseprop{\prop{}}}.

             Like above, but using {\elseprop{\prop{}}} for {\thenprop{\prop{}}} and 
             {\elseprop{\prop{f}}} for {\thenprop{\prop{f}}}.
         \end{itemize}

         For part 3 
         \begin{itemize}
           \item
  \opsem{\openv{}}{\e{}}{\v{}},
           \item
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
         {\e{b}}
         {\v{}},
           \item
  \t{} = {\replacefor {\t{f}}
                      {\object{2}}
                      {\x{}}},
         \end{itemize}
\end{subcase}
  \item[]
\begin{subcase}[B-BetaMulti]
  \ 

  \begin{enumerate}
    \item
  \opsem {\openv{}}
         {\e{1}}
         {\multi {\v{d}} {m}},
    \item
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}},
    \item
  \opsem {\openv{}}
         {\appexp {\v{d}} {\v{2}}}
         {\v{e}},
    \item
  \getmethod {\disptable{}}
             {\v{e}}
             {\v{l}}
             {\v{g}},
    \item
  \opsem {\openv{}}
         {\appexp {\v{g}} {\v{2}}}
         {\v{}},
       \item {\disptable{}} = {\curlymapvaloverright{\v{k}}{\v{v}}}
     \end{enumerate}

     By inversion on \e{1} via T-Multi we know 
     \begin{enumerate}[resume]
       \item
         \judgement{\propenv{}}{\e{1}}{\MultiFntype{\s{t}}{\s{d}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                {\object{1}},
           
         \item \s{t} = {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}},
         \item \s{d} = {\ArrowOne {\x{}} {\s{}}
                                                       {\t{d}}
                                                       {\filterset {\thenprop {\prop{d}}}
                                                                   {\elseprop {\prop{d}}}}
                                                       {\object{d}}},
       \item
         \judgement{}{\v{d}}{\s{d}}
                {\filterset {\thenprop {\prop{3}}}
                            {\elseprop {\prop{3}}}}
                {\object{3}},
              \item
  $\overrightarrow{\judgementtwo{}{\v{k}}{\Top{}}}$, and 
\item
  $\overrightarrow{\judgementtwo{}{\v{v}}{\s{t}}}$.
  \end{enumerate}

  By the inductive hypothesis on \e{2} we know 
  \begin{enumerate}[resume]
    \item \judgementtwo{\propenv{}}{\v{2}}{\s{}}, and
    \item \object{2} = \emptyobject{} or \inopenv{\openv{}}{\object{2}}{\v{2}}.
  \end{enumerate}

  % TODO getmethod has changed to not include {\v{k}}. Need a lemma for the below.
  We know by the definition of \getmethodliteral that
  \begin{enumerate}[resume]
    \item $\{ \v{v} | {\roundpair{\v{k}}{\v{v}}} \in \disptable{} \text{ and } \isaopsem{\v{k}}{\v{e}} = {\true{}} \} = {\roundpair{\v{l}}{\v{g}}}$, so
    \item \isaopsem{\v{l}}{\v{e}} = {\true{}}
  \end{enumerate}

  and because ${\v{g}} \in \{\overrightarrow{\v{v}}\}$
  that 
  \begin{enumerate}[resume]
    \item
  {\judgementtwo{}{\v{g}}{\s{t}}}.
  \end{enumerate}

  For part 1, we note
  \begin{enumerate}[resume]
    \item
  \object{} = {\replacefor {\object{f}}
                           {\object{2}}
                           {\x{}}},
  \end{enumerate}

\end{subcase}
  \item[]
\begin{subcase}[B-Delta]
  \opsem {\openv{}} {\e{1}} {\const{}},
  \opsem {\openv{}} {\e{2}} {\v{2}},
  \constantopsem{\const{}}{\v{2}} = \v{}

  % TODO do I need to prove anything about the argument in the definition
  % of the constant being under \s{}?

  Prove by cases on \const{}.
  \begin{itemize}
    \item[] \begin{subcase}[\const{} = \classconst]
    ${\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}$
                                                       =
  ${\ArrowOne {\x{}} {\Top{}}
                                      {\Union{\nil{}}{\Class{}}}
                                      {\filterset {\topprop{}}
                                                  {\topprop{}}}
                                      {\path {\classpe{}} {\x{}}}}$

    Prove by cases on \v{2}.

        \begin{itemize}
          \item[] \begin{subcase}[\v{2} = \classvalue{\class{}} {\overrightarrow {\classfieldpair{\fld{i}} {\v{i}}}}]
                    \v{} = \class{}

                    To prove part 1, note \object{} = {\replacefor {\object{f}}{\object{2}}{\x{}}} 
                    and \object{f} = {\path {\classpe{}} {\x{}}}.
                    There are two cases defined by substitution: if \object{2} = \emptyobject{} then \object{} = \emptyobject{}
                    and we are done,
                    or if \object{2} = {\path {\pathelem{}} {\xp{}}} then \object{} = 
                    {\path {\classpe{}}{\object{2}}},
                    by the induction hypothesis on \e{2} \inopenv {\openv{}} {\object{2}} {\v{2}}
                    and by the definition of path translation
                    {\openv{}}({\path {\classpe{}} {\object{2}}}) = {\appexp {\classconst{}} {{\openv{}}(\object{2})}},
                    which evaluates to \v{}.

                    Part 2 is trivial since both propositions are \topprop{} by substitution.
                    
                    Part 3 holds because {\judgementtwo{}{\v{2}}{\Class{}}}.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = \class{}] \v{} = \Class{}

              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = \true{}] \v{} = \Boolean{}

              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = \false{}] \v{} = \Boolean{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}] \v{} = \IFn{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\multi {\v{d}} {\disptable{}}}] \v{} = \HMapInstance{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\curlymapvaloverright{\v{1}}{\v{2}}}] \v{} = \Keyword{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\nil{}}] \v{} = \nil{}

             Parts 1 and 2 as above.
                    Part 3 holds because {\judgementtwo{}{\v{2}}{\Nil}}.
                  \end{subcase}
        \end{itemize}
      \end{subcase}
    %\item[]
    %  \begin{subcase}[\const{} = \throwconst]
    %    {\ArrowOne {\x{}} {\s{}}
    %                                                   {\t{f}}
    %                                                   {\filterset {\thenprop {\prop{f}}}
    %                                                               {\elseprop {\prop{f}}}}
    %                                                   {\object{f}}}
    %                                                   =
    %    {\ArrowOne {\x{}} {\Top{}}
    %                                  {\Bot{}}
    %                                  {\filterset {\botprop{}}
    %                                              {\botprop{}}}
    %                                  {\emptyobject{}}}

    %                                  Part 1 is trivial since \object{} = \emptyobject{} after substitution.
    %                                  Part 2 holds vacuously as both propositions are \botprop{} after substitution.
    %                                  Finally part 3 holds since {\judgementtwo{}{\hastype{\errorval{\v{2}}}{\Bot{}}}}.

    %  \end{subcase}
  \end{itemize}

\end{subcase}
  \item[]
\begin{subcase}[BE-Beta1]
\end{subcase}
  \item[]
\begin{subcase}[BE-Beta2]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaClosure]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaMulti1]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaMulti2]
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-IsA]\e{} = {\isaapp {\e{1}} {\e{2}}},
  \t{} = {\Boolean{}},
  \judgement {\propenv{}} {\e{1}} {\t{1}}
             {\filterset {\thenprop {\prop{1}}}
                         {\elseprop {\prop{1}}}}
                       {\object{1}},
  \judgement {\propenv{}} {\e{2}} {\t{2}}
             {\filterset {\thenprop {\prop{2}}}
                         {\elseprop {\prop{2}}}}
                       {\object{2}},
  \isacompare{\t{1}}{\object{1}}{\t{2}}{\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}},
  \object{} = \emptyobject{}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-IsA]
        \opsem {\openv{}} {\e{1}} {\v{1}},
        \opsem {\openv{}} {\e{2}} {\v{2}},
        \isaopsem{\v{1}}{\v{2}} = {\v{}}

        Part 1 holds trivially with \object{} = \emptyobject{}.

        For part 2, we must prove, where 
        \isaopsem{\v{1}}{\v{2}} = {\v{}},
        and
        \isacompare{\t{1}}{\object{1}}{\t{2}}{\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
        that if
        \istrueval{\v{}}
        then {\satisfies{\openv{}}{\thenprop{\prop{}}}}
        or if
        \isfalseval{\v{}}
        then {\satisfies{\openv{}}{\elseprop{\prop{}}}}.

        Prove by cases on the definition of \isaopsemliteral:
        \begin{itemize} % isaopsem
          \item[]
            \begin{subcase}[\isaopsem{\v{}}{\v{}} = {\true{}}, \text{if} \v{} \notequal\ {\class{}}]
              \ 

              \v{1} = \v{2}, \v{1} \notequal\ {\class{}}, \v{2} \notequal\ {\class{}}, \istrueval{\v{}}
              
              Since \istrueval{\v{}} we prove {\satisfies{\openv{}}{\thenprop{\prop{}}}}
              by cases on the definition of \isacompareliteral{}:
              \begin{itemize} % isacompare
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\path{\classpe{}}{\path{\pathelem{}}{\x{}}}}{\Value{\class{}}}
                                 {\filterset{\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}
                                            {\notprop{\class{}}{\path{\pathelem{}}{\x{}}}}}]
                    \ 


                    \object{1} = {\path{\classpe{}}{\path{\pathelem{}}{\x{}}}},
                    \t{2} = {\Value{\class{}}},
                    \thenprop{\prop{}} = {\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}

                    Unreachable by inversion on the typing relation, since \t{2} = {\Value{\class{}}},
                    yet \v{2} \notequal\ {\class{}}.

%                    By inversion on the typing relation, since \classpe{} is the last path element of \object{1}
%                    then \opsem{\openv{}}{\appexp{\classconst{}}{\openv{}({\path{\pathelem{}}{\x{}}})}}{\v{1}}.
%
%                    Since {\v{1}} = {\v{2}} then {\t{1}} = {\t{2}}, and because {\t{2}} = {\Value{\class{}}}
%                    then {\t{1}} = {\Value{\class{}}}.
%
%                    By inversion {\v{1}} = {\class{}}, via T-Class.
%
%                    Since {\opsem{\openv{}}{\appexp{\classconst{}}{\openv{}({\path{\pathelem{}}{\x{}}})}}{\class{}}}
%                    we conclude by lemma~\ref{appendix:lemma:classconst}
%                    with {\satisfies{\openv{}}{\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}}.

                  \end{subcase}
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\object{}}{\Value{\singletonmeta{}}}
                    {\replacefor
                      {\filtersetparen{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                        {\notprop{\Value{\singletonmeta{}}}{\x{}}}}
                      {\object{}}
                      {\x{}}}\ 
                    \text{if}\ {\singletonmeta{}} \notequal \class{}]
                    \ 

                    \t{2} = {\Value{\singletonmeta{}}}, 
                    {\singletonmeta{}} \notequal \class{},
                    \thenprop{\prop{}} = {\replacefor{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                                           {\object{1}}
                                           {\x{}}}
                    %\elseprop{\prop{}} = {\replacefor{\notprop{\Value{\singletonmeta{}}} {\x{}}}
                    %                       {\object{1}}
                    %                       {\x{}}}

                    Since \t{2} = {\Value{\singletonmeta{}}} where {\singletonmeta{}} \notequal \class{},
                    by inversion on the typing judgement 
                    {\v{2}} is either \true{}, \false{}, \nil{} or \k{}
                    by T-True, T-False, T-Nil or T-Kw.

                    Since \v{1} = {\v{2}} then \t{1} = \t{2}, and since \t{2} = {\Value{\singletonmeta{}}}
                      then \t{1} = {\Value{\singletonmeta{}}}, so
                    \judgementtwo {} {\v{1}} {\Value{\singletonmeta{}}}

                    If \object{1} = \emptyobject{} then \thenprop{\prop{}} = \topprop{} and
                    we derive
                    {\satisfies{\openv{}}{\topprop{}}} with M-Top.

                    Otherwise \object{1} = \path{\pathelem{}}{\x{}} and \thenprop{\prop{}} =
                    {\isprop{\Value{\singletonmeta{}}}{\path{\pathelem{}}{\x{}}}},
                    and since
                    \judgementtwo {} {\v{1}} {\Value{\singletonmeta{}}}
                    then
                    \judgementtwo {} {{\openv{}}(\path{\pathelem{}}{\x{}})} {\Value{\singletonmeta{}}},
                    which we can use M-Type to derive
                    {\satisfies{\openv{}}{\isprop{\Value{\singletonmeta{}}}{\path{\pathelem{}}{\x{}}}}}.
                  \end{subcase}
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\object{}}{\t{}} {\filterset{\topprop{}} {\topprop{}}}]
                    \ 

                    {\thenprop{\prop{}}} = {\topprop{}}

                    {\satisfies{\openv{}}{\topprop{}}} holds by M-Top.

                  \end{subcase}
              \end{itemize}
            \end{subcase}
          \item[]
            \begin{subcase}[\isaopsem{\class{1}}{\class{2}} = {\true{}}, \text{if}\ \issubtypein{}{\class{1}}{\class{2}}]
              \ 

              \v{1} = \class{1}, \v{2} = \class{2},
              \issubtypein{}{\class{1}}{\class{2}},
              \istrueval{\v{}}
              
              Since \istrueval{\v{}} we prove {\satisfies{\openv{}}{\thenprop{\prop{}}}}
              by cases on the definition of \isacompareliteral{}:
              \begin{itemize} % isacompare
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\path{\classpe{}}{\path{\pathelem{}}{\x{}}}}{\Value{\class{}}}
                                 {\filterset{\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}
                                            {\notprop{\class{}}{\path{\pathelem{}}{\x{}}}}}]
                    \ 


                    \object{1} = {\path{\classpe{}}{\path{\pathelem{}}{\x{}}}},
                    \t{2} = {\Value{\class{2}}},
                    \thenprop{\prop{}} = {\isprop{\class{2}} {\path{\pathelem{}}{\x{}}}}

                    By inversion on the typing relation, since \classpe{} is the last path element of \object{1}
                    then \opsem{\openv{}}{\appexp{\classconst{}}{\openv{}({\path{\pathelem{}}{\x{}}})}}{\v{1}}.

                    Since {\opsem{\openv{}}{\appexp{\classconst{}}{\openv{}({\path{\pathelem{}}{\x{}}})}}{\class{1}}},
                    as {\v{1}} = {\class{1}},
                    we can derive from lemma~\ref{appendix:lemma:classconst}
                    {\satisfies{\openv{}}{\isprop{\class{1}} {\path{\pathelem{}}{\x{}}}}}.

                    By the induction hypothesis we can derive 
                    {\inpropenv{\propenv{}}{\isprop{\class{1}} {\path{\pathelem{}}{\x{}}}}},
                    and with the fact {\issubtypein{}{\class{1}}{\class{2}}}
                    we can use L-Sub to conclude 
                    {\inpropenv{\propenv{}}{\isprop{\class{2}} {\path{\pathelem{}}{\x{}}}}},
                    and finally by lemma~\ref{appendix:lemma:satisfies}
                    we derive
                    {\satisfies{\openv{}}{\isprop{\class{2}} {\path{\pathelem{}}{\x{}}}}}.

                  \end{subcase}
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\object{}}{\Value{\singletonmeta{}}}
                    {\replacefor
                      {\filtersetparen{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                        {\notprop{\Value{\singletonmeta{}}}{\x{}}}}
                      {\object{}}
                      {\x{}}}\ 
                    \text{if}\ {\singletonmeta{}} \notequal \class{}]
                    \ 

                    \t{2} = {\Value{\singletonmeta{}}}, 
                    {\singletonmeta{}} \notequal \class{},
                    \thenprop{\prop{}} = {\replacefor{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                                           {\object{1}}
                                           {\x{}}}

                    Unreachable case since 
                    \t{2} = {\Value{\singletonmeta{}}} where 
                    {\singletonmeta{}} \notequal \class{},
                    but \v{2} = \class{2}.
                  \end{subcase}
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\object{}}{\t{}} {\filterset{\topprop{}} {\topprop{}}}]
                    \ 

                    {\thenprop{\prop{}}} = {\topprop{}}

                    {\satisfies{\openv{}}{\topprop{}}} holds by M-Top.

                  \end{subcase}
              \end{itemize}
            \end{subcase}
          \item[]
            \begin{subcase}[\isaopsem{\v{1}}{\v{2}} = {\false{}}, otherwise]
              \ 

              \v{1} \notequal\ \v{2},
              \isfalseval{\v{}}
              
              Since \isfalseval{\v{}} we prove {\satisfies{\openv{}}{\elseprop{\prop{}}}}
              by cases on the definition of \isacompareliteral{}:
              \begin{itemize} % isacompare
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\path{\classpe{}}{\path{\pathelem{}}{\x{}}}}{\Value{\class{}}}
                                 {\filterset{\isprop{\class{}} {\path{\pathelem{}}{\x{}}}}
                                            {\notprop{\class{}}{\path{\pathelem{}}{\x{}}}}}]
                    \ 


                    \object{1} = {\path{\classpe{}}{\path{\pathelem{}}{\x{}}}},
                    \t{2} = {\Value{\class{}}},
                    \elseprop{\prop{}} = {\notprop{\class{}} {\path{\pathelem{}}{\x{}}}}

                    By inversion on the typing relation, since \classpe{} is the last path element of \object{1}
                    then \opsem{\openv{}}{\appexp{\classconst{}}{\openv{}({\path{\pathelem{}}{\x{}}})}}{\v{1}}.
                    
                    By the definition of {\classconst{}} either {\v{1}} = {\class{}} or {\v{1}} = \nil{}.

                    If {\v{1}} = \nil{}, then we know from the definition of \isaopsemliteral that 
                    {\openv{}({\path{\pathelem{}}{\x{}}})} = \nil{}.

                    Since \judgementtwo{}{\openv{}({\path{\pathelem{}}{\x{}}})}{\Nil},
                    and there is no \v{1} such that both \judgementtwo{}{\openv{}({\path{\pathelem{}}{\x{}}})}{\class} and
                    \judgementtwo{}{\openv{}({\path{\pathelem{}}{\x{}}})}{\Nil{}},
                    we use M-NotType to derive 
                    \satisfies{\openv{}}{\notprop{\class{}} {\path{\pathelem{}}{\x{}}}}.

                    Similarly if {\v{1}} = \class{1}, by the definition of \isacompareliteral
                    we know {\notsubtypein{}{\class{1}}{\class{}}} and 
                    {\openv{}({\path{\pathelem{}}{\x{}}})} = \class{1}.

                    Since \judgementtwo{}{\openv{}({\path{\pathelem{}}{\x{}}})}{\class{1}},
                    and there is no \v{1} such that both 
                    \judgementtwo{}{\v{1}}{\class{}} and
                    \judgementtwo{}{\v{1}}{\class{1}},
                    we use M-NotType to derive 
                    \satisfies{\openv{}}{\notprop{\class{}} {\path{\pathelem{}}{\x{}}}}.


                  \end{subcase}
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\object{}}{\Value{\singletonmeta{}}}
                    {\replacefor
                      {\filtersetparen{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                        {\notprop{\Value{\singletonmeta{}}}{\x{}}}}
                      {\object{}}
                      {\x{}}}\ 
                    \text{if}\ {\singletonmeta{}} \notequal \class{}]
                    \ 

                    \t{2} = {\Value{\singletonmeta{}}}, 
                    {\singletonmeta{}} \notequal \class{},
                    %\thenprop{\prop{}} = {\replacefor{\isprop{\Value{\singletonmeta{}}} {\x{}}}
                    %                       {\object{1}}
                    %                       {\x{}}}
                    \elseprop{\prop{}} = {\replacefor{\notprop{\Value{\singletonmeta{}}} {\x{}}}
                                           {\object{1}}
                                           {\x{}}}

                    Since \t{2} = {\Value{\singletonmeta{}}} where {\singletonmeta{}} \notequal \class{},
                    by inversion on the typing judgement 
                    {\v{2}} is either \true{}, \false{}, \nil{} or \k{}
                    by T-True, T-False, T-Nil or T-Kw.

                    If \object{1} = \emptyobject{} then \elseprop{\prop{}} = \topprop{} and
                    we derive
                    {\satisfies{\openv{}}{\topprop{}}} with M-Top.

                    Otherwise \object{1} = \path{\pathelem{}}{\x{}} and \elseprop{\prop{}} =
                    {\notprop{\Value{\singletonmeta{}}}{\path{\pathelem{}}{\x{}}}}.
                    Noting that \v{1} \notequal\ \v{2},
                    we know \judgementtwo{}{\openv{}({\path{\pathelem{}}{\x{}}})}{\s{}}
                    where \s{} \notequal\ {\Value{\singletonmeta{}}},
                    and there is no \v{1} such that both 
                    \judgementtwo{}{\v{1}}{\Value{\singletonmeta{}}} and
                    \judgementtwo{}{\v{1}}{\s{}}
                    so we can use M-NotType to derive
                    {\satisfies{\openv{}}{\notprop{\Value{\singletonmeta{}}}{\path{\pathelem{}}{\x{}}}}}.
                  \end{subcase}
                \item[]
                  \begin{subcase}[\isacompare{\s{}}{\object{}}{\t{}} {\filterset{\topprop{}} {\topprop{}}}]
                    \ 

                    {\elseprop{\prop{}}} = {\topprop{}}

                    {\satisfies{\openv{}}{\topprop{}}} holds by M-Top.

                  \end{subcase}
              \end{itemize}
            \end{subcase}
        \end{itemize}

        Part 3 holds because by the definition of \isaopsemliteral
        \v{} can only be \true\ or \false, 
        and since \judgementtwo{\propenv{}}{\true}{\t{}}
        and
        \judgementtwo{\propenv{}}{\false}{\t{}}
        we are done.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-IsA1]
        \opsem {\openv{}} {\e{1}} {\errorvalv{}}

        Trivially reduces to an error.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-IsA2]
       \opsem {\openv{}} {\e{1}} {\v{1}},
       \opsem {\openv{}} {\e{2}} {\errorvalv{}}

        Trivially reduces to an error.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMap]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  $\t{} = {\Unionsplice {\overrightarrow {\t{i}}}}$
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  $\judgementtwo {\propenv{}} {\e{k}} {\Value {k}}$,
  $\judgement {\propenv{}} {\e{m}} {\Unionsplice {\overrightarrow {\HMapgeneric {\mandatory{}} {\absent{}}}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}}$,
  $\overrightarrow{\inmandatory{\k{}}{\t{i}}{\mandatory{}}}$


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
      $\opsem {\openv{}} {\e{m}}{\v{m}}$,
        $\v{m} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \opsem {\openv{}} {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

         To prove part 1 we consider two cases on the form of \object{m}: 
         \begin{itemize}
           \item
         if {\object{m}} = \emptyobject{}
         then \object{} = \emptyobject{} by substitution, which gives the desired result;
           \item
         if \object{m} = {\path {\pathelem{m}} {\x{m}}}
         then \object{} = {\path {\keype{k}} {\object{m}}} by substitution.
         We note by the definition of path translation
         {\openv{}}({\path {\keype{k}} {\object{m}}}) =
         {\getexp {{\openv{}}(\object{m})}{\k{}}}
         and by the induction hypothesis on \e{m}
         {{\openv{}}(\object{m})} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
         which together imply 
         \inopenv {\openv{}} {\object{}} {\getexp {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}}}.
         Since this is the same form as B-Get, we can apply the premise
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}
         to derive \inopenv {\openv{}} {\object{}} {\v{}}.
         \end{itemize}
         
         Part 2 holds trivially as \thenprop{\prop{}} = {\topprop{}}
         and \elseprop{\prop{}} = {\topprop{}}.

         To prove part 3 we note that (by the induction hypothesis on \e{m})
         $\judgementtwo{}{\v{m}}{\Unionsplice{\overrightarrow {\HMapgeneric {\mandatory{}} {\absent{}}}}}$,
         where $\overrightarrow{\inmandatory{\k{}}{\t{i}}{\mandatory{}}}$, and 
         both
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
         and
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}
         imply \judgementtwo{}{\v{}}{\Unionsplice {\overrightarrow {\t{i}}}}.

      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

       Unreachable subcase because 
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
       contradicts ${\inmandatory{\k{}}{\t{}}{\mandatory{}}}$.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMapAbsent]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \t{} = \Nil,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  \judgementtwo {\propenv{}} {\e{k}} {\Value {k}},
  \judgement {\propenv{}} {\e{m}} {\HMapgeneric {\mandatory{}} {\absent}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}},
  {\inabsent{\k{}}{\absent{}}}


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}} {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

       Unreachable subcase because 
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         contradicts
                {\inabsent{\k{}}{\absent{}}}.
      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

         To prove part 1 we consider two cases on the form of \object{m}: 
         \begin{itemize}
           \item
         if {\object{m}} = \emptyobject{}
         then \object{} = \emptyobject{} by substitution, which gives the desired result;
           \item
         if \object{m} = {\path {\pathelem{m}} {\x{m}}}
         then \object{} = {\path {\keype{k}} {\object{m}}} by substitution.
         We note by the definition of path translation
         {\openv{}}({\path {\keype{k}} {\object{m}}}) =
         {\getexp {{\openv{}}(\object{m})}{\k{}}}
         and by the induction hypothesis on \e{m}
         {{\openv{}}(\object{m})} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
         which together imply 
         \inopenv {\openv{}} {\object{}} {\getexp {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}}}.
         Since this is the same form as B-GetMissing, we can apply the premise
        \v{} = \nil\ 
         to derive \inopenv {\openv{}} {\object{}} {\v{}}.
         \end{itemize}
         
         Part 2 holds trivially as \thenprop{\prop{}} = {\topprop{}}
         and \elseprop{\prop{}} = {\topprop{}}.
         To prove part 3 we note that \e{m} has type {\HMapgeneric {\mandatory{}} {\absent{}}}
         where {\inabsent{\k{}}{\absent{}}}, and
         the premises of B-GetMissing
         \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
         and
          \v{} = \nil\ 
         tell us {\v{}} must be of type {\t{}}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMapPartialDefault]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \t{} = \Top,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  \judgementtwo {\propenv{}} {\e{k}} {\Value {k}},
 \judgement {\propenv{}} {\e{m}} {\HMapp {\mandatory{}} {\absent}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}},
             ${\notinmandatory{\k{}}{\t{}}{\mandatory{}}}$,
             {\notinabsent{\k{}}{\absent{}}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}}
                 {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

         Parts 1 and 2 are the same as the B-Get subcase of T-GetHMap.
         Part 3 is trivial as \t{} = \Top.


      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

         Parts 1 and 2 are the same as the B-GetMissing subcase of T-GetHMapAbsent.
         Part 3 is trivial as \t{} = \Top.

      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-AssocHMap]
  \e{} = {\assocexp {\e{m}} {\e{k}} {\e{v}}},
  \t{} = ${\HMapgeneric {\extendmandatoryset {\mandatory{}}{\k{}}{\t{}}} {\absent}}$,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = \emptyobject,
  \judgementtwo {\propenv{}} {\e{m}} {\HMapgeneric {\mandatory{}} {\absent}},
  \judgementtwo {\propenv{}} {\e{k}} {\Value{\k{}}},
  \judgementtwo {\propenv{}} {\e{v}} {\t{}},
  {\k{}} $\not\in$ {\absent{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Assoc]
        \v{} = 
        {\extendmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
                {\k{}}{\v{v}}},
        \opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
        \opsem {\openv{}} {\e{k}} {\k{}},
        \opsem {\openv{}} {\e{v}} {\v{v}}

        Parts 1 and 2 hold for the same reasons as T-True.
        %TODO part 3
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc2]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc3]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-If] \e{} = {\ifexp {\e1} {\e2} {\e3}},
  \judgement {\propenv{}} {\e1} {\t{1}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
                 {\object{1}},
  \judgement {\propenv{}, {\thenprop {\prop{1}}}}
                 {\e2} {\t{}} {\filterset {\thenprop {\prop{2}}} {\elseprop {\prop{2}}}}
                 {\object{}},
  \judgement {\propenv{}, {\elseprop {\prop{1}}}}
                 {\e3} {\t{}} {\filterset {\thenprop {\prop{3}}} {\elseprop {\prop{3}}}}
                 {\object{}},
  \thenprop{\prop{}} = {\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}},
  \elseprop{\prop{}} = {\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-IfTrue]
        \opsem {\openv{}} {\e{1}} {\v{1}},
              ${\v{1}} \not= {\false}$,
              ${\v{1}} \not= {\nil}$,
              \opsem {\openv{}} {\e{2}} {\v{}}

              For part 1, either \object{} = \emptyobject{}, or \e{} evaluates to the
              result of \e{2}.

              To prove part 2, we consider two cases:
              \begin{itemize}
                \item if \v{} = \false\ (or \nil)
                  then \e{2} evaluates to a false value so {\satisfies{\openv{}}{\elseprop {\prop{2}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}} by M-Or, 
                \item otherwise
                  ${\v{}} \not= {\false}$ and
                  ${\v{}} \not= {\nil}$,
                  so \e{2} evaluates to a true value so {\satisfies{\openv{}}{\thenprop {\prop{2}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}}} by M-Or.
              \end{itemize}

              Part 3 is trivial as
              \opsem {\openv{}} {\e{2}} {\v{}}
              and {\judgementtwo{}{\v{}}{\t{}}} by the induction hypothesis on {\e{2}}.


      \end{subcase}
    \item[]
      \begin{subcase}[B-IfFalse]
        \opsem {\openv{}} {\e{1}} {\false}
        \ \ \text{or}\ \ 
        \opsem {\openv{}} {\e{1}} {\nil},
        \opsem {\openv{}} {\e{3}} {\v{}}

              For part 1, either \object{} = \emptyobject{}, or \e{} evaluates to the
              result of \e{3}.

              To prove part 2, we consider two cases:
              \begin{itemize}
                \item if \v{} = \false\ (or \nil)
                  then \e{3} evaluates to a false value so {\satisfies{\openv{}}{\elseprop {\prop{3}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}} by M-Or, 
                \item otherwise
                  ${\v{}} \not= {\false}$ and
                  ${\v{}} \not= {\nil}$,
                  so \e{3} evaluates to a true value so {\satisfies{\openv{}}{\thenprop {\prop{3}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}}} by M-Or.
              \end{itemize}

              Part 3 is trivial as
              \opsem {\openv{}} {\e{3}} {\v{}}
              and {\judgementtwo{}{\v{}}{\t{}}} by the induction hypothesis on {\e{3}}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-If]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Let]
  \e{} = {\letexp {\x{}} {\e{1}} {\e{2}}},
  \judgement {\propenv{}} {\e{1}} {\s{}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
             {\object{1}},
             \propp{} = {\impprop {\notprop {\falsy{}} {\x{}}} {\thenprop {\prop{1}}}},
             \proppp{} = {\impprop {\isprop {\falsy{}} {\x{}}} {\elseprop {\prop{1}}}},
  \judgement
       {\propenv{}, {\isprop {\s{}} {\x{}}},
         {\propp{}},
         {\proppp{}}}
             {\e{2}} {\t{}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\object{}} 


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Let]
        \opsem {\openv{}} {\e{1}} {\v{1}},
        \opsem {\extendopenv{\openv{}}{\x{}}{\v{1}}} {\e{2}} {\v{}}

        For all the following cases (with a reminder that \x{} is fresh)
        we apply the induction hypothesis on \e{2}. We justify this by noting
        that occurrences of \x{} inside \e{2} have the same type as \e{1} and 
        simulate the propositions of \e{1}
        because 
        \opsem {\openv{}} {\e{1}} {\v{1}},
        and
        \opsem {\extendopenv{\openv{}}{\x{}}{\v{1}}} {\e{2}} {\v{}},
        so \satisfies{\openv{}}{\propenv{}, {\isprop {\s{}} {\x{}}}, \propp{}, \proppp{}},
        by M-And.

        We prove parts 1, 2 and 3 by directly using the induction hypothesis on \e{2}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Let]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Clos] \e{} = {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}},
  {\thenprop {\prop{}}}
  $\exists {\propenvp{}}. \satisfies{\openv{}}{\propenvp{}}$
  \ \text{and}\ 
\judgement {\propenvp{}} {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}
                 {\filterset {\thenprop {\prop{}}}
                             {\elseprop {\prop{}}}}
                 {\object{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Abs] \v{} = {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}

        We assume some \propenvp{}, such that
        \begin{itemize}
          \item \satisfies{\openv{}}{\propenvp{}}
          \item \judgement {\propenvp{}} {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}
                           {\filterset {\thenprop {\prop{}}}
                                       {\elseprop {\prop{}}}}
                           {\object{}}.
       \end{itemize}
       Note the last rule in the derivation of
          \judgement {\propenvp{}} {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}
                           {\filterset {\thenprop {\prop{}}}
                                       {\elseprop {\prop{}}}}
                           {\object{}}
                           must be T-Abs, so 
                           {\thenprop {\prop{}}} = {\topprop{}},
                           {\elseprop {\prop{}}} = {\botprop{}}
                           and {\object{}} = {\emptyobject{}}.
         Thus parts 1 and 2 hold for the same reasons as T-True.
         Part 3 holds as \v{} has the same type as {\abs {\x{}} {\s{}} {\e{1}}}
         under \propenvp{}.

      \end{subcase} 
  \end{itemize}
\end{case}

\begin{case}[T-Multi] \e{} = {\multi {\v{1}} {\curlymapvaloverright{\v{k}}{\v{v}}}},
  \t{} = {\MultiFntype {\s{}} {\t{1}}},
  {\thenprop {\prop{}}} = {\topprop{}},
  {\elseprop{\prop{}}} = {\botprop{}},
  {\object{}} = {\emptyobject{}},
  \judgementtwo {} {\v{1}} {\t{1}},
  $\overrightarrow{\judgementtwo{}{\v{k}}{\Top{}}}$,
  $\overrightarrow{\judgementtwo{}{\v{v}}{\s{}}}$

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\multi {\v{1}} {\curlymapvaloverright{\v{k}}{\v{v}}}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}

\end{case}

\begin{case}[T-Abs] \e{} = {\abs {\x{}} {\s{}} {\e{1}}},
  \t{} = {\ArrowOne {\x{}} {\s{}}
                                                      {\t{1}}
                                                      {\filterset {\thenprop {\prop{1}}}
                                                                  {\elseprop {\prop{1}}}}
                                                      {\object{1}}},
  {\thenprop{\prop{}}}= {\topprop{}},
  {\elseprop{\prop{}}}= {\botprop{}},
  {\object{}}= {\emptyobject{}},
{ \judgement {\propenv{}, {\isprop {\s{}} {\x{}}}}
            {\e{1}} {\t{}}
             {\filterset {\thenprop {\prop{1}}}
                         {\elseprop {\prop{1}}}}
             {\object{1}}},
\judgement {\propenv{}} {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}
                 {\filterset {\thenprop {\prop{}}}
                             {\elseprop {\prop{}}}}
                 {\object{}}

  \begin{itemize}
    \item[]
      %TODO
      \begin{subcase}[B-Abs]
        \v{} = ${\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}$,
          { \opsem {\openv{}}
                   {\abs {\x{}} {\t{}} {\e{1}}}
                   {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}}

        Parts 1 and 2 hold for the same reasons as T-True.
        Part 3 holds directly via T-Clos, since \v{} must be a closure.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Error]
  \e{} = \errorval{\v{1}},
  \t{} = \Bot,
  \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \botprop{}, \object{} = \emptyobject{}


  \begin{itemize}
    \item[]
      \begin{subcase}[BE-Error] 
        \opsem {\openv{}} {\e{}} {\errorval{\v{1}}}

        Trivially reduces to an error.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Subsume]
  \judgement {\propenv{}} {\e{}} {\tp{}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
             {\objectp{}},
\inpropenv {\propenv{}, {\thenprop {\propp{}}}} {\thenprop {\prop{}}},
\inpropenv {\propenv{}, {\elseprop {\propp{}}}} {\elseprop {\prop{}}},
\inpropenv {} {\issubtype {\tp{}} {\t{}}},
\inpropenv {} {\issubtype {\objectp{}} {\object{}}}

Part 1 holds because \objectp{} is the object of \e{}
and \inpropenv {} {\issubtype {\objectp{}} {\object{}}}.
Part 2 holds because 
the then and else propositions of \e{} are
{\thenprop {\propp{}}} and 
{\elseprop {\propp{}}} respectively, so
{\thenprop {\prop{}}} and
{\elseprop {\prop{}}} are also respectively as 
\inpropenv {\propenv{}, {\thenprop {\propp{}}}} {\thenprop {\prop{}}} and
\inpropenv {\propenv{}, {\elseprop {\propp{}}}} {\elseprop {\prop{}}}.
Part 3 holds because \e{} is of type \tp{} and 
\inpropenv {} {\issubtype {\tp{}} {\t{}}}.

\end{case}

\begin{case}[T-Const]\e{} = {\const{}},
  \t{} = {\constanttype{\const{}}},
{\thenprop{\prop{}}} = {\topprop{}},
{\elseprop{\prop{}}} = {\botprop{}},
{\object{}} = {\emptyobject{}}

  \begin{itemize}
    \item[] 
      \begin{subcase}[B-Val]
        Parts 1, 2 and 3 hold for the same reasons as T-True. 
      \end{subcase}
  \end{itemize}
\end{case}

\end{proof}

\end{lemma}

{\wrongtheorem{appendix}}

{\soundnesstheorem{appendix}}

\begin{theorem}[\nil{} cannot be accidentally introduced] \label{appendix:theorem:nullpointer}
If \judgement{\propenv{}}{\v{}}{\t{}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}
and \notsubtypein{}{\Nil{}}{\t{}}
then {\v{}} $\not=$ \nil{}.
\begin{proof}
  Corollary of lemma~\ref{appendix:lemma:soundness}.
\end{proof}

\end{theorem}

\begin{lemma}[Field lookup never fails] \label{appendix:lemma:fieldgood}
  %If \judgement{\propenv{}}{\hastype{\

\begin{proof}
  Corollary of lemma~\ref{appendix:lemma:soundness}.
\end{proof}

\end{lemma}

\begin{theorem}[Field lookup on \nil{} is disallowed] \label{appendix:theorem:fieldnil}

\begin{proof}
  Corollary of lemma~\ref{appendix:lemma:fieldgood}.
\end{proof}

\end{theorem}

\begin{theorem}[Method invocation on \nil{} is disallowed] \label{appendix:theorem:methodnil}

\begin{proof}
  Corollary of lemma~\ref{appendix:lemma:soundness}.
\end{proof}

\end{theorem}

{\nilinvoketheorem{appendix}}
