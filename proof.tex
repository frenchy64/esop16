\section{Soundness for Typed Clojure}

% TODO
\begin{assumption}[\newjavaliteral] \label{assumption:new}
  If\ $\forall i.\ {\opsem{}{\v{i}}{\classvalue{\classhint{i}}{\overrightarrow{\classfieldpair{\fld{j}} {\v{j}}}}}}\ or\ {\opsem{}{\v{i}}{\nil}}$
                  then
         $\newjava {\classhint{}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\classvalue{\classhint{}}{\overrightarrow {\classfieldpair{\fld{k}} {\v{k}}}}}$

\end{assumption}

\begin{lemma}
If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}},
\satisfies{\openv{}}{\propenv{}} 
and \opsem {\openv{}} {\e{}} {\v{}} 
then all of the following hold:
\begin{enumerate}
  \item either \object{} = \emptyobject{} or \inopenv {\openv{}} {\object{}} {\v{}},
  \item either \v{} $\not=$ \false\ (or \nil) and {\satisfies{\openv{}}{\thenprop{\prop{}}}} or 
               \v{}       = \false\ (or \nil) and {\satisfies{\openv{}}{\elseprop{\prop{}}}}, and
  \item \judgement{}{\hastype{\v{}}{\t{}}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
        for some \thenprop{\propp{}}, \elseprop{\propp{}} and {\objectp{}}.

\begin{proof}
By induction on the derivation of the typing judgement.

\begin{case}[T-True]
\e{} = \true, \t{} = \True, \thenprop{\prop{}} = \topprop{}, \elseprop{\prop{}} = \botprop{}, \object{} = \emptyobject{}

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val]
      \v{} = \true{}

Proving part 1 is trivial: \object{} is \emptyobject. 
To prove part 2, we note that \v{} = \true\ 
and \thenprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\thenprop{\prop{}}} by M-Top.
Part 3 holds as \e{} can only be reduced to itself via B-Val.
\end{subcase}

\end{itemize}

\begin{case}[T-EmptyMap]

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val]
        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Kw]

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val]
        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\end{case}

\begin{case}[T-False]
\e{} = \false, \t{} = \False, \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{}

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val]
      \v{} = \false{}

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \false\ 
and \elseprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\elseprop{\prop{}}} by M-Top. 
Part 3 holds as \e{} can only be reduced to itself via B-Val.
\end{subcase}

\end{itemize}
\end{case}

\begin{case}[T-Nil]
\e{} = \nil, \t{} = \Nil, \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{},

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val] 
      \v{} = \nil{}

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \nil\ 
and \elseprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\elseprop{\prop{}}} by M-Top. 
Part 3 holds as \e{} can only be reduced to itself via B-Val.
\end{subcase}

\end{itemize}

\end{case}

\begin{case}[T-Local]
  \e{} = \x{}, \thenprop{\prop{}} = {\notprop {\falsy{}} {\x{}}},
  \elseprop{\prop{}} = {\isprop {\falsy{}} {\x{}}},
\object{} = \x{}, 
\inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}},

\begin{itemize}
  \item[]
\begin{subcase}[B-Local]
{ \inopenv {\openv{}} {\x{}} {\v{}} },
{ \opsem {\openv{}} {\x{}} {\v{}} }

Part 1 follows from \inopenv{\openv{}}{\x{}} {\v{}} by B-Local.
Part 2 considers two cases: if \v{} is not \false\ or \nil, then 
\satisfies{\openv{}}{\notprop{\falsy}{\x{}}} holds by M-NotType; if \v{} is \false\ or \nil, then 
\satisfies{\openv{}}{\isprop{\falsy}{\x{}}} holds by M-Type.
We prove part 3 by observing
\inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}}
and
\satisfies{\openv{}}{\propenv{}},
so
{ \inopenv {\openv{}} {\x{}} {\v{}} }
by B-Local
gives us the desired result
\end{subcase}
\end{itemize}

\end{case}

\begin{case}[T-Do]
\e{} = {\doexp {\e1} {\e2}},
  \judgement {\propenv{}} 
             {\hastype {\e1} {\t1}} 
             {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop1}}} 
             {\object{1}},
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\hastype {\e{2}} {\t{}}} 
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}},

%TODO
\begin{itemize}
  \item[] \begin{subcase}[B-Do]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\v{}}

For all parts we note 
    since {\e{1}} can be either a true or false value
    then
    {\satisfies{\openv{}}{{\propenv{}},{\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}}
    by M-Or,
    which together with 
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\hastype {\e{2}} {\t{}}} 
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}},
    and
  \opsem {\openv{}} {\e{2}} {\v{}}
    allows us to apply the induction hypothesis on \e{2}.

To prove part 1 we use the induction hypothesis on \e{2}
to show either \object{} = \emptyobject{} 
or \inopenv {\openv{}} {\object{}} {\v{}}.

For part 2 we use the induction hypothesis on \e{2}
to show if \v{} $\not=$ \false\ (or \nil) then
        {\satisfies{\openv{}}{\thenprop{\prop{}}}}
        or
  if \v{} = \false\ (or \nil) then
        {\satisfies{\openv{}}{\elseprop{\prop{}}}}.

Part 3 follows from the induction hypothesis on \e{2}.
    \end{subcase}
  \item[]
\begin{subcase}[BE-Do]
  \v{} = {\errorval{\v{e}}},
\opsem {\openv{}} {\e{1}} {\errorval{\v{e}}},



\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-NewStatic]
  \e{} = {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                                                          {\class{}} {\overrightarrow{\e{i}}}},
  \object{} = \emptyobject{},
\thenprop{\prop{}} = \topprop{},
\elseprop{\prop{}} = \botprop{},
   $\overrightarrow{
\javatotc {\classhint{i}}
          {\t{i}}
          }$,
  \javatotc {\classhint{}}
            {\t{}},
            $
  \overrightarrow{
  \judgementtwo {\propenv{}}
                    {\hastype {\e{i}} {\t{i}}}
                  }$

\begin{itemize}
  \item[]
\begin{subcase}[B-New]
  $
  \overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }$,
         $\newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\v{}}$

Part 1 follows \object{} = \emptyobject{}.
Part 2 requires some explanation. The two false values in Typed Clojure
cannot be constructed with \newliteral, so the only case is \v{} $\not=$ \false\ (or \nil)
where \thenprop{\prop{}} = \topprop{} so \satisfies{\openv{}}{\thenprop{\prop{}}}.
Part 3 holds as B-New reduces to a \emph{non-nilable}
instance of \class{} via \newjavaliteral (by Assumption \ref{assumption:new}), and \javatotc{\classhint{}}{\t{}}.
\end{subcase}
  \item[]
\begin{subcase}[BE-New]
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-FieldStatic]
  \e{} = {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{1}}}
  \javatotc {\classhint{1}} {\class{}},
  \javatotcnil {\classhint{2}} {\t{}},
  \judgementtwo {\propenv{}} {\hastype {\e{1}} {\class{}}}

\begin{itemize}
  \item[]
\begin{subcase}[B-Field]
  \opsem {\openv{}}
         {\e{1}} 
         {\classvalue{\classhint{1}} {\classfieldpair{\fld{}} {\v{}}}}


Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \getfieldliteral 
in B-Field, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{subcase}
  \item[]
\begin{subcase}[BE-Field]
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-MethodStatic]
  \e{} = {\methodstaticexp {\classhint{1}} 
                          {\overrightarrow {\classhint{i}}} 
                          {\classhint{2}}
                          {\mth{}} {\e{}} {\overrightarrow{\e{i}}}}

\begin{itemize}
  \item[]
\begin{subcase}[B-Method]

Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \invokejavamethodliteral 
in B-Method, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{subcase}
  \item[]
\begin{subcase}[BE-Method1]
\end{subcase}
  \item[]
\begin{subcase}[BE-Method2]
\end{subcase}
\end{itemize}

\end{case}

\begin{case}[T-DefMulti]
  \e{} = {\createmultiexp {\s{}} {\e{1}}}


\begin{itemize}
  \item[]
\begin{subcase}[B-DefMulti]
Part 1 and 2 hold for the same reasons as T-True.
Part 3 holds trivially as B-DefMulti always returns the multimethod.
\end{subcase}
  \item[]
\begin{subcase}[BE-DefMulti]
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-DefMethod]

  \begin{itemize}
    \item[]
      \begin{subcase}[B-DefMethod]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod2]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod3]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-App]
  \e{} = {\appexp {\e{1}} {\e{2}}},
  \t{} = {\replacefor {\t{f}}
                      {\object{2}}
                      {\x{}}},
  {\thenprop {\prop{}}} = 
                 {\replacefor {\thenprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
  {\elseprop {\prop{}}} = 
                 {\replacefor {\elseprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
  \object{} = {\replacefor {\object{f}}
                              {\object{2}}
                              {\x{}}},
  \judgement {\propenv{}} {\hastype {\e{1}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                {\object{1}},
  \judgement {\propenv{}}
                 {\hastype {\e{2}} {\s{}}}
                 {\filterset {\thenprop {\prop{2}}}
                             {\elseprop {\prop{2}}}}
                 {\object{2}} 

\begin{itemize}
  \item[]
\begin{subcase}[B-BetaClosure]
  \opsem {\openv{}}
         {\e{1}}
         {\closure {\openv{c}} {\abs {\x{}} {\s{}} {\e{b}}}},
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}},
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
         {\e{b}}
         {\v{}}

         To prove part 1 we note by inversion of the typing relation (by T-Closure) if
         \begin{itemize}
           \item 
  \judgement {\propenv{}} {\hastype {\e{1}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                               {\object{f}}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                          {\object{1}} and
              \item 
                \opsem {\openv{}}
                       {\e{1}}
                       {\closure {\openv{c}} {\abs {\x{}} {\s{}} {\e{b}}}},
         \end{itemize}

         then there is some environment {\propenvc{}} such that
         \begin{itemize}
           \item
              \satisfies{\openv{c}}{\propenvc{}} and
            \item
              \judgement {\propenvc{}} {\hastype {\abs {\x{}} {\s{}} {\e{b}}} {\t{f}}}
                               {\filterset {\thenprop {\prop{f}}}
                                           {\elseprop {\prop{f}}}}
                               {\object{f}}.
         \end{itemize}

         By \judgementtwo{\propenv{}}{\hastype {\e{2}} {\s{}}},
            {\opsem {\openv{}}
                    {\e{2}}
                    {\v{2}}}
         and
         the inductive hypothesis 
         \begin{itemize}
           \item
             \opsem {\openv{}}
                    {\e{2}}
                    {\v{2}},
         \end{itemize}
         
         \satisfies{\propenv_{c}, {\isprop {\s{}} {\x{}}}}{\extendopenv {\openv{c}} {\x{}} {\v{2}}}.
         Since 
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
         {\e{b}}
         {\v{}},
  \judgement {\propenv{}}
                 {\hastype {\e{2}} {\s{}}}
                 {\filterset {\thenprop {\prop{2}}}
                             {\elseprop {\prop{2}}}}
                 {\object{2}} 
         and
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}}
         then either 
                              \object{} = {\replacefor {\object{f}}
                                                {\object{2}}
                                                {\x{}}}
                                                where
   \inopenv {\openv{}} {\object{}} {\v{}}
                              or \object{} = \emptyobject{}.

\end{subcase}
  \item[]
\begin{subcase}[B-BetaMulti]
  \opsem {\openv{}}
         {\e{1}}
         {\multi {\v{d}} {m}},
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}},
  \opsem {\openv{}}
         {\appexp {\v{d}} {\v{2}}}
         {\v{e}},
  \getmethod {\disptable{}}
             {\v{e}}
             {\v{f}},
  \opsem {\openv{}}
         {\appexp {\v{f}} {\v{2}}}
         {\v{}}

\end{subcase}
  \item[]
\begin{subcase}[B-Delta]
  \opsem {\openv{}} {\e{1}} {\const{}},
  \opsem {\openv{}} {\e{2}} {\v{2}},
  \constantopsem{\const{}}{\v{2}} = \v{}

  % TODO do I need to prove anything about the argument in the definition
  % of the constant being under \s{}?

  Prove by induction on \const{} and \v{2}.
  \begin{itemize}
    \item[] \begin{subcase}[\const{} = \classconst]
    ${\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}$
                                                       =
  ${\ArrowOne {\x{}} {\Top{}}
                                      {\Union{\nil{}}{\class{}}}
                                      {\filterset {\topprop{}}
                                                  {\topprop{}}}
                                      {\path {\classpe{}} {\x{}}}}$

        \begin{itemize}
          \item[] \begin{subcase}[\v{2} = \classvalue{\class{}} {\overrightarrow {\classfieldpair{\fld{i}} {\v{i}}}}]
                    \v{} = \class{}

                    To prove part 1, note \object{} = {\replacefor {\object{f}}{\object{2}}{\x{}}} 
                    and \object{f} = {\path {\classpe{}} {\x{}}}.
                    There are two cases defined by substitution: if \object{2} = \emptyobject{} then \object{} = \emptyobject{}
                    and we are done,
                    or if \object{2} = {\path {\pathelem{}} {\xp{}}} then \object{} = 
                    {\path {\classpe{}}{\object{2}}},
                     by the induction hypothesis \inopenv {\openv{}} {\object{2}} {\v{2}}
                    and by the definition of path translation
                    {\openv{}}({\path {\classpe{}} {\object{2}}}) = {\appexp {\classconst{}} {{\openv{}}(\object{2})}},
                    so we can deduce \inopenv {\openv{}} {\object{}} {\appexp {\classconst{}} {{\openv{}}(\object{2})}}
                    where {\appexp {\classconst{}} {{\openv{}}(\object{2})}} = \v{}, and we are done.

                    Part 2 is trivial since both propositions are \topprop{} by substitution.
                    
                    Part 3 
                  \end{subcase}
        \end{itemize}
            \end{subcase}
  \end{itemize}

\end{subcase}
  \item[]
\begin{subcase}[BE-Beta1]
\end{subcase}
  \item[]
\begin{subcase}[BE-Beta2]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaClosure]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaMulti1]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaMulti2]
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-IsA]\e{} = {\isaapp {\e{1}} {\e{2}}},
  \t{} = {\Boolean{}},
  \judgement {\propenv{}} {\hastype {\e{1}} {\t{1}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
                       {\object{1}},
  \judgementtwo {\propenv{}} {\hastype {\e{2}} {\t{2}}},
  \isacompare{\t{1}}{\object{1}}{\t{2}}{\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}},
  \object{} = \emptyobject{}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-IsA]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\v{2}},
  \isaopsem{\v{1}}{\v{2}} = {\v{}}

  From the definition of \isacompareliteral,
  \thenprop{\prop{}} = {\replacefor{\isprop{\t{2}}{\x{}}}{\object{1}}{\x{}}} and
  \elseprop{\prop{}} = {\replacefor{\notprop{\t{2}}{\x{}}}{\object{1}}{\x{}}}.

  Part 1 holds trivially with \object{} = \emptyobject{}.
  For part 2, if \v{} $\not=$ \false\ (or \nil)
  then {\satisfies{\openv{}}{\replacefor{\isprop{\t{2}}{\x{}}}{\object{1}}{\x{}}}}, as by the definition
  of \isaopsemliteral either 
  \begin{itemize}
    \item \v{1} = \v{2} so {\v{2}} must be the same type as down {\object{1}}, or
    \item \v{1} = \classvaluemeta{1} and \v{2} = \classvaluemeta{2} where \classvaluemeta{1}
  is a subclass of \classvaluemeta{2}, so {\v{2}} may be be safely upcast to the same type as down {\object{1}}.
  \end{itemize}
  Part 3 holds because by the definition of \isaopsemliteral
  \v{} can only be \true or \false, which are both subtypes of
  \t{}.


      \end{subcase}
    \item[]
      \begin{subcase}[BE-IsA1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-IsA2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMap]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  $\judgement {\propenv{}} {\hastype {\e{m}} {\HMapgeneric {\mandatory{}} {\absent{}}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}}$,
  $\judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}}$,
             ${\inmandatory{\k{}}{\t{}}{\mandatory{}}}$


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}}
                 {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

         To prove part 1 we consider two cases on the form of \object{m}: 
         \begin{itemize}
           \item
         if {\object{m}} = \emptyobject{}
         then \object{} = \emptyobject{} by substitution, which gives the desired result;
           \item
         if \object{m} = {\path {\pathelem{m}} {\x{m}}}
         then \object{} = {\path {\keype{k}} {\object{m}}} by substitution.
         We note by the definition of path translation
         {\openv{}}({\path {\keype{k}} {\object{m}}}) =
         {\getexp {{\openv{}}(\object{m})}{\k{}}}
         and by the induction hypothesis on \e{m}
         {{\openv{}}(\object{m})} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
         which together imply 
         \inopenv {\openv{}} {\object{}} {\getexp {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}}}.
         Since this is the same form as B-Get, we can apply the premise
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}
         to derive \inopenv {\openv{}} {\object{}} {\v{}}.
         \end{itemize}
         
         Part 2 holds trivially as \thenprop{\prop{}} = {\topprop{}}
         and \elseprop{\prop{}} = {\topprop{}}.
         To prove part 3 we note that \e{m} has type {\HMapgeneric {\mandatory{}} {\absent{}}}
         where ${\inmandatory{\k{}}{\t{}}{\mandatory{}}}$, and 
         the premises of B-Get
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
         and
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}
         tell us {\v{}} must be of type {\t{}}.

      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

       Unreachable subcase because 
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
       contradicts ${\inmandatory{\k{}}{\t{}}{\mandatory{}}}$.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMapAbsent]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \t{} = \Nil,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  \judgement {\propenv{}} {\hastype {\e{m}} {\HMapgeneric {\mandatory{}} {\absent}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}},
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}},
  {\inabsent{\k{}}{\absent{}}}


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}} {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

       Unreachable subcase because 
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         contradicts
                {\inabsent{\k{}}{\absent{}}}.
      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

         To prove part 1 we consider two cases on the form of \object{m}: 
         \begin{itemize}
           \item
         if {\object{m}} = \emptyobject{}
         then \object{} = \emptyobject{} by substitution, which gives the desired result;
           \item
         if \object{m} = {\path {\pathelem{m}} {\x{m}}}
         then \object{} = {\path {\keype{k}} {\object{m}}} by substitution.
         We note by the definition of path translation
         {\openv{}}({\path {\keype{k}} {\object{m}}}) =
         {\getexp {{\openv{}}(\object{m})}{\k{}}}
         and by the induction hypothesis on \e{m}
         {{\openv{}}(\object{m})} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
         which together imply 
         \inopenv {\openv{}} {\object{}} {\getexp {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}}}.
         Since this is the same form as B-GetMissing, we can apply the premise
        \v{} = \nil\ 
         to derive \inopenv {\openv{}} {\object{}} {\v{}}.
         \end{itemize}
         
         Part 2 holds trivially as \thenprop{\prop{}} = {\topprop{}}
         and \elseprop{\prop{}} = {\topprop{}}.
         To prove part 3 we note that \e{m} has type {\HMapgeneric {\mandatory{}} {\absent{}}}
         where {\inabsent{\k{}}{\absent{}}}, and
         the premises of B-GetMissing
         \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
         and
          \v{} = \nil\ 
         tell us {\v{}} must be of type {\t{}}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMapPartialDefault]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \t{} = \Top,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
 \judgement {\propenv{}} {\hastype {\e{m}} {\HMapp {\mandatory{}} {\absent}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}},
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}},
             ${\notinmandatory{\k{}}{\t{}}{\mandatory{}}}$,
             {\notinabsent{\k{}}{\absent{}}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}}
                 {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Assoc]
  \e{} = {\assocexp {\e{m}} {\e{k}} {\e{v}}},
  \t{} = ${\HMapgeneric {\extendmandatoryset {\mandatory{}}{\k{}}{\t{}}} {\absent}}$,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = \emptyobject,
  \judgementtwo {\propenv{}} {\hastype {\e{m}} {\HMapgeneric {\mandatory{}} {\absent}}},
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value{\k{}}}},
  \judgementtwo {\propenv{}} {\hastype {\e{v}} {\t{}}},
  {\k{}} $\not\in$ {\absent{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Assoc]
        \v{} = 
        {\extendmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
                {\k{}}{\v{v}}},
        \opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
        \opsem {\openv{}} {\e{k}} {\k{}},
        \opsem {\openv{}} {\e{v}} {\v{v}}

        We prove parts 1 and 2 for similar reasons as T-True.
        %TODO part 3
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc2]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc3]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-If]

  \begin{itemize}
    \item[]
      \begin{subcase}[B-If]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-If]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Let]
  \e{} = {\letexp {\x{}} {\e{1}} {\e{2}}},
  \judgement {\propenv{}} {\hastype {\e{1}} {\s{}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
             {\object{1}},
             \propp{} = {\impprop {\notprop {\falsy{}} {\x{}}} {\thenprop {\prop{1}}}},
             \proppp{} = {\impprop {\isprop {\falsy{}} {\x{}}} {\elseprop {\prop{1}}}},
  \judgement
       {\propenv{}, {\isprop {\s{}} {\x{}}},
         {\propp{}},
         {\proppp{}}}
             {\hastype {\e{2}} {\t{}}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\object{}} 


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Let]
        \opsem {\openv{}} {\e{1}} {\v{1}},
        \opsem {\extendopenv{\openv{}}{\x{}}{\v{1}}} {\e{2}} {\v{}}

        For all the following cases (with a reminder that \x{} is fresh)
        we apply the induction hypothesis on \e{2}. We justify this by noting
        that occurrences of \x{} inside \e{2} have the same type as \e{1} and 
        simulate the propositions of \e{1}
        because 
        \opsem {\openv{}} {\e{1}} {\v{1}},
        and
        \opsem {\extendopenv{\openv{}}{\x{}}{\v{1}}} {\e{2}} {\v{}},
        so \satisfies{\openv{}}{\propenv{}, {\isprop {\s{}} {\x{}}}, \propp{}, \proppp{}},
        by M-And.

        We prove parts 1, 2 and 3 by directly using the induction hypothesis on \e{2}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Let]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Clos] \e{} = {\closure {\openv{}} {\abs {\x{}} {\sp{}} {\e{1}}}},
  $\exists {\propenvp{}}. \satisfies{\openv{}}{\propenvp{}}$
  \ \text{and}\ 
\judgement {\propenvp{}} {\hastype {\abs {\x{}} {\sp{}} {\e{1}}} {\t{}}}
                 {\filterset {\thenprop {\prop{}}}
                             {\elseprop {\prop{}}}}
                 {\object{}}
  \begin{itemize}
    \item[]
      \begin{subcase}[B-Abs] \v{} = {\closure {\openv{}} {\abs {\x{}} {\sp{}} {\e{1}}}}

        We assume \propenv{} substitutes for \propenvp{}, so 
        \begin{itemize}
          \item \satisfies{\openv{}}{\propenv{}}
          \item \judgement {\propenv{}} {\hastype {\abs {\x{}} {\sp{}} {\e{1}}} {\t{}}}
                           {\filterset {\thenprop {\prop{}}}
                                       {\elseprop {\prop{}}}}
                           {\object{}}.
       \end{itemize}
       Note the last rule in the derivation of
          \judgement {\propenv{}} {\hastype {\abs {\x{}} {\sp{}} {\e{1}}} {\t{}}}
                           {\filterset {\thenprop {\prop{}}}
                                       {\elseprop {\prop{}}}}
                           {\object{}}
                           must be T-Abs, so 
                           {\thenprop {\prop{}}} = {\topprop{}},
                           {\elseprop {\prop{}}} = {\botprop{}}
                           and {\object{}} = {\emptyobject{}}.
         Thus parts 1, 2 and 3 hold for the same reasons as T-True.

      \end{subcase} 
  \end{itemize}
\end{case}

\begin{case}[T-Multi] \e{} = {\multi {\e{1}} {\disptable{}}},
  \t{} = {\MultiFntype {\s{}} {\t{1}}},
  {\thenprop {\prop{}}} = {\topprop{}},
  {\elseprop{\prop{}}} = {\botprop{}},
  {\object{}} = {\emptyobject{}},
  \judgementtwo {} {\hastype {\e{1}} {\t{1}}} 

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val]
        Similar to T-True.
      \end{subcase}
  \end{itemize}

\end{case}

\begin{case}[T-Abs] \e{} = {\abs {\x{}} {\s{}} {\e{1}}},
  \t{} = {\ArrowOne {\x{}} {\s{}}
                                                      {\t{1}}
                                                      {\filterset {\thenprop {\prop{1}}}
                                                                  {\elseprop {\prop{1}}}}
                                                      {\object{1}}},
  {\thenprop{\prop{}}}= {\topprop{}},
  {\elseprop{\prop{}}}= {\botprop{}},
  {\object{}}= {\emptyobject{}},
{ \judgement {\propenv{}, {\isprop {\s{}} {\x{}}}}
            {\hastype {\e{1}} {\t{}}}
             {\filterset {\thenprop {\prop{1}}}
                         {\elseprop {\prop{1}}}}
             {\object{1}}},
\judgement {\propenv{}} {\hastype {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}}
                 {\filterset {\thenprop {\prop{}}}
                             {\elseprop {\prop{}}}}
                 {\object{}}

  \begin{itemize}
    \item[]
      %TODO
      \begin{subcase}[B-Abs]
        \v{} = ${\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}$,
          { \opsem {\openv{}}
                   {\abs {\x{}} {\t{}} {\e{1}}}
                   {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}}

        Parts 1 and 2 hold for the same reasons as T-True.
        Part 3 holds directly via T-Clos, since \v{} must be a closure.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Error]
  \e{} = \errorval{\v{1}},
  \t{} = \Bot,
  \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \botprop{}, \object{} = \emptyobject{}


  \begin{itemize}
    \item[]
      \begin{subcase}[BE-Error] 
        \v{} = \errorval{\v{1}}

        Parts 1 holds as \object{} = \emptyobject{}.
        Part 2 holds vaculously as \thenprop{\prop{}} = \botprop{} and \elseprop{\prop{}} = \botprop{}.
        Part 3 holds as \errorval{\v{1}} is of type \Bot by the premises of T-Error.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Subsume]

\end{case}

\begin{case}[T-Const]\e{} = {\const{}},
  \t{} = {\constanttype{\const{}}},
{\thenprop{\prop{}}} = {\topprop{}},
{\elseprop{\prop{}}} = {\botprop{}},
{\object{}} = {\emptyobject{}}

  \begin{itemize}
    \item[] 
      \begin{subcase}[B-Val]
        Parts 1, 2 and 3 hold for the same reasons as T-True. 
      \end{subcase}
  \end{itemize}
\end{case}

\end{proof}

\end{enumerate}
\end{lemma}
