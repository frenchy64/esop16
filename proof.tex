\section{Soundness for Typed Clojure}

\begin{assumption}[\newjavaliteral] \label{assumption:new}
  If\ $\forall i.\ {\v{i}} = {\classvalue{\classhint{i}}{\overrightarrow{\classfieldpair{\fld{j}} {\v{j}}}}}\ or\ {\v{i}}= {\nil}$
  then
  \begin{itemize}
  \item if $\newjava {\classhint{}}
                {\overrightarrow{\classhint{i}}}
                {\overrightarrow{\v{i}}}
                {\v{}}$
                  then
                  \begin{itemize}
                    \item
                      \v{} = 
                  ${\classvalue{\classhint{}}{\overrightarrow {\classfieldpair{\fld{k}} {\v{k}}}}}$
                  \end{itemize}
  \item
                  otherwise 
        $\newjava {\classhint{}}
                {\overrightarrow{\classhint{i}}}
                {\overrightarrow{\v{i}}}
                {\errorval{\v{e}}}$.
            \end{itemize}
\end{assumption}

\begin{assumption}[\getfieldliteral] \label{assumption:field}
  If\ {\v{1}} = ${\classvalue{\classhint{1}}{{\classfieldpair{\fld{}}{\v{f}}, {\overrightarrow{\classfieldpair{\fld{l}} {\v{l}}}}}}}$,
  then 
  \begin{itemize}
    \item
         if \getfieldjava{\classhint{1}} {\v{1}} {\fld{}} {\classhint{2}} {\v{}}
                  then \v{} = \v{f} and either
                  \begin{itemize}
                    \item
                  \v{f} = ${\classvalue{\classhint{2}}{\overrightarrow{\classfieldpair{\fld{m}} {\v{m}}}}}$
                   or 
                    \item
                  \v{f} = \nil,
                  \end{itemize}
    \item
      otherwise \getfieldjava{\classhint{1}} {\v{1}} {\fld{}} {\classhint{2}} {\errorval{\v{e}}}.
  \end{itemize}
\end{assumption}

\begin{assumption}[\invokejavamethodliteral] \label{assumption:method}
  If\ {\v{1}} = {\classvalue{\classhint{1}}{\overrightarrow{\classfieldpair{\fld{l}} {\v{l}}}}},
  $\forall i.\ {\v{i}}={\classvalue{\classhint{i}}{\overrightarrow{\classfieldpair{\fld{j}} {\v{j}}}}}\ or\ {\v{i}}={\nil}$
         then 
         \begin{itemize}
           \item if
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{i}}} {\overrightarrow{\v{i}}}
                    {\classhint{2}}
                    {\v{}}
                  then either
                  \begin{itemize}
                    \item
                  \v{} = ${\classvalue{\classhint{2}}{\overrightarrow{\classfieldpair{\fld{m}} {\v{m}}}}}$
                  or\ 
                  \v{} = \nil,  or
                  \end{itemize}
          \item
            otherwise
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{i}}} {\overrightarrow{\v{i}}}
                    {\classhint{2}}
                    {\errorval{\v{e}}}.
        \end{itemize}
\end{assumption}

\begin{lemma} \label{lemma:soundness}
If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}
and
\satisfies{\openv{}}{\propenv{}} then
\begin{itemize}
  \item
    if
    \opsem {\openv{}} {\e{}} {\v{}} 
then of the following hold:
\begin{enumerate}
  \item either \object{} = \emptyobject{} or \inopenv {\openv{}} {\object{}} {\v{}},
  \item either \v{} $\not=$ \false\ (or \nil) and {\satisfies{\openv{}}{\thenprop{\prop{}}}} or 
               \v{}       = \false\ (or \nil) and {\satisfies{\openv{}}{\elseprop{\prop{}}}}, and
  \item \judgement{}{\hastype{\v{}}{\t{}}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
        for some \thenprop{\propp{}}, \elseprop{\propp{}} and {\objectp{}}
\end{enumerate}

  \item
otherwise \opsem {\openv{}} {\e{}} {\errorvalv{}}.
\end{itemize}


\begin{proof}
By induction on the derivation of the typing judgement.

\begin{case}[T-True]
\e{} = \true, \t{} = \True, \thenprop{\prop{}} = \topprop{}, \elseprop{\prop{}} = \botprop{}, \object{} = \emptyobject{}

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val]
      \v{} = \true{}

Proving part 1 is trivial: \object{} is \emptyobject. 
To prove part 2, we note that \v{} = \true\ 
and \thenprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\thenprop{\prop{}}} by M-Top.
Part 3 holds as \e{} can only be reduced to itself via B-Val.
\end{subcase}

\end{itemize}

\begin{case}[T-HMap] \e{} = {\curlymapvaloverright{\v{k}}{\v{v}}},
  \t{} = {\HMapc {\mandatory{}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}},
  $\overrightarrow{\judgementtwo {} {\hastype{\v{k}}{\Value \k{}}}}$,
  $\overrightarrow{\judgementtwo {} {\hastype{\v{v}}{\t{v}}}}$,
  \mandatory{} = \mandatorysetoverright{\k{}}{\t{v}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\curlymapvaloverright{\v{k}}{\v{v}}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Kw] \e{} = {\k{}},
  \t{} = {\Value{\k{}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\k{}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}
\end{case}

\end{case}

\begin{case}[T-False]
\e{} = \false, \t{} = \False, \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{}

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val]
      \v{} = \false{}

Proving part 1 is trivial: \object{} is \emptyobject. To prove part 2, we note that \v{} = \false\ 
and \elseprop{\prop{}} = \topprop{}, so \satisfies{\openv{}}{\elseprop{\prop{}}} by M-Top. 
Part 3 holds as \e{} can only be reduced to itself via B-Val.
\end{subcase}

\end{itemize}
\end{case}

\begin{case}[T-Nil]
\e{} = \nil, \t{} = \Nil, \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{},

\begin{itemize}
  \item[] 
    \begin{subcase}[B-Val] 
      \v{} = \nil{}

      Similar to T-False.
\end{subcase}

\end{itemize}

\end{case}

\begin{case}[T-Local]
  \e{} = \x{}, \thenprop{\prop{}} = {\notprop {\falsy{}} {\x{}}},
  \elseprop{\prop{}} = {\isprop {\falsy{}} {\x{}}},
\object{} = \x{}, 
\inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}},

\begin{itemize}
  \item[]
\begin{subcase}[B-Local]
{ \inopenv {\openv{}} {\x{}} {\v{}} },
{ \opsem {\openv{}} {\x{}} {\v{}} }

Part 1 follows from \inopenv{\openv{}}{\x{}} {\v{}} by B-Local.
Part 2 considers two cases: if \v{} is not \false\ or \nil, then 
\satisfies{\openv{}}{\notprop{\falsy}{\x{}}} holds by M-NotType; if \v{} is \false\ or \nil, then 
\satisfies{\openv{}}{\isprop{\falsy}{\x{}}} holds by M-Type.
We prove part 3 by observing
\inpropenv{\propenv{}}{\isprop{\t{}}{\x{}}}
and
\satisfies{\openv{}}{\propenv{}},
so
{ \inopenv {\openv{}} {\x{}} {\v{}} }
by B-Local
gives us the desired result.
\end{subcase}
\end{itemize}

\end{case}

\begin{case}[T-Do]
\e{} = {\doexp {\e1} {\e2}},
  \judgement {\propenv{}} 
             {\hastype {\e1} {\t1}} 
             {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop1}}} 
             {\object{1}},
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\hastype {\e{2}} {\t{}}} 
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}},

\begin{itemize}
  \item[] \begin{subcase}[B-Do]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\v{}}

For all parts we note 
    since {\e{1}} can be either a true or false value
    then
    {\satisfies{\openv{}}{{\propenv{}},{\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}}
    by M-Or,
    which together with 
\judgement {\propenv{}, {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}}
           {\hastype {\e{2}} {\t{}}} 
           {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}} 
           {\object{}},
    and
  \opsem {\openv{}} {\e{2}} {\v{}}
    allows us to apply the induction hypothesis on \e{2}.

To prove part 1 we use the induction hypothesis on \e{2}
to show either \object{} = \emptyobject{} 
or \inopenv {\openv{}} {\object{}} {\v{}}, since \e{} always
evaluates to the result of \e{2}.

For part 2 we use the induction hypothesis on \e{2}
to show if \v{} $\not=$ \false\ (or \nil) then
        {\satisfies{\openv{}}{\thenprop{\prop{}}}}
        or
  if \v{} = \false\ (or \nil) then
        {\satisfies{\openv{}}{\elseprop{\prop{}}}}.

Part 3 follows from the induction hypothesis on \e{2}.
    \end{subcase}
  \item[]

\begin{subcase}[BE-Do1]
  \opsem {\openv{}} {\e{1}} {\errorval{\v{e}}},
  \opsem {\openv{}} {\e{}} {\errorval{\v{}}}

        Trivially reduces to an error.
\end{subcase}
  \item[]
\begin{subcase}[BE-Do2]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\errorvalv{}},
  \opsem {\openv{}} {\e{}} {\errorvalv{}}

        As above.
\end{subcase}
  \item[]

\begin{subcase}[BW-Do1]
  Unreachable by the induction hypothesis on \e{1}.
\end{subcase}
  \item[]

\begin{subcase}[BW-Do2]
  Unreachable by the induction hypothesis on \e{2}.
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-NewStatic]
  \e{} = {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                                                          {\class{}} {\overrightarrow{\e{i}}}},
  \object{} = \emptyobject{},
\thenprop{\prop{}} = \topprop{},
\elseprop{\prop{}} = \botprop{},
   $\overrightarrow{
\javatotc {\classhint{i}}
          {\t{i}}
          }$,
  \javatotc {\classhint{}}
            {\t{}},
            $
  \overrightarrow{
  \judgementtwo {\propenv{}}
                    {\hastype {\e{i}} {\t{i}}}
                  }$

\begin{itemize}
  \item[]
\begin{subcase}[B-New]
  $
  \overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }$,
         $\newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\v{}}$

Part 1 follows \object{} = \emptyobject{}.
Part 2 requires some explanation. The two false values in Typed Clojure
cannot be constructed with \newliteral, so the only case is \v{} $\not=$ \false\ (or \nil)
where \thenprop{\prop{}} = \topprop{} so \satisfies{\openv{}}{\thenprop{\prop{}}}.
Part 3 holds as B-New reduces to a \emph{non-nilable}
instance of \class{} via \newjavaliteral (by assumption \ref{assumption:new}), and \javatotc{\classhint{}}{\t{}}.
\end{subcase}
  \item[]

\begin{subcase}[BE-New1] $\overrightarrow{
  \opsem {\openv{}}
         {\e{i-1}}
         {\v{i-1}}
       }$,
  \opsem {\openv{}}
         {\e{i}}
         {\errorvalv{}},
  \opsem {\openv{}} {\e{}} {\errorvalv{}}

        Trivially reduces to an error.

\end{subcase}
  \item[]

\begin{subcase}[BE-New2] 
  $\overrightarrow{
  \opsem {\openv{}}
         {\e{i}}
         {\v{i}}
       }$,
         \newjava {\classhint{1}}
                  {\overrightarrow{\classhint{i}}}
                  {\overrightarrow{\v{i}}}
                  {\errorvalv{}},
        \opsem {\openv{}} {\e{}} {\errorvalv{}}

        As above.

\end{subcase}
  \item[]

\begin{subcase}[BW-New1]
  Unreachable by the induction hypothesis on {\e{i}}.
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-FieldStatic]
  \e{} = {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{1}}},
  \javatotc {\classhint{1}} {\class{}},
  \javatotcnil {\classhint{2}} {\t{}},
  \judgementtwo {\propenv{}} {\hastype {\e{1}} {\class{}}}

\begin{itemize}
  \item[]
\begin{subcase}[B-Field]
  \opsem {\openv{}}
         {\e{1}} 
         {\classvalue{\classhint{1}} {\classfieldpair{\fld{}} {\v{}}}}


Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \getfieldliteral (assumption \ref{assumption:field})
in B-Field, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{subcase}
  \item[]
\begin{subcase}[BE-Field]
  \opsem {\openv{}}
         {\e{1}} 
         {\errorvalv{}},
  \opsem {\openv{}}
         {\e{}}
         {\errorvalv{}}

         Trivially reduces to an error.

\end{subcase}

\item[]
\begin{subcase}[BW-Field]
  Unreachable by the induction hypothesis on \e{1}.
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-MethodStatic]
  \e{} = ${\methodstaticexp {\classhint{1}} 
                          {\overrightarrow {\classhint{i}}} 
                          {\classhint{2}}
                          {\mth{}} {\e{m}} {\overrightarrow{\e{a}}}}$,
  \thenprop{\prop{}} = \topprop{}, \elseprop{\prop{}} = \topprop{}, \object{} = \emptyobject{},
  $\overrightarrow{\javatotc {\classhint{i}} {\t{i}}}$,
             \javatotc {\classhint{1}} {\class{}},
             \javatotcnil {\classhint{2}} {\t{}},
  \judgementtwo {\propenv{}} {\hastype {\e{m}} {\class{}}},
             $\overrightarrow{
  \judgementtwo {\propenv{}} {\hastype {\e{a}} {\t{a}}}
                  }$

\begin{itemize}
  \item[]
\begin{subcase}[B-Method]
  \opsem {\openv{}}
         {\e{m}}
         {\v{m}},
  $\overrightarrow{
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}}$,
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{a}}} {\overrightarrow{\v{a}}}
                    {\classhint{2}}
                    {\v{}}


Part 1 is trivial as \object{} is always \emptyobject{}.
Part 2 holds trivially, \v{} can be either a true or false value
and both {\thenprop{\prop{}}} and {\elseprop{\prop{}}}
are \topprop{}.
Part 3 relies on the semantics of \invokejavamethodliteral (assumption \ref{assumption:method})
in B-Method, which returns a \emph{nilable} instance of \classhint{2},
and \javatotcnil{\classhint{2}} {\t{}}.
\end{subcase}

  \item[]
\begin{subcase}[BE-Method1]
  \opsem {\openv{}}
         {\e{m}}
         {\errorval{\v{}}},
  \opsem {\openv{}}
         {\e{}}
         {\errorval{\v{}}}

         Trivially reduces to an error.
\end{subcase}
  \item[]
\begin{subcase}[BE-Method2]
  \opsem {\openv{}}
         {\e{m}}
         {\v{m}},
 $\overrightarrow{
  \opsem {\openv{}}
         {\e{n-1}}
         {\v{n-1}}
       }$,
  \opsem {\openv{}}
         {\e{n}}
         {\errorval{\v{}}},
  \opsem {\openv{}}
         {\e{}}
         {\errorval{\v{}}}

  As above.
\end{subcase}
  \item[]
\begin{subcase}[BE-Method3]
  \opsem {\openv{}}
         {\e{m}}
         {\v{m}},
  $\overrightarrow{
  \opsem {\openv{}}
         {\e{a}}
         {\v{a}}
       }$,
  \invokejavamethod {\classhint{1}} {\v{m}} {mth}
                    {\overrightarrow{\classhint{a}}} {\overrightarrow{\v{a}}}
                    {\classhint{2}}
                    {\errorvalv{}},
  \opsem {\openv{}} {\e{}} {\errorvalv{}}

  As above.

\end{subcase}
  \item[]
\begin{subcase}[BW-Method1]
\end{subcase}
  \item[]
\begin{subcase}[BW-Method2]
\end{subcase}
\end{itemize}

\end{case}

\begin{case}[T-DefMulti]
  \e{} = {\createmultiexp {\s{}} {\e{d}}},
  \t{} = {\MultiFntype {\s{}} {\t{d}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \s{} = {\ArrowOne {\x{}} {\t{1}} {\t{2}}
                          {\filterset {\thenprop {\prop{1}}}
                                      {\elseprop {\prop{1}}}}
                          {\object{1}}},
  \t{d} = {\ArrowOne {\x{}} {\t{1}} {\t{3}}
                          {\filterset {\thenprop {\prop{2}}}
                                      {\elseprop {\prop{2}}}}
                          {\object{2}}},
  \judgementtwo {\propenv{}} {\hastype {\e{d}} {\t{d}}}


\begin{itemize}
  \item[]
\begin{subcase}[B-DefMulti]
  \v{} = {\multi {\v{d}} {\emptydisptable}},
  \opsem {\openv{}} {\e{d}} {\v{d}}


Part 1 and 2 hold for the same reasons as T-True.
For part 3 we show \judgementtwo{}{\hastype{\multi {\v{d}} {\emptydisptable}}{\MultiFntype {\s{}} {\t{d}}}}
by T-Multi, since \judgementtwo {} {\hastype {\v{d}} {\t{d}}} by the inductive hypothesis on {\e{d}}
and {\emptydisptable} vacuously satisfies the other premises of T-Multi, so we are done.

\end{subcase}
  \item[]
\begin{subcase}[BE-DefMulti] \opsem {\openv{}} {\e{d}} {\errorvalv{}},
        \opsem {\openv{}} {\e{}} {\errorvalv{}}

        Trivially reduces to an error.

\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-DefMethod]
  \e{} = {\extendmultiexp {\e{m}} {\e{v}} {\e{f}}},
  \e{f} = {\abs {\x{}} {\t{1}} {\e{b}}},
  \t{} = {\MultiFntype {\t{m}} {\t{d}}},
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = {\emptyobject{}},
  \t{m} = {\ArrowOne {\x{}} {\t{1}} {\s{}}
                     {\filterset {\thenprop {\prop{m}}}
                                 {\elseprop {\prop{m}}}}
                     {\object{m}}},
  \t{d} = {\ArrowOne {\x{}} {\t{1}} {\sp{}}
                     {\filterset {\thenprop {\prop{d}}}
                                 {\elseprop {\prop{d}}}}
                     {\object{d}}},
  \judgementtwo {\propenv{}} {\hastype {\e{m}} {\MultiFntype {\t{m}} {\t{d}}}},
  \isacompare{\sp{}}{\object{d}}{\t{v}}{\filterset {\thenprop {\prop{i}}} {\elseprop {\prop{i}}}},
  \judgementtwo {\propenv{}}
               {\hastype {\e{v}} {\t{v}}},
  \judgement {\propenv{}, {\isprop{\t{1}} {\x{}}}, {\thenprop {\prop{i}}}}
           {\hastype {\e{b}} {\s{}}}
           {\filterset {\thenprop {\prop{m}}}
                       {\elseprop {\prop{m}}}}
           {\object{m}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-DefMethod]
       \v{} = {\multi {\v{d}} {\disptablep{}}},
        \opsem {\openv{}}
               {\e{m}}
               {\multi {\v{d}} {\disptable{}}},
  \opsem {\openv{}}
         {\e{v}}
         {\v{v}},
  \opsem {\openv{}}
         {\e{f}}
         {\v{f}},
         \disptablep{} = {\extenddisptable {\disptable{}} 
                                {\v{v}}
                                {\v{f}}}

                                Part 1 and 2 hold for the same reasons as T-True, noting that the propositions
                                and object agree with T-Multi.

For part 3 we show
\judgementtwo{}{\hastype{\multi {\v{d}} {\extenddisptable {\disptable{}}{\v{v}}{\v{f}}}}{\MultiFntype {\t{m}} {\t{d}}}}
by noting \judgementtwo {} {\hastype {\v{d}} {\t{d}}},
  \judgementtwo{}{\hastype{\v{v}}{\Top{}}}
  and
  \judgementtwo{}{\hastype{\v{f}}{\t{m}}}, and since \disptable{} is in the correct form by the inductive
  hypothesis on {\e{m}} we can satisfy all premises of T-Multi, so we are done.


      \end{subcase}

    \item[]
      \begin{subcase}[BE-DefMethod1]
        \opsem {\openv{}}
               {\e{m}}
               {\errorval{\v{}}},
        \opsem {\openv{}}
                  {\e{}}
                {\errorval{\v{}}}

                Trivially reduces to an error.

      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod2]
        \opsem {\openv{}}
         {\e{m}}
         {\multi {\v{d}} {\disptable{}}},
  \opsem {\openv{}}
         {\e{v}}
         {\errorval{\v{}}},
        \opsem {\openv{}}
                  {\e{}}
                {\errorval{\v{}}}

                As above.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-DefMethod3]
        \opsem {\openv{}}
         {\e{m}}
         {\multi {\v{d}} {\disptable{}}},
  \opsem {\openv{}}
         {\e{v}}
         {\v{v}},
  \opsem {\openv{}}
         {\e{f}}
         {\errorval{\v{}}},
        \opsem {\openv{}}
                  {\e{}}
                {\errorval{\v{}}}

                As above.

      \end{subcase}
  \end{itemize}
\end{case}

      %TODO
\begin{case}[T-App]
  \e{} = {\appexp {\e{1}} {\e{2}}},
  \t{} = {\replacefor {\t{f}}
                      {\object{2}}
                      {\x{}}},
  {\thenprop {\prop{}}} = 
                 {\replacefor {\thenprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
  {\elseprop {\prop{}}} = 
                 {\replacefor {\elseprop {\prop{f}}}
                              {\object{2}}
                              {\x{}}},
  \object{} = {\replacefor {\object{f}}
                           {\object{2}}
                           {\x{}}},
  \judgement {\propenv{}} {\hastype {\e{1}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                {\object{1}},
  \judgement {\propenv{}}
                 {\hastype {\e{2}} {\s{}}}
                 {\filterset {\thenprop {\prop{2}}}
                             {\elseprop {\prop{2}}}}
                 {\object{2}},
  \opsem{\openv{}}{\e{}}{\v{}}
%                 IHe1 = $\forall{\openv{1}},
%                               {\v{1}},
%                               {\thenprop {\prop{1}}},
%                               {\elseprop {\prop{1}}},
%                               {\object{1}}.
%                               {\judgement
%                                 {\propenv{}}
%                                 {\hastype
%                                   {\e{1}}
%                                   {\ArrowOne {\x{}} {\s{}}
%                                     {\t{f}}
%                                     {\filterset 
%                                       {\thenprop {\prop{f}}}
%                                       {\elseprop {\prop{f}}}}
%                                     {\object{f}}}}
%                                {\filterset {\thenprop {\prop{1}}}
%                                            {\elseprop {\prop{1}}}}
%                                {\object{1}}}
%\Rightarrow
%                                                       {\satisfies{\openv{1}}{\propenv{}}}
%                                                       \Rightarrow
%  \opsem {\openv{}}
%         {\e{1}}
%         {\v{1}}
%         \Rightarrow
%         (1: \object{1} = \emptyobject{} \vee \inopenv{\openv{1}}{\object{1}}{\v{1}})
%         \wedge
%       (2: (\v{1} \not= \false\ (or\ \nil) \wedge \satisfies{\openv{1}}{\thenprop{\prop{1}}})
%          \vee
%            (\v{1} = \false\ (or\ \nil) \wedge \satisfies{\openv{1}}{\elseprop{\prop{1}}}))
%            \wedge
%          (3: \exists {\thenprop{\propp{1}}},{\elseprop{\propp{1}}},{\objectp{1}}.
%          \judgement{}{\hastype{\v{1}}{\ArrowOne {\x{}} {\s{}}
%                                     {\t{f}}
%                                     {\filterset 
%                                       {\thenprop {\prop{f}}}
%                                       {\elseprop {\prop{f}}}}
%                                   {\object{f}}}}
%                        {\filterset{\thenprop{\propp{1}}}{\elseprop{\propp{1}}}}
%                      {\objectp{1}})
%                                                       $









\begin{itemize}
  \item[]
\begin{subcase}[B-BetaClosure]
  \opsem {\openv{}}
         {\e{1}}
         {\closure {\openv{c}} {\abs {\x{}} {\s{}} {\e{b}}}},
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}},
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
         {\e{b}}
         {\v{}}

         To prove part 1, we know by inversion on \e{1} from T-Clos
         there is some environment {\propenvc{}} such that
         \begin{itemize}
           \item
              \satisfies{\openv{c}}{\propenvc{}} and
            \item
  \judgement {\propenvc{}} {\hastype {\abs {\x{}} {\s{}} {\e{b}}} {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}}
                {\filterset {\thenprop {\prop{1}}}
                            {\elseprop {\prop{1}}}}
                {\object{1}},
         \end{itemize}
         and also by inversion on \e{1} from T-Abs
         \begin{itemize}
           \item
  { \judgement {\propenvc{}, {\isprop {\s{}} {\x{}}}}
              {\hastype {\e{b}} {\t{f}}}
               {\filterset {\thenprop {\prop{f}}}
                           {\elseprop {\prop{f}}}}
               {\object{f}}}.
         \end{itemize}

         We consider cases on the form of \object{f}:

         \begin{itemize}
           \item if \object{f} = \emptyobject{}, then \object{} = \emptyobject{} by substitution,
           \item if \object{f} = {\path {\pathelem{f}} {\x{}}}, 
             we consider cases on the form of \object{2}:
             \begin{itemize}
               \item if \object{2} = \emptyobject{}, then \object{} = \emptyobject{},
               \item otherwise \object{2} = {\path {\pathelem{2}} {\y{}}}, where,
                 because
                \object{} = {\replacefor {\path {\pathelem{f}} {\x{}}}
                                         {\path {\pathelem{2}} {\y{}}}
                                         {\x{}}},
                                         by substitution
                                         \object{} = {\path {\pathelem{f}} {\path {\pathelem{2}} {\y{}}}}.
                                         To prove \inopenv{\openv{}}{\path {\pathelem{f}} {\path {\pathelem{2}} {\y{}}}}{\v{}}
                                         we note by the induction hypothesis on {\e{2}} that 
                                         \inopenv{\openv{}}{\path {\pathelem{2}} {\y{}}}{\v{2}}
  \opsem {\extendopenv {\openv{c}} {\x{}} {\v{2}}}
         {\e{b}}
         {\v{}}

             \end{itemize}
           \item otherwise \object{f} = {\path {\pathelem{f}} {\y{}}} where $\x{} \not= \y{}$
         \end{itemize}


         To prove part 2, if \v{} $\not=$ \false\ (or \nil)
\end{subcase}
  \item[]
\begin{subcase}[B-BetaMulti]
  \opsem {\openv{}}
         {\e{1}}
         {\multi {\v{d}} {m}},
  \opsem {\openv{}}
         {\e{2}}
         {\v{2}},
  \opsem {\openv{}}
         {\appexp {\v{d}} {\v{2}}}
         {\v{e}},
  \getmethod {\disptable{}}
             {\v{e}}
             {\v{f}},
  \opsem {\openv{}}
         {\appexp {\v{f}} {\v{2}}}
         {\v{}}

\end{subcase}
  \item[]
\begin{subcase}[B-Delta]
  \opsem {\openv{}} {\e{1}} {\const{}},
  \opsem {\openv{}} {\e{2}} {\v{2}},
  \constantopsem{\const{}}{\v{2}} = \v{}

  % TODO do I need to prove anything about the argument in the definition
  % of the constant being under \s{}?

  Prove by cases on \const{}.
  \begin{itemize}
    \item[] \begin{subcase}[\const{} = \classconst]
    ${\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}$
                                                       =
  ${\ArrowOne {\x{}} {\Top{}}
                                      {\Union{\nil{}}{\Class{}}}
                                      {\filterset {\topprop{}}
                                                  {\topprop{}}}
                                      {\path {\classpe{}} {\x{}}}}$

    Prove by cases on \v{2}.

        \begin{itemize}
          \item[] \begin{subcase}[\v{2} = \classvalue{\class{}} {\overrightarrow {\classfieldpair{\fld{i}} {\v{i}}}}]
                    \v{} = \class{}

                    To prove part 1, note \object{} = {\replacefor {\object{f}}{\object{2}}{\x{}}} 
                    and \object{f} = {\path {\classpe{}} {\x{}}}.
                    There are two cases defined by substitution: if \object{2} = \emptyobject{} then \object{} = \emptyobject{}
                    and we are done,
                    or if \object{2} = {\path {\pathelem{}} {\xp{}}} then \object{} = 
                    {\path {\classpe{}}{\object{2}}},
                    by the induction hypothesis on \e{2} \inopenv {\openv{}} {\object{2}} {\v{2}}
                    and by the definition of path translation
                    {\openv{}}({\path {\classpe{}} {\object{2}}}) = {\appexp {\classconst{}} {{\openv{}}(\object{2})}},
                    which evaluates to \v{}.

                    Part 2 is trivial since both propositions are \topprop{} by substitution.
                    
                    Part 3 holds because {\judgementtwo{}{\hastype{\v{2}}{\Class{}}}}.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = \class{}] \v{} = \Class{}

              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = \true{}] \v{} = \Boolean{}

              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = \false{}] \v{} = \Boolean{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}] \v{} = \IFn{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\multi {\v{d}} {\disptable{}}}] \v{} = \HMapInstance{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\curlymapvaloverright{\v{1}}{\v{2}}}] \v{} = \Keyword{}


              As above.
                  \end{subcase}
          \item[] \begin{subcase}[\v{2} = {\nil{}}] \v{} = \nil{}

             Parts 1 and 2 as above.
                    Part 3 holds because {\judgementtwo{}{\hastype{\v{2}}{\Nil}}}.
                  \end{subcase}
        \end{itemize}
      \end{subcase}
    \item[]
      \begin{subcase}[\const{} = \throwconst]
        {\ArrowOne {\x{}} {\s{}}
                                                       {\t{f}}
                                                       {\filterset {\thenprop {\prop{f}}}
                                                                   {\elseprop {\prop{f}}}}
                                                       {\object{f}}}
                                                       =
        {\ArrowOne {\x{}} {\Top{}}
                                      {\Bot{}}
                                      {\filterset {\botprop{}}
                                                  {\botprop{}}}
                                      {\emptyobject{}}}

                                      Part 1 is trivial since \object{} = \emptyobject{} after substition.
                                      Part 2 holds vacuously as both propositions are \botprop{} after substition.
                                      Finally part 3 holds since {\judgementtwo{}{\hastype{\errorval{\v{2}}}{\Bot{}}}}.

      \end{subcase}
  \end{itemize}

\end{subcase}
  \item[]
\begin{subcase}[BE-Beta1]
\end{subcase}
  \item[]
\begin{subcase}[BE-Beta2]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaClosure]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaMulti1]
\end{subcase}
  \item[]
\begin{subcase}[BE-BetaMulti2]
\end{subcase}
\end{itemize}
\end{case}

\begin{case}[T-IsA]\e{} = {\isaapp {\e{1}} {\e{2}}},
  \t{} = {\Boolean{}},
  \judgement {\propenv{}} {\hastype {\e{1}} {\t{1}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
                       {\object{1}},
  \judgementtwo {\propenv{}} {\hastype {\e{2}} {\t{2}}},
  \isacompare{\t{1}}{\object{1}}{\t{2}}{\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}},
  \object{} = \emptyobject{}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-IsA]
  \opsem {\openv{}} {\e{1}} {\v{1}},
  \opsem {\openv{}} {\e{2}} {\v{2}},
  \isaopsem{\v{1}}{\v{2}} = {\v{}}

  From the definition of \isacompareliteral,
  \thenprop{\prop{}} = {\replacefor{\isprop{\t{2}}{\x{}}}{\object{1}}{\x{}}} and
  \elseprop{\prop{}} = {\replacefor{\notprop{\t{2}}{\x{}}}{\object{1}}{\x{}}}.

  Part 1 holds trivially with \object{} = \emptyobject{}.
  For part 2, if \v{} $\not=$ \false\ (or \nil)
  then {\satisfies{\openv{}}{\replacefor{\isprop{\t{2}}{\x{}}}{\object{1}}{\x{}}}}, as by the definition
  of \isaopsemliteral either 
  \begin{itemize}
    \item \v{1} = \v{2} so {\v{2}} must be the same type as down {\object{1}}, or
    \item \v{1} = \classvaluemeta{1} and \v{2} = \classvaluemeta{2} where \classvaluemeta{1}
  is a subclass of \classvaluemeta{2}, so {\v{2}} may be be safely upcast to the same type as down {\object{1}}.
  \end{itemize}
  Part 3 holds because by the definition of \isaopsemliteral
  \v{} can only be \true or \false, which are both subtypes of
  \t{}.


      \end{subcase}
    \item[]
      \begin{subcase}[BE-IsA1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-IsA2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMap]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  $\t{} = {\Unionsplice {\overrightarrow {\t{i}}}}$
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  $\judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}}$,
  $\judgement {\propenv{}} {\hastype {\e{m}} {\Unionsplice {\overrightarrow {\HMapgeneric {\mandatory{}} {\absent{}}}}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}}$,
  $\overrightarrow{\inmandatory{\k{}}{\t{i}}{\mandatory{}}}$


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
      $\opsem {\openv{}} {\e{m}}{\v{m}}$,
        $\v{m} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \opsem {\openv{}} {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

         To prove part 1 we consider two cases on the form of \object{m}: 
         \begin{itemize}
           \item
         if {\object{m}} = \emptyobject{}
         then \object{} = \emptyobject{} by substitution, which gives the desired result;
           \item
         if \object{m} = {\path {\pathelem{m}} {\x{m}}}
         then \object{} = {\path {\keype{k}} {\object{m}}} by substitution.
         We note by the definition of path translation
         {\openv{}}({\path {\keype{k}} {\object{m}}}) =
         {\getexp {{\openv{}}(\object{m})}{\k{}}}
         and by the induction hypothesis on \e{m}
         {{\openv{}}(\object{m})} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
         which together imply 
         \inopenv {\openv{}} {\object{}} {\getexp {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}}}.
         Since this is the same form as B-Get, we can apply the premise
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}
         to derive \inopenv {\openv{}} {\object{}} {\v{}}.
         \end{itemize}
         
         Part 2 holds trivially as \thenprop{\prop{}} = {\topprop{}}
         and \elseprop{\prop{}} = {\topprop{}}.

         To prove part 3 we note that (by the induction hypothesis on \e{m})
         $\judgementtwo{}{\hastype{\v{m}}{\Unionsplice{\overrightarrow {\HMapgeneric {\mandatory{}} {\absent{}}}}}}$,
         where $\overrightarrow{\inmandatory{\k{}}{\t{i}}{\mandatory{}}}$, and 
         both
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
         and
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}
         imply \judgementtwo{}{\hastype{\v{}}{\Unionsplice {\overrightarrow {\t{i}}}}}.

      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

       Unreachable subcase because 
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
       contradicts ${\inmandatory{\k{}}{\t{}}{\mandatory{}}}$.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMapAbsent]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \t{} = \Nil,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}},
  \judgement {\propenv{}} {\hastype {\e{m}} {\HMapgeneric {\mandatory{}} {\absent}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}},
  {\inabsent{\k{}}{\absent{}}}


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}} {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

       Unreachable subcase because 
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         contradicts
                {\inabsent{\k{}}{\absent{}}}.
      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

         To prove part 1 we consider two cases on the form of \object{m}: 
         \begin{itemize}
           \item
         if {\object{m}} = \emptyobject{}
         then \object{} = \emptyobject{} by substitution, which gives the desired result;
           \item
         if \object{m} = {\path {\pathelem{m}} {\x{m}}}
         then \object{} = {\path {\keype{k}} {\object{m}}} by substitution.
         We note by the definition of path translation
         {\openv{}}({\path {\keype{k}} {\object{m}}}) =
         {\getexp {{\openv{}}(\object{m})}{\k{}}}
         and by the induction hypothesis on \e{m}
         {{\openv{}}(\object{m})} = {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
         which together imply 
         \inopenv {\openv{}} {\object{}} {\getexp {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}}}.
         Since this is the same form as B-GetMissing, we can apply the premise
        \v{} = \nil\ 
         to derive \inopenv {\openv{}} {\object{}} {\v{}}.
         \end{itemize}
         
         Part 2 holds trivially as \thenprop{\prop{}} = {\topprop{}}
         and \elseprop{\prop{}} = {\topprop{}}.
         To prove part 3 we note that \e{m} has type {\HMapgeneric {\mandatory{}} {\absent{}}}
         where {\inabsent{\k{}}{\absent{}}}, and
         the premises of B-GetMissing
         \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
         and
          \v{} = \nil\ 
         tell us {\v{}} must be of type {\t{}}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-GetHMapPartialDefault]
  \e{} = {\getexp {\e{m}} {\e{k}}},
  \t{} = \Top,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\topprop{}},
  \object{} = {\replacefor
               {\path {\keype{k}} {\x{}}}
                          {\object{m}}
                          {\x{}}},
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value {k}}},
 \judgement {\propenv{}} {\hastype {\e{m}} {\HMapp {\mandatory{}} {\absent}}}
           {\filterset {\thenprop {\prop{m}}} {\elseprop {\prop{m}}}}
           {\object{m}},
             ${\notinmandatory{\k{}}{\t{}}{\mandatory{}}}$,
             {\notinabsent{\k{}}{\absent{}}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Get]
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$
        ,
         \opsem {\openv{}}
                 {\e{k}} {\k{}},
         $\keyinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
         \getmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}} {\k{}} = {\v{}}

         Parts 1 and 2 are the same as the B-Get subcase of T-GetHMap.
         Part 3 is trivial as \t{} = \Top.


      \end{subcase}
    \item[]
      \begin{subcase}[B-GetMissing]
        \v{} = \nil,
        $\opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}$,
       \opsem {\openv{}} {\e{k}} {\k{}},
       \keynotinmap{\k{}}{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}

         Parts 1 and 2 are the same as the B-GetMissing subcase of T-GetHMapAbsent.
         Part 3 is trivial as \t{} = \Top.

      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Get2]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-AssocHMap]
  \e{} = {\assocexp {\e{m}} {\e{k}} {\e{v}}},
  \t{} = ${\HMapgeneric {\extendmandatoryset {\mandatory{}}{\k{}}{\t{}}} {\absent}}$,
  \thenprop{\prop{}} = {\topprop{}},
  \elseprop{\prop{}} = {\botprop{}},
  \object{} = \emptyobject,
  \judgementtwo {\propenv{}} {\hastype {\e{m}} {\HMapgeneric {\mandatory{}} {\absent}}},
  \judgementtwo {\propenv{}} {\hastype {\e{k}} {\Value{\k{}}}},
  \judgementtwo {\propenv{}} {\hastype {\e{v}} {\t{}}},
  {\k{}} $\not\in$ {\absent{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Assoc]
        \v{} = 
        {\extendmap{\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}}
                {\k{}}{\v{v}}},
        \opsem {\openv{}}
        {\e{m}} {\curlymap{\overrightarrow{({\v{a}}\ {\v{b}})}}},
        \opsem {\openv{}} {\e{k}} {\k{}},
        \opsem {\openv{}} {\e{v}} {\v{v}}

        Parts 1 and 2 hold for the same reasons as T-True.
        %TODO part 3
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc1]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc2]
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Assoc3]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-If] \e{} = {\ifexp {\e1} {\e2} {\e3}},
  \judgement {\propenv{}} {\hastype {\e1} {\t{1}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
                 {\object{1}},
  \judgement {\propenv{}, {\thenprop {\prop{1}}}}
                 {\hastype {\e2} {\t{}}} {\filterset {\thenprop {\prop{2}}} {\elseprop {\prop{2}}}}
                 {\object{}},
  \judgement {\propenv{}, {\elseprop {\prop{1}}}}
                 {\hastype {\e3} {\t{}}} {\filterset {\thenprop {\prop{3}}} {\elseprop {\prop{3}}}}
                 {\object{}},
  \thenprop{\prop{}} = {\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}},
  \elseprop{\prop{}} = {\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-IfTrue]
        \opsem {\openv{}} {\e{1}} {\v{1}},
              ${\v{1}} \not= {\false}$,
              ${\v{1}} \not= {\nil}$,
              \opsem {\openv{}} {\e{2}} {\v{}}

              For part 1, either \object{} = \emptyobject{}, or \e{} evaluates to the
              result of \e{2}.

              To prove part 2, we consider two cases:
              \begin{itemize}
                \item if \v{} = \false\ (or \nil)
                  then \e{2} evaluates to a false value so {\satisfies{\openv{}}{\elseprop {\prop{2}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}} by M-Or, 
                \item otherwise
                  ${\v{}} \not= {\false}$ and
                  ${\v{}} \not= {\nil}$,
                  so \e{2} evaluates to a true value so {\satisfies{\openv{}}{\thenprop {\prop{2}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}}} by M-Or.
              \end{itemize}

              Part 3 is trivial as
              \opsem {\openv{}} {\e{2}} {\v{}}
              and {\judgementtwo{}{\hastype{\v{}}{\t{}}}} by the induction hypothesis on {\e{2}}.


      \end{subcase}
    \item[]
      \begin{subcase}[B-IfFalse]
        \opsem {\openv{}} {\e{1}} {\false}
        \ \ \text{or}\ \ 
        \opsem {\openv{}} {\e{1}} {\nil},
        \opsem {\openv{}} {\e{3}} {\v{}}

              For part 1, either \object{} = \emptyobject{}, or \e{} evaluates to the
              result of \e{3}.

              To prove part 2, we consider two cases:
              \begin{itemize}
                \item if \v{} = \false\ (or \nil)
                  then \e{3} evaluates to a false value so {\satisfies{\openv{}}{\elseprop {\prop{3}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\elseprop {\prop{2}}} {\elseprop {\prop{3}}}}} by M-Or, 
                \item otherwise
                  ${\v{}} \not= {\false}$ and
                  ${\v{}} \not= {\nil}$,
                  so \e{3} evaluates to a true value so {\satisfies{\openv{}}{\thenprop {\prop{3}}}}, and thus
                  {\satisfies{\openv{}}{\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}}} by M-Or.
              \end{itemize}

              Part 3 is trivial as
              \opsem {\openv{}} {\e{3}} {\v{}}
              and {\judgementtwo{}{\hastype{\v{}}{\t{}}}} by the induction hypothesis on {\e{3}}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-If]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Let]
  \e{} = {\letexp {\x{}} {\e{1}} {\e{2}}},
  \judgement {\propenv{}} {\hastype {\e{1}} {\s{}}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
             {\object{1}},
             \propp{} = {\impprop {\notprop {\falsy{}} {\x{}}} {\thenprop {\prop{1}}}},
             \proppp{} = {\impprop {\isprop {\falsy{}} {\x{}}} {\elseprop {\prop{1}}}},
  \judgement
       {\propenv{}, {\isprop {\s{}} {\x{}}},
         {\propp{}},
         {\proppp{}}}
             {\hastype {\e{2}} {\t{}}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\object{}} 


  \begin{itemize}
    \item[]
      \begin{subcase}[B-Let]
        \opsem {\openv{}} {\e{1}} {\v{1}},
        \opsem {\extendopenv{\openv{}}{\x{}}{\v{1}}} {\e{2}} {\v{}}

        For all the following cases (with a reminder that \x{} is fresh)
        we apply the induction hypothesis on \e{2}. We justify this by noting
        that occurrences of \x{} inside \e{2} have the same type as \e{1} and 
        simulate the propositions of \e{1}
        because 
        \opsem {\openv{}} {\e{1}} {\v{1}},
        and
        \opsem {\extendopenv{\openv{}}{\x{}}{\v{1}}} {\e{2}} {\v{}},
        so \satisfies{\openv{}}{\propenv{}, {\isprop {\s{}} {\x{}}}, \propp{}, \proppp{}},
        by M-And.

        We prove parts 1, 2 and 3 by directly using the induction hypothesis on \e{2}.
      \end{subcase}
    \item[]
      \begin{subcase}[BE-Let]
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Clos] \e{} = {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}},
  {\thenprop {\prop{}}}
  $\exists {\propenvp{}}. \satisfies{\openv{}}{\propenvp{}}$
  \ \text{and}\ 
\judgement {\propenvp{}} {\hastype {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}}
                 {\filterset {\thenprop {\prop{}}}
                             {\elseprop {\prop{}}}}
                 {\object{}}

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Abs] \v{} = {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}

        We assume some \propenvp{}, such that
        \begin{itemize}
          \item \satisfies{\openv{}}{\propenvp{}}
          \item \judgement {\propenvp{}} {\hastype {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}}
                           {\filterset {\thenprop {\prop{}}}
                                       {\elseprop {\prop{}}}}
                           {\object{}}.
       \end{itemize}
       Note the last rule in the derivation of
          \judgement {\propenvp{}} {\hastype {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}}
                           {\filterset {\thenprop {\prop{}}}
                                       {\elseprop {\prop{}}}}
                           {\object{}}
                           must be T-Abs, so 
                           {\thenprop {\prop{}}} = {\topprop{}},
                           {\elseprop {\prop{}}} = {\botprop{}}
                           and {\object{}} = {\emptyobject{}}.
         Thus parts 1 and 2 hold for the same reasons as T-True.
         Part 3 holds as \v{} has the same type as {\abs {\x{}} {\s{}} {\e{1}}}
         under \propenvp{}.

      \end{subcase} 
  \end{itemize}
\end{case}

\begin{case}[T-Multi] \e{} = {\multi {\v{1}} {\curlymapvaloverright{\v{k}}{\v{v}}}},
  \t{} = {\MultiFntype {\s{}} {\t{1}}},
  {\thenprop {\prop{}}} = {\topprop{}},
  {\elseprop{\prop{}}} = {\botprop{}},
  {\object{}} = {\emptyobject{}},
  \judgementtwo {} {\hastype {\v{1}} {\t{1}}},
  $\overrightarrow{\judgementtwo{}{\hastype{\v{k}}{\Top{}}}}$,
  $\overrightarrow{\judgementtwo{}{\hastype{\v{v}}{\s{}}}}$

  \begin{itemize}
    \item[]
      \begin{subcase}[B-Val] \v{} = {\multi {\v{1}} {\curlymapvaloverright{\v{k}}{\v{v}}}}

        Similar to T-True.
      \end{subcase}
  \end{itemize}

\end{case}

\begin{case}[T-Abs] \e{} = {\abs {\x{}} {\s{}} {\e{1}}},
  \t{} = {\ArrowOne {\x{}} {\s{}}
                                                      {\t{1}}
                                                      {\filterset {\thenprop {\prop{1}}}
                                                                  {\elseprop {\prop{1}}}}
                                                      {\object{1}}},
  {\thenprop{\prop{}}}= {\topprop{}},
  {\elseprop{\prop{}}}= {\botprop{}},
  {\object{}}= {\emptyobject{}},
{ \judgement {\propenv{}, {\isprop {\s{}} {\x{}}}}
            {\hastype {\e{1}} {\t{}}}
             {\filterset {\thenprop {\prop{1}}}
                         {\elseprop {\prop{1}}}}
             {\object{1}}},
\judgement {\propenv{}} {\hastype {\abs {\x{}} {\s{}} {\e{1}}} {\t{}}}
                 {\filterset {\thenprop {\prop{}}}
                             {\elseprop {\prop{}}}}
                 {\object{}}

  \begin{itemize}
    \item[]
      %TODO
      \begin{subcase}[B-Abs]
        \v{} = ${\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}$,
          { \opsem {\openv{}}
                   {\abs {\x{}} {\t{}} {\e{1}}}
                   {\closure {\openv{}} {\abs {\x{}} {\s{}} {\e{1}}}}}

        Parts 1 and 2 hold for the same reasons as T-True.
        Part 3 holds directly via T-Clos, since \v{} must be a closure.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Error]
  \e{} = \errorval{\v{1}},
  \t{} = \Bot,
  \thenprop{\prop{}} = \botprop{}, \elseprop{\prop{}} = \botprop{}, \object{} = \emptyobject{}


  \begin{itemize}
    \item[]
      \begin{subcase}[BE-Error] 
        \opsem {\openv{}} {\e{}} {\errorval{\v{1}}}

        Trivially reduces to an error.
      \end{subcase}
  \end{itemize}
\end{case}

\begin{case}[T-Subsume]
  \judgement {\propenv{}} {\hastype {\e{}} {\tp{}}}
             {\filterset {\thenprop {\propp{}}}
                         {\elseprop {\propp{}}}}
             {\objectp{}},
\inpropenv {\propenv{}, {\thenprop {\propp{}}}} {\thenprop {\prop{}}},
\inpropenv {\propenv{}, {\elseprop {\propp{}}}} {\elseprop {\prop{}}},
\inpropenv {} {\issubtype {\tp{}} {\t{}}},
\inpropenv {} {\issubtype {\objectp{}} {\object{}}}

Part 1 holds because \objectp{} is the object of \e{}
and \inpropenv {} {\issubtype {\objectp{}} {\object{}}}.
Part 2 holds because 
the then and else propositions of \e{} are
{\thenprop {\propp{}}} and 
{\elseprop {\propp{}}} respectively, so
{\thenprop {\prop{}}} and
{\elseprop {\prop{}}} are also respectively as 
\inpropenv {\propenv{}, {\thenprop {\propp{}}}} {\thenprop {\prop{}}} and
\inpropenv {\propenv{}, {\elseprop {\propp{}}}} {\elseprop {\prop{}}}.
Part 3 holds because \e{} is of type \tp{} and 
\inpropenv {} {\issubtype {\tp{}} {\t{}}}.

\end{case}

\begin{case}[T-Const]\e{} = {\const{}},
  \t{} = {\constanttype{\const{}}},
{\thenprop{\prop{}}} = {\topprop{}},
{\elseprop{\prop{}}} = {\botprop{}},
{\object{}} = {\emptyobject{}}

  \begin{itemize}
    \item[] 
      \begin{subcase}[B-Val]
        Parts 1, 2 and 3 hold for the same reasons as T-True. 
      \end{subcase}
  \end{itemize}
\end{case}

\end{proof}

\end{lemma}

\begin{theorem}[Well-typed programs don't go wrong] \label{theorem:wrong}
  If {\judgement {} {\hastype {\e{}} {\t{}}} {\filterset {\thenprop{\prop{}}}{\elseprop{\prop{}}}} {\object{}}}
  then \notopsem{}{\e{}}{\wrong{}}.

\begin{proof}
  Corollary of lemma \ref{lemma:soundness}, since 
  when {\judgement {} {\hastype {\e{}} {\t{}}} {\filterset {\thenprop{\prop{}}}{\elseprop{\prop{}}}} {\object{}}}
    , by lemma \ref{lemma:soundness}, either
    \opsem {} {\e{}} {\v{}} or
    \opsem {} {\e{}} {\errorvalv{}}, therefore \notopsem{}{\e{}}{\wrong{}}.
\end{proof}
\end{theorem}

\begin{theorem}[Type soundness] \label{theorem:soundness}
If \judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}
and \opsem {\openv{}} {\e{}} {\v{}} 
then \judgement{}{\hastype{\v{}}{\t{}}}{\filterset{\thenprop{\propp{}}}{\elseprop{\propp{}}}}{\objectp{}}
        for some \thenprop{\propp{}}, \elseprop{\propp{}} and {\objectp{}}

\begin{proof}
  Corollary of lemma \ref{lemma:soundness}.
\end{proof}

\end{theorem}
