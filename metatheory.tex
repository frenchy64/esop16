\section{Metatheory}
\label{sec:metatheory}

Our proof for type soundness is similar to~\citet{TF10}. We add
errors and \wrong{} value and prove
well-typed programs do not go wrong.

We make our assumptions about Java explicit. We concede that
method and constructor calls may diverge or error, but we assume they can
never go wrong.

{\javanewassumption{main}}

%For readability we define logical truth in Clojure.

%{\istruefalsedefinitions{main}}

We use an extra lemma to support our main soundness lemma. Consistency
ensures that occurrence typing does not refer to variables
hidden inside a closure.

{\consistentwithonlydef{main}}

Our main lemma says if there is a defined reduction, then the propositions, object
and type are correct.
The metavariable \definedreduction{} ranges over \v{}, \errorvalv{} and \wrong{}.

\begin{lemma}\label{main:lemma:soundness}

  {\soundnesslemmahypothesis}
  \begin{proof}
    By induction on the derivation of the typing judgement. 
    (Full proof given as lemma~\ref{appendix:lemma:soundness}).
  \end{proof}
\end{lemma}


We can now state our soundness theorem.

{\soundnesstheoremnoproof{main}}

{\wrongtheoremnoproof{main}}
\noindent
As a corollary, null-pointer exceptions are ruled-out in typed code.
%
%{\nilinvoketheoremnoproof{main}}
