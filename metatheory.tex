\section{Metatheory}
\label{sec:metatheory}

We prove type soundness follow using the same technique as~\citet{TF10}. 
We also include errors and a \wrong{} value and prove
well-typed programs do not go wrong.

Rather than modeling Java's dynamic semantics, we instead
make our assumptions about Java explicit. We concede that
method and constructor calls may diverge or error, but we assume they can
never go wrong. (Assumptions for other operations are given in the supplemental
material).

{\javanewassumption{main}}



%For readability we define logical truth in Clojure.

%{\istruefalsedefinitions{main}}

For the purposes of our soundness proof, we require that all values
are \emph{consistent}.
Consistency
ensures that occurrence typing does not refer to variables
hidden inside a closure.

{\consistentwithonlydef{main}}

Our main lemma says if there is a defined reduction, then the propositions, object
and type are correct.
The metavariable \definedreduction{} ranges over \v{}, \errorvalv{} and \wrong{}.

\begin{lemma}\label{main:lemma:soundness}

  {\soundnesslemmahypothesis}
  \begin{proof}
    By induction on the derivation of the operational semantics.
    (Full proof given as lemma~\ref{appendix:lemma:soundness}).
  \end{proof}
\end{lemma}


We can now state our soundness theorem.

{\soundnesstheoremnoproof{main}}

{\wrongtheoremnoproof{main}}
%
%{\nilinvoketheoremnoproof{main}}
