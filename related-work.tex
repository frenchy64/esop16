\section{Related Work}

% Cite a few of the early papers here.
%http://www.cs.washington.edu/research/projects/cecil/www/pubs/
\paragraph{Multimethods} 
\citeauthor{MS02} and collaborators present a sequence of
systems~\cite{MS02, cecil, more} with statically-typed multimethods
and modular type checking.  In contrast to Typed Clojure, in these
system methods declare the types of arguments that they expect which
corresponds to exclusively using \clj{class} as the dispatch function
in Typed Clojure. However, Typed Clojure does not attempt to rule out
failed dispatches at runtime.

% one sentence
% TC based on TR, already covered

%\paragraph{Occurrence Typing} 
%Occurrence typing~\cite{TF08,TF10} extends the type 
%system with a \emph{proposition environment} that represents 
%the information on the types of bindings down conditional branches.
%These propositions are then used to update the types associated
%with bindings in the \emph{type environment} down branches
%so binding occurrences are given different types 
%depending on the branches they appear in, and the conditionals
%that lead to that branch.

% What's diff about TC from the related work
% small summary for deisel....
% - diesel supports x
%- - calculus supports some subset of x
% we support y, which covers most of x but also foo

% eg. multiple dispatch
%     nominal vs structural

% eg. run abritrary metaprogramming over dispatch in CLOS
%  more expressive

% type systems for mm or rows
% rows vs HMap
% - no poly in HMap
% - based on subtyping
% - rows based on polymorphism

\paragraph{Record Types} Row polymorphism~\cite{Wan89,CM91,HP91}, used
in systems such as the OCaml object system, provides many of the
features of HMap types, but defined using universally-quantified row
variables. HMaps in Typed Clojure are instead designed to be used with
subtyping, but nonetheless provide similar expressiveness, including
the ability to require presence and absence of certain keys. 

Dependent JavaScript~\cite{Chugh:2012:DTJ} can track similar
invariants as HMaps with types for JS objects. They must deal with
mutable objects, they feature refinement types and strong updates to
the heap to track changes to objects.

Typed Lua~\cite{Maidl:2014:TLO} has \emph{table types} which track
entries in a mutable Lua table.  Typed Lua changes the dynamic
semantics of Lua to accommodate mutability: Typed Lua raises a runtime
error for lookups on missing keys---HMaps consider lookups on missing
keys normal.

The integration of completeness information, crucial for many examples
in Typed Clojure, is not provided by any of these systems.

\paragraph{Java Interoperability in Statically Typed Languages}
Scala~\cite{OCD+} has nullable references for compatibility with Java.
Programmers must manually check for
\java{null} as in Java to avoid null-pointer exceptions. 


\paragraph{Optional type systems}
Reticulated Python~\cite{Vitousek14} is a gradually typed
system for Python, implemented as a source-to-source
translation that inserts dynamic checks at language boundaries
and supporting Python's first-class object system.
Typed Clojure is implemented as a syntactic check on Clojure
code with no option to insert dynamic checks automatically.
Typed Clojure does not support a first-class object system
because Java has nominal classes, however HMaps offer a subset 
of the structural features offered by Reticulated.

%  \item GradualTalk
%  \item Flow
%\end{itemize}


