\section{Related Work}

\paragraph{Multimethods} 
\citet{MS02} describe Dubious, a simple statically typed core language including multimethods that
dispatch on the type of its arguments. 
In Dubious methods declare the types of arguments that they expect which corresponds to
exclusively using \clj{class} as the dispatch function in Typed Clojure.

% one sentence
% TC based on TR, already covered

%\paragraph{Occurrence Typing} 
%Occurrence typing~\cite{TF08,TF10} extends the type 
%system with a \emph{proposition environment} that represents 
%the information on the types of bindings down conditional branches.
%These propositions are then used to update the types associated
%with bindings in the \emph{type environment} down branches
%so binding occurrences are given different types 
%depending on the branches they appear in, and the conditionals
%that lead to that branch.

% What's diff about TC from the related work
% small summary for deisel....
% - diesel supports x
%- - calculus supports some subset of x
% we support y, which covers most of x but also foo

% eg. multiple dispatch
%     nominal vs structural

% eg. run abritrary metaprogramming over dispatch in CLOS
%  more expressive

% type systems for mm or rows
% rows vs HMap
% - no poly in HMap
% - based on subtyping
% - rows based on polymorphism

\paragraph{Record Types} Row polymorphism~\cite{Wan89,CM91,HP91}, used
in systems such as the OCaml object system, provides many of the
features of HMap types, but defined using universally-quantified row
variables. HMaps in Typed Clojure are instead designed to be used with
subtyping, but nonetheless provide similar expressiveness, including
the ability to require presence and absence of certain keys. 

Dependent JavaScript~\cite{Chugh:2012:DTJ} can track similar
invariants as HMaps with types for JS objects. They must deal with
mutable objects, they feature refinement types and strong updates to
the heap to track changes to objects.

Typed Lua~\cite{Maidl:2014:TLO} has \emph{table types} which track
entries in a mutable Lua table.  Typed Lua changes the dynamic
semantics of Lua to accommodate mutability: Typed Lua raises a runtime
error for lookups on missing keys---HMaps consider lookups on missing
keys normal.

The integration of completeness information, crucial for many examples
in Typed Clojure, is not provided by any of these systems.

\paragraph{Optional type systems}
\begin{itemize}
  \item Reticulated Python~\cite{Vitousek14}
  \item GradualTalk
  \item Flow
\end{itemize}

