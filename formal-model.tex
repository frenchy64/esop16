\section{A Formal Model of \lambdatc{}}

\label{sec:formal}

Now that we have demonstrated the core features Typed Clojure
provides, we link them together in a formal model called
\lambdatc{}.

Building on occurrence typing,
we incrementally add each
novel feature of Typed Clojure to the formalism,
interleaving presentation of syntax, typing rules, operational semantics,
and subtyping.

\subsection{Occurrence typing}

Our presentation will start with a review of
occurrence typing~\cite{TF10}, the foundation of \lambdatc{}.
We build up the occurrence typing calculus for illustrative purposes, 
and present the full syntax at the end of the section.

\paragraph{Logical formulas over type environments}
Standard type systems use type environments to track lexical type information.
Introducing a lexically scoped variable $x$ is a matter of associating 
associating $x$ with its type $\Number$ (a number) in the type environment.
Correspondingly, checking the type of a variable is a simple map lookup.
$$
\begin{array}{lr}
\judgementtwo{\x{} \mapsto \Number}{\appexp{\inc{}}{\x{}}}{\Number}
&
\infer [LC-Local]
{ {\propenv{}}(\x{}) = {\t{}}
}
{ \judgementtwo {\propenv{}} 
            {\x{}} {\t{}}
           }
\end{array}
$$

Occurrence typing takes a different approach.
The same information is conveyed by \emph{logical formulas}.
The logical statement {\isprop{\Number{}}{\x{}}} says the value
obtained via $x$ is of type \Number{}. We now must \emph{prove}
a variable's type via a \emph{logical system}.
$$
\begin{array}{lr}
\judgementtwo{\isprop{\Number{}}{\x{}}}{\appexp{\inc{}}{\x{}}}{\Number}
&
\infer [T-LocalProve]
{ \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}}
{ \judgementtwo {\propenv{}} 
            {\x{}} {\t{}}
           }
\end{array}
$$
The proof system judgment { \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}}
says logical assumptions {\propenv{}} prove variable \x{} is of type \t{}.

\paragraph{Symbolic representations}
As we saw in \secref{sec:overview},
occurrence typing is capable of reasoning
about deeply nested expressions.
For each expression, the type system assigns a symbolic representation
with respect to the current lexical environment. For example,

\begin{itemize}
  \item $x$ is represented as $x$; 
  \item $\appexpone{\ccclass{\appexp{\makekw{lunch}}{m}}}$ is represented as ${\path{\classpe{}}{\path{\keype{\makekw{lunch}}}{m}}}$;
  \item $42$ has no representation, called \emptyobject{}.
\end{itemize}

This symbolic representation is called the expression's \emph{object}. 
\figref{main:figure:termsyntax} gives the syntax for objects.
\emptyobject{} is the
\emph{empty object}. Non-empty objects \path{\pathelem{}}{\x{}} consist of a symbol \x{} and a \emph{path} \pathelem{},
which is a possibly-empty sequence of \emph{path elements} applied right-to-left.
This paper uses two path elements---{\classpe{}} and {\keype{k}}---representing a call to \classconst{} and
a keyword lookup on $k$ respectively.


%The particular part of the runtime environment we reference in a
%type proposition is called the \emph{object}.
%The typing judgment relates an object to every expression in the language.
%An object is either \emph{empty}, written \emptyobject{}, 
%which says 
%this expression is not known to evaluate to a particular part
%  of the current runtime environment, or a 
%variable with some \emph{path}, written \path{\pathelem{}}{\x{}},
%that exactly indicates how the value of this
%expression can be derived from the current runtime environment.
%Type propositions can only reference non-empty objects.

\paragraph{Logical statements about objects}
So far we have seen logical statements about the simplest object, a variable---{\isprop{\t{}}{\x{}}},
saying variable \x{} is of type \t{}.
We extend logical statements to reason about \emph{arbitrary} non-empty 
objects {\isprop{\t{}}{\path{\pathelem{}}{\x{}}}}.

To illustrate, recall \egref{example:desserts-on-meal}.
We know the parameter $o$ is of type $\Order$
by the annotation on $desserts$---written
\begin{equation}
\qquad {\isprop{\Order}{o}}
\end{equation}
as a logical statement.
%
In checking the ${\makekw{combo}}$ method, we also assume
${\appexp{\makekw{Meal}}{o}}$ is ${\makekw{combo}}$,
based on multimethod dispatch rules. This is written
\begin{equation}
  \qquad {\isprop{\Value{\makekw{combo}}}{\path{\keype{\makekw{Meal}}}{o}}}
\end{equation}
and pronounced ``the ${\makekw{Meal}}$ path of variable $o$ is of type
{\Value{\makekw{combo}}}'', a keyword singleton type.

\paragraph{Logical system in action} At some point in checking the {\makekw{combo}} method,
we will need the type of $o$.
Our proposition environment consists of both above facts
$$
\propenv{} = {{\isprop{\Order}{o}},
    {\isprop{\Value{\makekw{combo}}}{\path{\keype{\makekw{Meal}}}{o}}}}
$$
and T-LocalProve says $o$ is of type \t{} if \propenv{} \emph{proves} $o$ is of type \t{}
$$
{ \inpropenv 
  {\propenv{}}
  {\isprop {\t{}} {o}}}
$$
The logical system deduces \t{} as being a {\makekw{combo}} meal.

Now the purpose of a logical representation can be conveyed---we rely on the logical
system to combine pieces of type information to deduce more accurate types for lexical
bindings.

\paragraph{Extension to propositional logic}
The kinds of logical statements are extended to \emph{propositional logic}.
\figref{main:figure:termsyntax} describes the syntax we will use for the rest of the paper.
The proposition metavariable \prop{} 
consists of positive and negative \emph{type propositions} 
about non-empty objects---{\isprop {\t{}} {\path {\pathelem{}} {\x{}}}}
and {\notprop {\t{}} {\path {\pathelem{}} {\x{}}}}
respectively---the former we have seen before, 
the latter pronounced ``the object {\path {\pathelem{}} {\x{}}} is \emph{not} of type \t{}''.
The other propositions are standard logical connectives: implications, conjunctions,
disjunctions, and the trivial (\topprop{}) and impossible (\botprop{}) propositions.

%The first insight about occurrence typing is that
%logical formulas
%can be used to represent type information about our programs
%by relating parts of the runtime environment to types
%via propositional logic.
%\emph{Type propositions}  make assertions like ``variable \x{} is of type \NumberFull{}'' or
%``variable \x{} is not \nil{}''---in our logical system we write these as
%{\isprop{\NumberFull}{\x{}}}
%and {\notprop{\Nil{}}{\x{}}}. 
%
%The second insight is that we can replace the traditional 
%representation of a
%type environment (eg., a map from variables to types)
%with a set of propositions, written \propenv{}. 
%Instead of mapping \x{} to
%the type \NumberFull{}, we use the proposition {\isprop{\NumberFull}{\x{}}}.

\paragraph{`Then' and `else' propositions} Along with an object, each expression carries two
propositions---a `then' and an `else' proposition,
that can be assumed if the expression evaluates to a
true value and a false value respectively.

The `then' proposition {\thenprop{\prop{}}} for the variable $o$ is $\notprop{\falsy{}}{o}$, for example.
This says if the expression $o$ evaluates to a true value, then $o$ is neither
of type \False or \Nil. Naturally, the `else' proposition {\elseprop{\prop{}}} is $\isprop{\falsy{}}{o}$---which
is true when $o$ is a false value---says $o$ is either \False or \Nil.

The pair of propositions {\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}} is called a \emph{proposition set}.

\paragraph{The full judgment}

We formalize our type system following~\citet{TF10}.
%(with differences highlighted in $\trdiff{\text{blue}}$)
The typing judgment 
$$
{\judgementrewrite   {\propenv}
              {\e{}} {\t{}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}
  {\ep{}}}
$$
says expression \e{} rewrites to \ep{}, which
is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}. We write 
{\judgementtworewrite{\propenv}{\e{}} {\t{}}{\ep{}} if we are only interested in the type
  or
{\judgementselfrewrite   {\propenv}
              {\e{}} {\t{}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
for expressions that rewrite to themselves.

\paragraph{Expressions} The syntax is given in \figref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals, and let expressions.
All binding forms introduce fresh variables.
Values include booleans, \nil{}, class literals, keywords, 
numbers,
constants, and strings. Lexical closures {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
close over functions with value environments \openv{}, which map bindings to values.

\paragraph{Types} Types include the top type, \emph{untagged} unions, functions, singleton types
and class instances.
We abbreviate the classes
\Booleanlong{} to \Boolean{}, 
\Keywordlong{} to \Keyword{},
\NumberFull{}  to \Number{},
\StringFull{}  to \String{}, and 
\FileFull{}  to \File{}.
We also abbreviate the types
\EmptyUnion{}     to \Bot{}, 
{\ValueNil}       to \Nil{}, 
{\ValueTrue}      to \True, and
{\ValueFalse} to {\False}.

The difference between the types
\Value{\Keyword} and \Keyword{} is subtle.
The former is inhabited by the class literal \Keyword{} and the result of 
\appexp{\classconst{}}{\makekw{a}}---the latter by keywords like \makekw{a}.

Function types contain \emph{latent} (terminology from~\cite{Lucassen88polymorphiceffect}) propositions, object, and return type,
which may refer to the function argument.
%Latent means they are relevant when the function is applied rather than evaluated.
They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

\paragraph{Elimination rule for propositions}
We can now review the main elimination rule for propositions, T-Local.
$$
    {\TLocal}
$$
It says, if proposition environment \propenv{} proves variable \x{} is 
of type \t{}, then under proposition environment \propenv{}
variable \x{} is of type \t{}. Also, if \x{} is a true value, then
we know \x{} is neither \False or \Nil, and if \x{} is a false value,
then \x{} is either \False or \Nil. Finally, the symbolic representation
for \x{}---its object---is \x{}.

\paragraph{Introduction rules for propositions}
Every program branch is an opportunity to extend the proposition environment
since we learn whether a test expression evaluates true or false. The T-If
rule assumes the test's `then' proposition \thenprop{\prop{1}}
in the then branch, and the test's `else' proposition \elseprop{\prop{1}}
in the else branch.
\begin{mathpar}
  {\TIf}
\end{mathpar}
The `then' proposition is {\orprop {\thenprop {\prop{2}}} {\thenprop {\prop{3}}}}
because if the entire expression reduces to a true value,
then either the `then' branch is true---implying {\thenprop {\prop{2}}}---or
the `else' branch is true---implying {\thenprop {\prop{3}}}.


%Given a set of propositions, we can use logical reasoning to derive
%new information about our programs
%with the judgment \inpropenv{\propenv{}}{\prop{}}.
%In addition to the standard rules for the logical connectives, the key
%rule is L-Update, which combines multiple propositions about the same variable,
%allowing us to refine its type.
%$$
%  {\LUpdate}
%$$
%For example, with L-Update we can use the knowledge of
%\inpropenv{\propenv{}}{\isprop{\UnionNilNum}{\x{}}}
%and 
%\inpropenv{\propenv{}}{\notprop{\Nil{}}{\x{}}}
%to derive \inpropenv{\propenv{}}{\isprop{\Number}{\x{}}}.
%(The metavariable \propisnotmeta{} ranges over \t{} and \nottype{\t{}} (without variables).)
%We cover L-Update in more detail in \secref{sec:formalpaths}.
%
%Finally, this approach allows the type system to track
%programming idioms from 
%dynamic languages
%using implicit type-based reasoning based on the result of
%conditional tests.
%For instance,
%\egref{example:parent-if}
%only utilizes \clj{f} once
%the programmer is convinced it is safe to do so based whether
%\clj{f}
%is
%true or false. 
%To express this in the type system, every expression 
%is described by two propositions: a `then' proposition
%for when it reduces to a true value, and an `else' proposition
%when it reduces to a false value---for \clj{f}
%the then proposition is {\notprop{\falsy}{f}} and 
%the else proposition is {\isprop{\falsy}{f}}.
%\ref{main:figure:typingrules}

\begin{figure}
  \footnotesize
$$
\begin{array}{lrll}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}} &\mbox{Expressions} \\
                      &\alt& {\ifexp {\e{}} {\e{}} {\e{}}}
                      %\alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}\\
                      %\alt {\errorvalv{}}
  \v{} &::=&          \singletonmeta{}
                      \alt {\num{}}
                      \alt {\const{}}
                      \alt {\str{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
                \constantssyntax{}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                &\mbox{Types} \\
                      &\alt& {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}\\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \propenvsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{array}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure}



%\figref{main:figure:typingrules} contains the core typing rules.
%The key rule for reasoning about conditional control flow is
%T-If. 
%
%\begin{mathpar}
%  {\TIf}
%\end{mathpar}

%The propositions of the test expression \e{1}, \thenprop{\prop{1}} and \elseprop{\prop{1}}, are 
%used as assumptions in the then and else branch respectively.

The introduction rule for lambda abstractions also introduces 
propositions to bring its parameter into scope when checking the body.
The proposition set says lambda expressions cannot be false.
$$
{\TAbs}
$$
The object \x{} is in scope in the latent propositions \thenprop{\prop{}} and
\elseprop{\prop{}}, latent object \object{}, and latent type \t{}. These are substituted with the
actual argument object---\objectp{}---with the application rule for functions.
$$
    {\TApp}
$$

The rule for let expressions links inferred information about
\x{} to the expression used to instantiate \x{}, \ep{1}, via logical implications.
$$
%\footnotesize
\infer [T-Let]
{ \judgementrewrite {\propenv{}} {\e{1}} {\s{}} {\filterset {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}}
             {\object{1}}
             {\ep{1}}
             \\\\
             \propp{} = {\impprop {\notprop {\falsydiff{}} {\x{}}} {\thenprop {\prop{1}}}}
             \\\\
             \proppp{} = {\impprop {\isprop {\falsydiff{}} {\x{}}} {\elseprop {\prop{1}}}}
  \\\\
  \judgementrewrite
       {\propenv{}, {\isprop {\s{}} {\x{}}},
         {\propp{}},
         {\proppp{}}}
             {\e{}} {\t{}} {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
             {\object{}} 
             {\ep{}}
             }
{ \judgementrewrite {\propenv{}} {\letexp {\x{}} {\e{1}} {\e{}}} {\t{}}
             {\replacefor {\filterset {\thenprop {\prop{}}} {\elseprop {\prop{}}}}
                          {\object{1}}
                          {\x{}}}
             {\replacefor {\object{}} 
                          {\object{1}}
                          {\x{}}}
             {\letexp {\x{}} {\ep{1}} {\ep{}}}
             }
$$

\paragraph{Other typing rules} The remaining core typing rules
include a subsumption rule, and rules for other values that reflect
\nil{} and \false{} as being the only false values.
$$
\footnotesize
    %{\TDo}
    %{\TClass}
    %{\TIf}
    %{\TAbs}
    %\begin{array}{c}
    %  {\TSubsume}\\\\
    %  {\TNum}
    %\end{array}
    \begin{array}{c}
      {\TNum}\\\\
      {\TConst}\\\\
      {\TKw}\\\\
      {\TClass}\\\\
      {\TTrue}\\\\
    \end{array}
    \begin{array}{c}
      {\TSubsume}\\\\
      {\TStr}\\\\
      {\TNil}\\\\
      {\TFalse}
    \end{array}
$$

%The T-Local rule connects the type system to the proof system over type propositions
%via \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}
%to derive a type for a variable.
%Using this rule, the type system can then appeal to L-Update to refine the type
%assigned to \x{}.
%
%We are now equipped to type check
%\egref{example:parent-if}:
%$$
%\clj{(if f (.getParent f) nil)}
%$$
%
%With {\propenv{}} = {\isprop{\UnionNilFile{}}{f}},
%$$
%\judgement{\propenv{}}{f}{\UnionNilFile{}}{\localfilterset{f}}{f}
%$$
%via T-Local.
%
%Checking the then branch involves extending
%the proposition environment with {\notprop{\falsy}{f}}
%$$
%\judgement{{\propenv{}},{\isprop{\Number}{\x{}}}}{\x{}}{\Number{}}{\filterset{\notprop{\falsy{}}{\x{}}}{\isprop{\falsy{}}{\x{}}}}{\emptyobject{}}
%$$
%because we can now satisfy the premise of T-Local:
%$$
%\inpropenv{{\propenv{}},\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}.
%$$
%\judgement{{\propenv{}},\isprop{\Number}{\x{}}}{\hastype{\appexp{\inc{}}{\x{}}}{\Number{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$
%$$
%\judgement{{\propenv{}},\notprop{\Number}{\x{}}}{\hastype{\zeroliteral{}}{\Number}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$

%\inc{} has type
%$$
%{\ArrowOne{\x{}}{\Number}{\Number}
%        {\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}}
%$$
%We can now check the conditional with T-If.
%$$
%\judgement{\isprop{\Number}{\x{}}}{\hastype{\ifexp{\appexp{\numberhuh{}}{\x{}}}{\appexp{\inc{}}{\x{}}}{\zeroliteral{}}}{\Number}}{\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}
%$$
%Finally the function can be checked with T-Abs
%$$
%\judgement{}{\hastype{\abs{\x{}}{\UnionNilNum}{\ ...}}
%                                             {\ArrowOne{\x{}}{\UnionNilNum}{\Number}
%        {\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}}}
%  {\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$

\paragraph{Operational semantics} We define the dynamic semantics for \lambdatc{}
in a big-step style using an environment, following~\citet{TF10}.
We include both errors and a \wrong{} value, which is provably ruled out by the
type system.
The main judgment is \opsem{\openv{}}{\e{}}{\definedreduction{}}
which states that \e{} evaluates to answer \definedreduction{} in environment
\openv{}. We chose to omit the core rules (see \figref{appendix:figure:opsem})
however a notable difference is \nil{} is a false value, which affects the
semantics of \ifliteral{}:
\begin{mathpar}
    \BIfTrue{}

    \BIfFalse{}
\end{mathpar}

\paragraph{Subtyping}
\figref{main:figure:subtyping} presents subtyping
as a reflexive and transitive relation with top type \Top. 
Singleton types are instances of their respective classes---boolean singleton types
are of type \Boolean{}, class literals are instances of \Class{} and keywords are
instances of \Keyword{}.
Instances of classes \class{} are subtypes of \Object{}. Since function types 
are subtypes of \IFn{}, all types except for \Nil{} are subtypes of \Object{},
so \Top{} = {\Union{\Nil}{\Object}}.
Function subtyping is contravariant left of the arrow---latent propositions, object
and the result type are covariant.
Subtyping for untagged unions is standard.

\paragraph{class} The \classconst{} function is implemented as a constant
function (via T-Const), which returns a latent object which is the argument applied to the
\classpe{} path element
$$
\constanttypefigure{}
$$
The dynamic semantics are given in \figref{main:figure:primitivesem}.
%The definition of \updateliteral{} supports various idioms relating to \classpe{}
%which we introduce in \secref{sec:isaformal}.

%\begin{figure*}
%  \footnotesize
%%%   \judgbox{
%%%{\judgementrewrite   {\propenv}
%%%              {\e{}} {\t{}}
%%%  {\filterset {\thenprop {\prop{}}}
%%%              {\elseprop {\prop{}}}}
%%%  {\object{}}{\ep{}}}}
%%%           {Under proposition environment $\propenv{}$, 
%%%             expression \e{} is of type \t{}
%%%             with  \\
%%%
%%%`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
%%%and object \object{} and rewrites to \ep{}.}
%  \begin{mathpar}
%    %{\TDo}
%    %{\TClass}
%    %{\TIf}
%    %{\TAbs}
%    %\begin{array}{c}
%    %  {\TSubsume}\\\\
%    %  {\TNum}
%    %\end{array}
%    \begin{array}{c}
%      {\TNum}\\\\
%      {\TConst}\\\\
%      {\TKw}\\\\
%      {\TClass}\\\\
%      {\TTrue}\\\\
%    \end{array}
%    \begin{array}{c}
%      {\TSubsume}\\\\
%      {\TNil}\\\\
%      {\TFalse}
%    \end{array}
%
%    %{\TLet}
%    %{\TLocal}
%
%    %{\TApp}
%    %{\TError}
%
%  \end{mathpar}
%  \caption{Typing rules}
%  \label{main:figure:typingrules}
%\end{figure*}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%    {\BLocal}
%
%    %{\BDo}
%
%    {\BLet}
%
%    \BVal{}
%
    %\BIfTrue{}

%    \BIfFalse{}
%
%    \BAbs{}
%
%    \BBetaClosure{}
%
%    \BDelta{}
%  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{main:figure:standardopsem}
%\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \SRefl{}

    \STop{}

\SUnionSuper{}

\SUnionSub{}

\SFunMono{}

\SObject{}

\SClass{}

\begin{array}{l}
\SSBool{}\\\\
\SSKw{}
\end{array}

\SFun{}


  \end{mathpar}
  \caption{Core Subtyping rules}
  \label{main:figure:subtyping}
\end{figure}

%\subsection{Reasoning about Exceptional Control Flow}
%\label{sec:doformal}
%
%Along with conditional control flow,
%Clojure programmers rely on \emph{exceptions}
%to assert type-related invariants.
%
%\begin{exmp}
%\inputminted[firstline=13,lastline=15]{clojure}{code/demo/src/demo/do.clj}
%\label{example:doexception}
%\end{exmp}
%
%The fully expanded increment function in~\egref{example:doexception}
%guards its final call with a number check, preventing
%a possible null-pointer exception.
%Without this check, the type system would reject the program.
%
%To check this example,
%occurrence typing 
%automatically
%assumes
%\clj{x} is a number when checking the second \clj{do} subexpression
%based on the first subexpression.
%\footnote{See \url{https://github.com/typedclojure/examples}
%  for full examples.}
%We model this formally %(section~\ref{sec:doformal}) 
%and prove
%null-pointer exceptions are impossible in typed code (section~\ref{sec:metatheory}).
%
%
%We extend our model with sequencing expressions and errors, where {\errorvalv{}}
%models the result of calling Clojure's \clj{throw} special form
%with some \clj{Throwable}.
%
%\smallskip
%$
%\begin{altgrammar}
%  \e{} &::=& \ldots \alt {\errorvalv{}} \alt {\doexp {\e{}} {\e{}}} &\mbox{Expressions} 
%\end{altgrammar}
%$
%
%\smallskip
%%
%%B-Do simply evaluates its arguments sequentially and returns the right argument.
%%Since errors are not values, we define error propagation semantics
%%like BE-Do1 (figure~\ref{appendix:figure:errorstuck} for the full rules).
%%
%%\begin{mathpar}
%%    {\BDo}
%%
%%\infer [BE-Error]
%%{}
%%{ \opsem {\openv{}} 
%%         {\errorvalv{}}
%%         {\errorvalv{}}}
%%
%%\infer [BE-Do1]
%%{ \opsem {\openv{}} {\e{1}} {\errorvalv{}} }
%%{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\errorvalv{}}}
%%\end{mathpar}
%
%Our main insight is as follows: 
%if the first subexpression in a sequence reduces to a value, then it is either true or false.
%If we learn some proposition in both cases then we can use that proposition as an assumption to check the second subexpression.
%T-Do formalizes this intuition.
%
%\begin{mathpar}
%    {\TDo}  
%\end{mathpar}
%
%The introduction of errors, 
%which do not evaluate to either
%a true or false value,
%makes our insight interesting.
%
%\begin{mathpar}
%    {\TError}
%\end{mathpar}
%
%Recall \egref{example:doexception}.
%\begin{minted}{clojure}
%...
%  (do (if (number? x) nil (throw (new Exception)))
%      (inc x)) 
%...
%\end{minted}
%
%As before, checking \appexp{\numberhuh{}}{\x{}} allows us to use the proposition \isprop{\Number}{\x{}}
%when checking the then branch.
%
%By T-Nil and subsumption we can propagate this  information to both propositions.
%$$
%\judgement{\isprop{\Number}{\x{}}}{\nil{}}{\Nil{}}{\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
%$$
%Furthermore, using T-Error
%and subsumption we can conclude anything in the else branch.
%$$
%\judgement{\notprop{\Number}{\x{}}}{\errorvalv{}}{\Bot}{\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
%$$
%Using the above as premises to T-If we conclude that if the first
%expression in the \doliteral{} evaluates successfully, \isprop{\Number}{\x{}} must be true.
%$$
%\judgement{\isprop{\UnionNilNum}{\x{}}}
%          {\ifexp{\appexp{\numberhuh{}}{\x{}}}{\nil{}}{\errorvalv{}}}{\Boolean}
%          {\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
%$$
%We can now use \isprop{\Number}{\x{}} in the environment to check the second subexpression
%{\appexp{\inc{}}{\x{}}}, completing the example.

\subsection{Java Interoperability}

\begin{figure}[t]
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots   
                      {\fieldexp {\fld{}} {\e{}}}
                      \alt {\methodexp {\mth{}} {\e{}} {\overrightarrow{\e{}}}}&\mbox{Expressions}\\
                      &\alt& {\newexp {\class{}} {\overrightarrow{\e{}}}}\\
     &\alt& \mininonreflectiveexpsyntax{}
    \\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \classtableallsyntax{}
  \end{altgrammar}
  $$
  \begin{mathpar}
    {\TField}

    %{\TMethod}

    %{\TInstance}
  \end{mathpar}
 %\classtablelookupsyntax{}
 \begin{mathpar}
  \begin{altgrammar}
    \convertjavatypenil{}
  \end{altgrammar}
  \begin{altgrammar}
    \convertjavatypenonnil{}
  \end{altgrammar}
  \\
  \begin{altgrammar}
    \converttctype{}
  \end{altgrammar}
\end{mathpar}
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \caption{Java Interoperability Syntax, Typing and Operational Semantics}
  \label{main:figure:javatyping}
\end{figure}

We present Java interoperability in a restricted setting without class inheritance,
overloading or Java Generics.

We extend the syntax in \figref{main:figure:javatyping} with Java field lookups and calls to
methods and constructors. 
To prevent ambiguity, % between zero-argument methods and fields, 
field accesses are written \fieldexp{\fld{}}{\e{}}
and method calls $\methodexp{\mth{}}{\e{}}{\overrightarrow{e}}$.
%and \clj{(new class es*)} is $\newexp{\class{}}{\overrightarrow{es}}$.

\egref{example:getparent-direct-constructor} translates to expression~\ref{eq:unresolved}.
$$
\clj{(.getParent (new File "a/b"))}
$$
\begin{equation}  \label{eq:unresolved}
  \qquad {\methodexp {\getparent{}} {\newexp {\File{}} {\makestr{a/b}}} {}}
\end{equation}

But both the constructor and method are unresolved.
We introduce \emph{non-reflective} expressions for specifying exact Java overloads.
\begin{equation} \label{eq:resolved}
\qquad {\methodstaticexp {\File} {} {\String} {\getparent{}} {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}} {}}
\end{equation}
From the left, the one-argument constructor for \File takes a \String, and the 
\getparent{} method of
\File{} takes zero arguments
and
returns a \String.

We now walk through the conversion from unresolved expression~\ref{eq:unresolved} to 
resolved expression~\ref{eq:resolved}.

\paragraph{Constructors} First we check and convert {\newexp {\File{}} {\makestr{a/b}}} to {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}}
The T-New typing rule checks and rewrites constructors.
$$
    {\TNew}
$$
To check
{\newexp {\File{}} {\makestr{a/b}}}
we first resolve the constructor overload in the class table---there is at most one
to simplify presentation.
With \classhint{1} = \String,
we convert to a nilable type the argument with \t{1} = \Union{\Nil}{\String}
and type check {\makestr{a/b}} against \t{1}.
Typed Clojure defaults to allowing non-nilable arguments, but this
can be overridden, so we model the more general case.
% which erases nil
The return Java type \File is converted to a non-nil
Typed Clojure type \t{} = \File for the return type,
and the proposition set says constructors can never be false---constructors
can never produce the internal boolean value that Clojure uses for \false{}, or \nil{}.
Finally, the constructor rewrites to {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}}.

\paragraph{Methods} Next we convert {\methodexp {\getparent{}} {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}} {}}
to
{\methodstaticexp {\File} {} {\String} {\getparent{}} {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}} {}}.
The T-Method rule checks unresolved methods.
$$
    {\TMethod}
$$
To check {\methodexp {\getparent{}} {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}} {}},
we verify the target type \s{} = \File is non-nil before erasing \Nil
by converting to a Java type \classhint{1} = \File.
The specific overload is chosen from the class table based on \classhint{1}---there is at most one.
Then {\newstaticexp {\String} {\File{}} {\File{}} {\makestr{a/b}}}
is checked against a nilable conversion of \classhint{1}, \t{1} = \Union{\Nil}{\File},
which succeeds by the previous rule.
The nilable return type \t{} = \Union{\Nil}{\String} is given, and---finally---the 
entire expression rewrites to expression \ref{eq:resolved}.
%
%We allow arguments to constructors and methods to be nilable, but not method
%and field targets.

The T-Field rule is included in \figref{main:figure:javatyping}, and is like T-Method, but without arguments.

The evaluation rules B-Field, B-New and B-Method (\figref{main:figure:javatyping}) simply evaluate their
arguments and call the relevant JVM operation, which we do not model---\secref{sec:metatheory}
states our exact assumptions.
There are no evaluation rules for reflective Java interoperability, since there are no typing
rules that rewrite to reflective calls.


%\subsection{Paths}
%\label{sec:formalpaths}
%
%Recall the first insight of occurrence typing---we can reason
%about specific \emph{parts} of the runtime environment
%using propositions.
%We refer to parts of the runtime environment via 
%a \emph{path} that consists of a series of
%\emph{path elements} applied right-to-left to a variable
%written \path{\pathelem{}}{\x{}}.
%\citet{TF10} introduce the path elements \carpe{} and \cdrpe{}
%to reason about selector operations on cons cells.
%We instead want to reason about HMap lookups and calls to \classconst{}.
%
%\paragraph{Key path element} We introduce our first path element
%{\keype{\k{}}}, which represents the operation of looking up
%a key \k{}.
%We directly relate this to our typing rule T-GetHMap
%(\figref{main:figure:hmapsyntax}) by
%checking the then branch of the first conditional test is checked in 
%an equivalent version of \egref{example:decleaf}.
%\begin{minted}{clojure}
%  (fn [m :- Expr]
%    (if (= (get m :op) :if)
%      {:op :if, ...}
%      (if ...)))
%\end{minted}
%
%We do not specifically support \equivliteral{} in our calculus, 
%but on keyword arguments it works identically to \clj{isa?} which we model
%in \secref{sec:isaformal}.
%Intuitively, if {\judgement{\propenv{}}{\e{}}{\t{}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}}
%then \equivapp{\e{}}{\makekw{if}} has the true and false propositions
%$$
%{\replacefor{\filterset{\isprop{\Value{\makekw{if}}}{\x{}}}{\notprop{\Value{\makekw{if}}}{\x{}}}}{\object{}}{\x{}}}
%$$
%where substitution reduces to \topprop{} if \object{} = \emptyobject{}.
%
%We start with proposition environment \propenv{} = {\isprop{\Expr{}}{m}}.
%Since {\Expr{}} is a union of HMaps, each with the entry \makekw{op}, we can use T-GetHMap.
%$$
%\judgement{\propenv{}}{\getexp{m}{\makekw{op}}}{\Keyword}{\filterset{\topprop{}}{\topprop{}}}{\path{\keype{\makekw{op}}}{m}}
%$$
%Using our intuitive definition of \equivliteral{} above, we know
%$$
%\judgement{\propenv{}}{\equivapp{\getexp{m}{\makekw{op}}}{\makekw{if}}}{\Boolean}{\filterset{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}{\notprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}}{\emptyobject{}}
%$$
%Going down the then branch gives us the extended environment
%\propenvp{} = {\isprop{\Expr{}}{m}},{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}.
%Using L-Update we can combine what we know about object $m$ and object
%{\path{\keype{\makekw{op}}}{m}}
%to derive
%$$
%\inpropenv{\propenvp{}}{\isprop{\HMapp{\mandatoryset{{\mandatoryentrykwnoarrow{op}{\makekw{if}}}, {\mandatoryentrykwnoarrow{test}{\Expr{}}},
%                                       {\mandatoryentrykwnoarrow{then}{\Expr{}}},   {\mandatoryentrykwnoarrow{else}{\Expr{}}}}}
%                                   {\emptyabsent{}}}{m}}
%$$
%
%The full definition of \updateliteral{} is given in \figref{main:figure:update}
%which considers both keys a path elements as well as the \classconst{}
%path element described below.
%In the absence of paths, update simply performs set-theoretic operations
%on types; see \figref{main:figure:restrictremove} for details.
%
%\paragraph{Class path element} Our second path element \classpe{} is used in the latent
%object of the constant \classconst{} function. Like Clojure's \clj{class}
%function \classconst{} returns the argument's class or \nil{}
%if passed \nil{}.
%$$
%\begin{array}{lrlr}
%  \pesyntax{}   &::=& \ldots \alt {\classpe{}}
%                &\mbox{Path Elements}
%\end{array}
%$$
%\begin{mathpar}
%\constanttypefigure{}
%\end{mathpar}
%The dynamic semantics are given in \figref{main:figure:primitivesem}.
%The definition of \updateliteral{} supports various idioms relating to \classpe{}
%which we introduce in \secref{sec:isaformal}.

\subsection{Multimethod preliminaries: \isaliteral}

\label{sec:isaformal}

We now consider the \isaliteral{} operation, a core part of the dispatch mechanism for multimethods. 
Recalling the examples in \secref{sec:multioverview},
\isaliteral{} is
a subclassing test for classes, otherwise an equality test.
%---we do not model the semantics for vectors

The key component of the T-IsA rule is the \isacompareliteral{} 
metafunction
(\figref{main:figure:mmsyntax}), used to calculate the propositions for
\isaliteral{} tests.
\begin{mathpar}
  \TIsA{}
\end{mathpar}

As an example,
\isaapp{\appexp{\classconst{}}{\x{}}}{\Keyword}
has the true and false propositions 
\isacompare{\s{}}{\path{\classpe{}}{\x{}}}{\Value{\Keyword}}{\filterset{\isprop{\Keyword}{\x{}}}{\notprop{\Keyword}{\x{}}}},
meaning that if this expression produces true, \x{} is a keyword, otherwise it is not.

The operational behavior of \isaliteral{} is given by B-IsA (\figref{main:figure:mmsyntax}). \isaopsemliteral{} explicitly handles classes in the second case.

%The definition of \isacompareliteral{} (figure~\ref{main:figure:mmsyntax}) is deliberately conservative.
%The first line considers the case where the object of the left argument
%is a non-empty path ending in \classpe{} and the type of the right argument is a singleton class.

\constantsemfigure{main}

\subsection{Multimethods}

\begin{figure}[t!]
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\createmultiexp {\t{}} {\e{}}} &\mbox{Expressions} \\
             &\alt& {\extendmultiexp {\e{}} {\e{}} {\e{}}}
             \alt {\isaapp {\e{}} {\e{}}}\\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
 \disptablesyntax{} \\\\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types}
\end{altgrammar}
$$
  \begin{mathpar}
    %\TDefMulti{}

    %\TDefMethod{}
  \end{mathpar}
  \begin{mathpar}
    \isapropsfigure{}
  \end{mathpar}
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    %\BBetaMulti{}
  \end{mathpar}
  \getmethodfigure{}
$$
\begin{array}{ll}
  \vcenter{\hbox{\BIsA{}}}
  &
  \vcenter{\hbox{\isaopsemfigure{}}}
\end{array}
$$
\caption{Multimethod Syntax, Typing and Operational Semantics}
\label{main:figure:mmsyntax}
\end{figure}

We use \emph{immutable}
multimethods without default methods to ease presentation.
%Syntax and semantics are given in \figref{main:figure:mmsyntax}. 
%Multimethods can error if no matching method is chosen (rules in the supplemental material).
Below is the translation of \egref{example:hi-multimethod} to \lambdatc{}.
\begin{minted}{clojure}
(ann hi [Kw -> Str])
(defmulti hi identity)
(defmethod hi :en [_] "hello")
(defmethod hi :fr [_] "bonjour")
(hi :en) ;=> "hello"
\end{minted}
\begin{listing}
$\letexp{hi_0} {\createmultiexp {\ArrowOne{\x{}}{\Keyword}{\String}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}} {\abs{\x{}}{\Keyword}{\x{}}}}
  {\\\text{\quad}
    \letexp{hi_1} {\extendmultiexp {hi_0} {\makekw{en}} {\abs {\x{}} {\Keyword} {\makestr{hello}}}}
      {\\\text{\quad\quad}
        \letexp{hi_2} {\extendmultiexp {hi_1} {\makekw{fr}} {\abs {\x{}} {\Keyword} {\makestr{bonjour}}}}
        {\\\text{\quad\quad\quad
          \appexp{hi_2}{\makekw{en}}}}}}
$
\end{listing}

For convenience, examples in this section are flattened when they are really nested
let bindings. We also elide trivial latent propositions and objects.
The following is an abbreviation of the previous expression.
\begin{lstlisting}
${\createmultiexp {\ArrowTwo{\x{}}{\Keyword}{\String}} {\abs{\x{}}{\Keyword}{\x{}}}}$
${\extendmultiexp {hi} {\makekw{en}} {\abs {\x{}} {\Keyword} {\makestr{hello}}}}$
${\extendmultiexp {hi} {\makekw{fr}} {\abs {\x{}} {\Keyword} {\makestr{bonjour}}}}$
$\appexp{hi}{\makekw{en}}$
\end{lstlisting}

%\defmethodliteral{} returns a new extended multimethod
%without changing the original multimethod. 
%
%\begin{minted}{clojure}
%(let [hi (defmulti [Kw -> Str] identity)]
%  (let [hi (defmethod hi :en [_] "hello")]
%    (let [hi (defmethod hi :fr [_] "bonjour")]
%      (hi :en))) ;=> "hello"
%\end{minted}

\paragraph{How to check}
We now walk through type checking the expression
\begin{equation}  \label{eq:hi-defmulti}
{\createmultiexp {\ArrowTwo{\x{}}{\Keyword}{\String}} {\abs{\x{}}{\Keyword}{\x{}}}}
\end{equation}

The expression {\createmultiexp {\s{}} {\e{}}} creates a multimethod with \emph{interface type} \s{}, and dispatch function \e{}
of type \sp{},
producing a value of type
{\MultiFntype {\s{}} {\sp{}}}. % with interface type {\s{}} and dispatch function type {\sp{}}.
The typing rule for \defmultiliteral{} simply checks the dispatch function, and
verifies both the interface and dispatch type's domain agree.
$$
    \TDefMulti{}
$$
Expression~\ref{eq:hi-defmulti} checks with \t{} = \Keyword, interface type \s{} = {\ArrowTwo{\x{}}{\Keyword}{\String}},
dispatch function type \sp{} = {\ArrowOne{\x{}}{\Keyword}{\Keyword}{\filterset{\topprop{}}{\topprop{}}}{\x{}}}, and overall type
$$
{\MultiFntype {\ArrowTwo{\x{}}{\Keyword}{\String}}
              {\ArrowOne{\x{}}{\Keyword}{\Keyword}{\filterset{\topprop{}}{\topprop{}}}{\x{}}}}
$$

Next, we walk through checking
\begin{equation}  \label{eq:hi-defmethoden}
{\extendmultiexp {hi} {\makekw{en}} {\abs {\x{}} {\Keyword} {\makestr{hello}}}}
\end{equation}

The expression 
{\extendmultiexp {\e{m}} {\e{v}} {\e{f}}} creates a new multimethod
that extends multimethod \e{m}'s dispatch table, mapping dispatch value
\e{v} to method \e{f}. The typing rule for \defmethodliteral{}
checks \e{m} is a multimethod with dispatch function type \t{d},
then calculates the extra information we know based on the current
dispatch value {\thenprop{\proppp{}}}, which is assumed when checking the method
body.
$$
    \TDefMethod{}
$$
Expression~\ref{eq:hi-defmethoden} checks with \e{m} being of type
$$
{\MultiFntype {\ArrowTwo{\x{}}{\Keyword}{\String}}
              {\ArrowOne{\x{}}{\Keyword}{\Keyword}{\filterset{\topprop{}}{\topprop{}}}{\x{}}}}
$$
with \objectp{} = {\x{}} and \t{v} = \Value{\makekw{en}}. Then {\thenprop{\proppp{}}} = 
{\isprop {\Value{\makekw{en}}}{\x{}}} by
$$
\isacompare{}{\x{}}{\Value{\makekw{en}}}
{\filterset {\isprop {\Value{\makekw{en}}}{\x{}}}{\notprop{\Value{\makekw{en}}}{\x{}}}}
$$
Since \t{} = \Keyword{}, we check the method body with
$$
\judgement{{\isprop{\Keyword}{\x{}}},{\isprop {\Value{\makekw{en}}}{\x{}}}}
  {\makestr{hello}}
  {\String}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$
Finally from the interface type \t{m}, we know \thenprop{\prop{}} = \elseprop{\prop{}} = \topprop{},
and \object{} = \emptyobject{}, which also agrees with the method body, above.


%The expression {\createmultiexp {\s{}} {\e{}}} 
%defines a multimethod
%with interface type \s{} and dispatch function \e{}.
%The expression {\extendmultiexp {\e{m}} {\e{v}}{\e{f}}}
%extends multimethod \e{m} and to map
%dispatch value {\e{v}} to {\e{f}} in an extended dispatch table.
%The value {\multi {\v{}} {\disptable{}}} is the runtime value of a multimethod
%with dispatch function {\v{}} and dispatch table {\disptable{}}.
%
%The T-DefMulti rule ensures that the type of the dispatch function
%has at least as permissive a parameter type
%as the interface type.
%
%For example, we can check the definition from our translation above of \egref{example:rep}
%using T-DefMulti.
%$$
%\judgement{}%{\propenv{}}
%{\createmultiexp 
%      {\s{}}
%      {\classconst{}}}
%  {\MultiFntype {\s{}}{\sp{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$
%where \s{}  = {\ArrowOne {\x{}} {\Top{}} {\t{}} {\filterset {\topprop{}} {\topprop{}}} {\emptyobject{}}}
%  and \sp{} = {\ArrowOne {\x{}} {\Top{}} {\Union{\Nil}{\Class}} {\filterset {\topprop{}} {\topprop{}}} {\path{\classpe{}}{\x{}}}}.
%  Since the parameter types agree, this is well-typed.
%
%The T-DefMethod rule requires a syntactic lambda expression as the method.
%This way we can manually check the body of the lambda under an extended
%environment as sketched in \egref{example:incmap}.
%We use \isacompareliteral{} to compute the proposition for this method,
%since \isaliteral{} is used at runtime in multimethod dispatch.
%
%We continue with the next line of the translation of \egref{example:rep}.
%From the previous line we have \propenv{} = {\isprop{\MultiFntype {\s{}}{\sp{}}}{path}},
%so
%$$
%\judgement{\propenv{}}
%  {\extendmultiexp {prop} {\String}
%                   {\abs {\x{}} {\Top{}} {\x{}}}}
%  {\MultiFntype {\s{}}{\sp{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$
%We know \emph{prop} is a multimethod by \propenv{}, so now we check the body
%of this method.
%$$
%\judgement{\propenv{},{\isprop{\Top}{\x{}}},{\isprop{\String}{\x{}}}}
%  {\x{}}
%  {\String}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$
%%This is checked by T-Local since {\inpropenv{\propenv{},{\isprop{\Top}{\x{}}},{\isprop{\String}{\x{}}}}{\isprop{\String}{\x{}}}}.
%The new proposition {\isprop{\String}{\x{}}} is derived by 
%$$
%  \isacompare{\Top{}}{\path{\classpe{}}{\x{}}}{\Value{\File{}}}
%             {\filterset{\isprop{\String}{\x{}}}
%                        {\notprop{\String}{\x{}}}}.
%$$
%%
%The body of the \clj{let} is checked by T-App because
%{\MultiFntype {\s{}}{\sp{}}} is a subtype of its interface type {\s{}}.

\paragraph{Subtyping}
Multimethods are also functions, which is encoded via the following subtyping rule.
$$
\SPMultiFn{}
$$
This rule says a multimethod can be upcast to its interface type. This means
multimethod call sites can be handled by T-App via T-Subsume. Other rules are given in
in \figref{main:figure:mmsyntax}. 

\paragraph{Semantics}
Multimethod definition semantics are also given 
in \figref{main:figure:mmsyntax}. 
B-DefMulti creates a multimethod with the given dispatch function and an empty dispatch table.
B-DefMethod produces a new multimethod with an extended dispatch table.

The overall dispatch mechanism is summarised by B-BetaMulti.
$$
    \BBetaMulti{}
$$
First the dispatch function \v{d} is applied to the argument \vp{} to obtain
the dispatch value \v{e}.
Based on \v{e},
the \getmethodliteral{} metafunction (\figref{main:figure:mmsyntax})
extracts a method \v{f} from the method table {\disptable{}}
and applies it to the original argument for the final result.

\subsection{Precise Types for Heterogeneous maps}
\label{sec:hmapformal}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
%    \pesyntax{}   &::=& \ldots \alt {\keype{\k{}}}
%                  &\mbox{Path Elements}
  \end{altgrammar}
  $$
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \caption{HMap Syntax, Typing and Operational Semantics}
  \label{main:figure:hmapsyntax}
\end{figure}


\figref{main:figure:hmapsyntax} presents syntax, typing rules
and dynamic semantics in detail.
%
The type \HMapgeneric{\mandatory{}}{\absent{}}
includes {\mandatory{}}, a map of \emph{present} entries (mapping keywords to types),
\absent{}, a set of keyword keys that are known to be \emph{absent}
and
tag \completenessmeta{} which is either {\complete{}} (``complete'') if the map is fully specified by \mandatory{},
and {\partial{}} (``partial'') if there are \emph{unknown} entries.
To ease presentation, 
if an HMap has completeness tag \complete{} then \absent{} implicitly contains all keywords not in the domain of \mandatory{}.
%\HMapcwithabsent{\mandatory{}}{\absent{}} is abbreviated to \HMapc{\mandatory{}}. 
Keys cannot be both present and absent.

The expressions \clj{(get m :a)} and \clj{(:a m)} are semantically identical, though
we only model the former to avoid the added complexity of keywords being functions.
To simplify presentation, we only provide syntax for the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}},
usually written {\curlymapvaloverrightnoarrow{\k{}}{\v{}}}.

Subtyping for HMaps
designate \MapLiteral{} as a common supertype for all HMaps.
S-HMap says that an HMap is a subtype of another HMap if they agree
on \completenessmeta{}, agree on mandatory entries with subtyping
and at least cover the absent keys of the supertype.
Complete maps are subtypes of partial maps
as long as they agree on the mandatory entries of the partial map via subtyping (S-HMapP).

The typing rules for \getliteral{} consider three possible cases. T-GetHMap models a lookup
that will certainly succeed, T-GetHMapAbsent a lookup that will certainly fail
and T-GetHMapPartialDefault a lookup with unknown results.
Lookups on unions of HMaps are only supported in T-GetHMap, 
for cases like \egref{example:desserts-on-meal}
where every element in the union
contains the key we are looking up.
The object {\replacefor {\path {\keype{k}} {\x{}}} {\object{}} {\x{}}}
is a symbolic representation for a keyword lookup of $k$ in \object{}.
The substitution for {\x{}} handles the case where \object{} is empty.
$$
\begin{array}{rcl}
{\replacefor {\path {\keype{k}} {\x{}}} {\y{}} {\x{}}} &=& {\path {\keype{k}} {\y{}}} \\
{\replacefor {\path {\keype{k}} {\x{}}} {\emptyobject{}} {\x{}}} &=& \emptyobject{}
\end{array}
$$

%The objects in the T-Get rules are more complicated than those in T-Local---the 
%next section discusses this in detail.
Finally T-AssocHMap extends an HMap with a mandatory entry while preserving completeness
and absent entries, and enforcing ${\k{}} \not\in {\absent{}}$ to prevent badly
formed types.

The semantics for \getliteral{} and \assocliteral{} are straightforward.
If the entry is missing, B-GetMissing produces \nil{}.

\subsection{Proof system}

% checks obvious prop logic, but update is most interesting rule.





\begin{figure*}
  $$
\begin{array}{lllll}
\updatefigure
\end{array}
$$
\caption{Type Update}
\label{main:figure:update}
\end{figure*}

\begin{figure}
  $$
\begin{array}{lllll}
  \restrictremovefigure{}
\end{array}
  $$
  \caption{Restrict and Remove}
  \label{main:figure:restrictremove}
\end{figure}
