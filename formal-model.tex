\section{A Formal Model of Typed Clojure}

\label{sec:formal}

Now that we have demonstrated the core features Typed Clojure
provides, we present a model that links them all together.
Our presentation will start with a review of
occurrence typing~\cite{TF10}.
Then for the rest of the section we incrementally add each
novel feature of Typed Clojure to the formalism,
interleaving presentation of typing rules, operational semantics
and
subtyping.

The first insight about occurrence typing is that
propositions can be used to capture type information about our programs,
in particular by referencing components or subcomponents of the runtime environment
and relating them to types.
\emph{Type Propositions} make assertions like ``variable \clj{x} is of type \clj{Number}'' or
``variable \clj{x} is not \clj{nil}''---
in our logical system we write these as
{\isprop{\NumberFull}{\x{}}}
and {\notprop{\Nil{}}{\x{}}}. 
The other propositions are standard: the implication, conjunction,
disjunction, trivial (\topprop{}) and impossible (\botprop{}) propositions
(figure~\ref{main:figure:termsyntax}).

The particular part of the environment we reference in a positive or negative
type proposition is called the \emph{object}.
Every expression has an object that is either \emph{empty}, written \emptyobject{}, which says there is no
known way to relate this expression to the current environment, or a 
variable with some \emph{path}, written \path{\pathelem{}}{\x{}},
that exactly indicates how the value of this
expression can be derived from the current environment.
Type propositions can only reference non-empty objects.

The second insight is that we can replace the traditional 
representation of a
type environment of a map from variables to types
with a sequence of propositions, written \propenv{}. 
Instead of mapping \clj{x} to
the type \clj{Number}, we use the proposition {\isprop{\NumberFull}{\x{}}}.

The third insight is that we
can use a logic system to learn new information about our programs.
The key component of the logic system L-Update uses type propositions
to derive new propositions.
$$
  {\LUpdate}
$$
For example, with L-Update we can use the knowledge of
\inpropenv{\propenv{}}{\isprop{\UnionNilNum}{\x{}}}
and 
\inpropenv{\propenv{}}{\notprop{\Nil{}}{\x{}}}
to derive \inpropenv{\propenv{}}{\isprop{\Number}{\x{}}}.
(The metavariable \propisnotmeta{} ranges over \t{} and \nottype{\t{}} (without variables).)
We cover \updateliteral{} in section~\ref{sec:updateformalsection}.

The fourth insight is a consequence of
programmers in dynamic languages
using implicit type-based reasoning based on the result of
conditional tests.
For instance, example~\ref{example:conditionalflow}
only utilises \clj{x} once
the programmer is convinced it is safe to do so based whether
\clj{(number? x)}
is 
a true or false value. The takeaway is that every expression has
two extra pieces of information relevant to the logic system: a `then' proposition
for when it reduces to a true value, and an `else' proposition
when it reduces to a false value---for \clj{(number? x)}
the then proposition is {\isprop{\NumberFull}{\x{}}} and 
the else proposition is {\notprop{\NumberFull}{\x{}}}.
%\ref{main:figure:typingrules}

\begin{figure}
  \footnotesize
$$
\begin{array}{lrll}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}} &\mbox{Expressions} \\
                      &\alt& {\ifexp {\e{}} {\e{}} {\e{}}}
                      %\alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}\\
                      %\alt {\errorvalv{}}
  \v{} &::=&          \singletonmeta{}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
                \constantssyntax{}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                &\mbox{Types} \\
                      &\alt& {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}\\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \propenvsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{array}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure}


We formalise our type system following~\citet{TF10}
(with differences highlighted in $\trdiff{\text{blue}}$).
The typing judgement 
$$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}. We sometimes write 
{\judgementtwo{\propenv}{\hastype {\e{}} {\t{}}} if we are only interested in the type.

Syntax is given in figure~\ref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals and let expressions.
All binding forms introduce fresh variables.
Values include booleans, \nil{}, class literals, keywords, 
constants and closures. 
Value environments map local bindings to values.
Closures contain the value environment \openv{} when the function was created,
which is used during beta reduction to ensure the abstraction respects lexical scoping.
\false{} and \nil{} are logically false, otherwise values are true.

Types include the top type, \emph{untagged} unions, functions, singleton types
and class instances. 
We write the class literal \Booleanlong{} as \Boolean{} and \Keywordlong{} as \Keyword{}.
The type \Value{\Keyword} is inhabited by the class literal \Keyword{} and \clj{:a} is of type \Keyword{}.
We abbreviate \EmptyUnion{} as \Bot{}, {\ValueNil} as \Nil{}, 
{\ValueTrue} as \True and {\ValueFalse} as {\False}.
Function types contain \emph{latent}(terminology from~\cite{Lucassen88polymorphiceffect}) propositions and object, which, along with the return type,
may refer to the parameter identifier. They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

Figure~\ref{main:figure:typingrules} contains the standard typing rules.
The first interesting rule is T-If. The propositions of the test \thenprop{\prop{1}} and \elseprop{\prop{1}}
are used as assumptions in the then and else branch respectively.
If the result of the \ifliteral{} is true, then the value either
came from \e{2}, in which case \thenprop{\prop{2}} is true, or from \e{3},
which implies \thenprop{\prop{3}} is true. 
The else proposition is \orprop{\elseprop{\prop{2}}}{\elseprop{\prop{3}}} for
similar reasons, but instead for when each branch is a false value.
The second interesting rule is T-Local, where we actually utilise the logic system
to extract a type for a local binding. This rule is why L-Update is crucial---T-Local
looks for positive type propositions in \propenv{} with the same object as the binding.
By subsumption we can choose the most specific positive proposition and thus
T-Local can return the most specific type inferred by the logic system.

We can now demonstrate how to check example~\ref{example:conditionalflow}.
We abbreviate \NumberFull{} as \Number{} and \Booleanlong{} as \Boolean{}.
The test is checked with T-App, 
$$
\judgement{\isprop{\UnionNilNum{}}{\x{}}}{\hastype{\appexp{\numberhuh{}}{\x{}}}{\Boolean}}{\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}
$$
\numberhuh{} has type
$$
{\ArrowOne{\x{}}{\Top}{\Boolean}
        {\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}}
$$
By T-Local.
$$
\judgement{\isprop{\Number}{\x{}}}{\hastype{\x{}}{\Number{}}}{\filterset{\notprop{\falsy{}}{\x{}}}{\isprop{\falsy{}}{\x{}}}}{\x{}}
$$
Now we check both branches.
$$
\judgement{\isprop{\Number}{\x{}}}{\hastype{\appexp{\inc{}}{\x{}}}{\Number{}}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$
$$
\judgement{\notprop{\Number}{\x{}}}{\hastype{\zeroliteral{}}{\Number}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$
\inc{} has type
$$
{\ArrowOne{\x{}}{\Number}{\Number}
        {\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}}
$$
We can now check the conditional with T-If.
$$
\judgement{\isprop{\Number}{\x{}}}{\hastype{\ifexp{\appexp{\numberhuh{}}{\x{}}}{\appexp{\inc{}}{\x{}}}{\zeroliteral{}}}{\Number}}{\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}
$$
Finally the function can be checked with T-Abs
$$
\judgement{}{\hastype{\abs{\x{}}{\UnionNilNum}{\ ...}}
                                             {\ArrowOne{\x{}}{\UnionNilNum}{\Number}
        {\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}}}
  {\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
$$

The operational semantics for our language standard defined in big-step style, 
The notable different is \nil{} is a false value, which require changes 
to the semantics of \ifliteral{}:

\begin{mathpar}
    \BIfTrue{}

    \BIfFalse{}
\end{mathpar}

For example,
B-IfTrue evaluates \e{1} in the environment \openv{} with the result \v{1}.
If \v{1} is not \nil{} or \false{} then the conditional returns the result of evaluating the then branch \e{2}
in \openv{}.

Subtyping (figure~\ref{main:figure:subtyping}) 
is a reflexive and transitive relation with top type \Top. All objects are subtypes
of \emptyobject{}.
Singleton types are instances of their respective classes---boolean singleton types
are of type \Boolean{}, class literals are instances of \Class{} and keywords are
instances of \Keyword{}.
Instances of classes \class{} are subtypes of \Object{}. Since function types 
are subtypes of \IFn{}, all types except for \Nil{} are subtypes of \Object{},
so \Top{} = {\Union{\Nil}{\Object}}.
Function subtyping is contravariant left of the arrow---latent propositions, object
and the result type are covariant.
Subtyping for untagged unions is standard.

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TLocal}

    {\TTrue}

    {\TFalse}

    {\TNil}

    %{\TDo}
    %{\TClass}
    {\TIf}
    {\TLet}
    {\TConst}

    %{\TKw}

    {\TApp}

    {\TAbs}

    %{\TError}

    {\TSubsume}
  \end{mathpar}
  \caption{Typing rules}
  \label{main:figure:typingrules}
\end{figure*}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%    {\BLocal}
%
%    %{\BDo}
%
%    {\BLet}
%
%    \BVal{}
%
    %\BIfTrue{}

%    \BIfFalse{}
%
%    \BAbs{}
%
%    \BBetaClosure{}
%
%    \BDelta{}
%  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{main:figure:standardopsem}
%\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \standardsubtyping{}
  \end{mathpar}
  \caption{Subtyping rules}
  \label{main:figure:subtyping}
\end{figure*}

\subsection{Reasoning about Exceptional Control Flow}
\label{sec:doformal}

We extend our model with sequencing expressions and errors, where {\errorvalv{}}
models the result of calling Clojure's \clj{throw} special form
with some \clj{Throwable}.

\smallskip
$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\errorvalv{}} \alt {\doexp {\e{}} {\e{}}} &\mbox{Expressions} 
\end{altgrammar}
$

\smallskip
%
%B-Do simply evaluates its arguments sequentially and returns the right argument.
%Since errors are not values, we define error propagation semantics
%like BE-Do1 (figure~\ref{appendix:figure:errorstuck} for the full rules).
%
%\begin{mathpar}
%    {\BDo}
%
%\infer [BE-Error]
%{}
%{ \opsem {\openv{}} 
%         {\errorvalv{}}
%         {\errorvalv{}}}
%
%\infer [BE-Do1]
%{ \opsem {\openv{}} {\e{1}} {\errorvalv{}} }
%{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\errorvalv{}}}
%\end{mathpar}

Our main insight is as follows: 
if the left argument reduces to a value, then it is either logically true or false.
If we learn the same information in both cases then we can use it as an assumption to check the right argument.
T-Do formalises this intuition.

\begin{mathpar}
    {\TDo}  
\end{mathpar}

The introduction of errors, specifically as an expression that is neither true nor false, 
makes our insight interesting.

\begin{mathpar}
    {\TError}
\end{mathpar}

Now we can check example~\ref{example:doexception}.
We check the test with T-App:
$$
\judgement{\isprop{\UnionNilNum}{\x{}}}{\hastype{\appexp{\numberhuh}{\x{}}}{\Boolean}}{\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}
$$
By T-Nil and subsumption we derive the same information in both propositions.
$$
\judgement{\isprop{\Number}{\x{}}}{\hastype{\nil{}}{\Nil{}}}{\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}
$$
By T-Error we can assume anything about the return of an error.
$$
\judgement{\notprop{\Number}{\x{}}}{\hastype{\errorvalv{}}{\Bot}}{\filterset{\botprop{}}{\botprop{}}}{\emptyobject{}}
$$
Using the above as premises to T-If we learn {\orprop{\isprop{\Number}{\x{}}}{\botprop{}}}
in both propositions.
$$
\judgement{\isprop{\UnionNilNum}{\x{}}}
          {\hastype{\ifexp{\appexp{\numberhuh{}}{\x{}}}{\nil{}}{\errorvalv{}}}{\Boolean}}
          {\filterset{\orprop{\isprop{\Number}{\x{}}}{\botprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\botprop{}}}}{\emptyobject{}}
$$
By T-Local we know \x{} is a \Number{}.
$$
\judgement{\orprop{\isprop{\Number}{\x{}}}{\botprop{}}}{\hastype{\x{}}{\Number}}{\filterset{\notprop{\falsy{}}{\x{}}}{\isprop{\falsy{}}{\x{}}}}{\x{}}
$$
By T-App,
\inc{} requires a \Number{} argument which we just proved.
$$
\judgement{\orprop{\isprop{\Number}{\x{}}}{\botprop{}}}{\hastype{\appexp{\inc{}}{\x{}}}{\Number}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$
Finally we conclude with T-Do using the conditional and increment expressions as premises.
$$
\judgement{\isprop{\UnionNilNum}{\x{}}}
          {\hastype{\doexp
                     {\ifexp{\appexp{\numberhuh{}}{\x{}}}
                        {\nil{}}
                        {\errorvalv{}}}
                     {\appexp{\inc{}}{\x{}}}}{\Number}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$

\subsection{Heterogeneous maps}
\label{sec:hmapformal}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
    \pesyntax{}   &::=& \ldots \alt {\keype{\k{}}}
                  &\mbox{Path Elements}
  \end{altgrammar}
  $$
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \caption{HMap Terms, Types, Semantics, Subtyping and Typing Rules}
  \label{main:figure:hmapsyntax}
\end{figure}


We now present \HMapliteral{} types in detail.
Figure~\ref{main:figure:hmapsyntax} extends the syntax for terms and types.
The syntax 
$$
\clj{(HMap :mandatory p :absent-keys a :complete? b)}
$$
we introduced in section~\ref{sec:overview}
is now written \HMapgeneric{\mandatory{}}{\absent{}},
where \completenessmeta{} is {\complete{}} if \clj{b} is \clj{true} and is {\partial{}} otherwise. 
The \mandatory{} entry specifies a set of known present keyword entries and \absent{} tracks known absent keys.
To ease presentation, 
if a HMap is declared as \complete{} then \absent{} implicitly contains all other keywords not specified in \mandatory{}.
%\HMapcwithabsent{\mandatory{}}{\absent{}} is abbreviated to \HMapc{\mandatory{}}. 
Keys cannot be both present and absent.

The expressions \clj{(get m :a)} and \clj{(:a m)} are semantically identical, though
we only model the former to avoid the added complexity of keywords being functions.
To simplify presentation, we only provide syntax for the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}},
usually written {\curlymapvaloverrightnoarrow{\k{}}{\v{}}}.

Subtyping for HMaps (figure~\ref{main:figure:hmapsyntax})
designate \MapLiteral{} as a common supertype for all HMaps.
S-HMap says that a HMap is a subtype of another HMap if they agree
on \completenessmeta{}, agree on mandatory entries with subtyping
and at least cover the absent keys of the supertype.
Complete maps are subtypes of partial maps
as long as they agree on the mandatory entries of the partial map via subtyping (S-HMapP).

Figure~\ref{main:figure:hmapsyntax} contains the typing rules. T-GetHMap models a lookup
that will certainly succeed, T-GetHMapAbsent a lookup that will certainly fail
and T-GetHMapPartialDefault a lookup with unknown results.
We only handle unions of HMaps in T-GetHMap, where every element in the union
contains the key we are looking up, in particular to support operations like
looking up \clj{:op} on a map of type \clj{Expr} (example~\ref{example:decleaf}).
The object in each T-Get rule is now more complicated than in T-Local---the 
next section discusses this in detail.
T-Assoc extends a HMap with a mandatory entry.

Figure~\ref{main:figure:hmapsyntax} contains the semantics for \getliteral{}
and \assocliteral{}.
The B-Get rule evaluates first evaluates the map and the key, asserts
the key must be present in the map and returns the associated key. If
the entry is missing, B-GetMissing says we return \nil{}.

\subsection{Paths}


Recall the first insight of occurrence typing---not
only do we want to reason about components of the runtime environment, that
is, variables, but \emph{subcomponents} of the environment.
We briefly mentioned paths, written \path{\pathelem{}}{\x{}}, but we concentrated on
reasoning only about the variable \x{}---the notation \pathelem{} is a nested sequence of \emph{path elements}
applied right-to-left to a variable \x{}.
\citet{TF10} introduce the path elements \carpe{} and \cdrpe{}
to reason about selector operations on cons cells.
We instead want to reason about HMap lookups.

We introduce our first path element
{\keype{\k{}}}, which represents the operation of looking up
a key \k{}.
We directly relate this to our typing rule T-GetHMap
(figure~\ref{main:figure:hmapsyntax}) by
checking the then branch of the first conditional test is checked in 
an equivalent version of example~\ref{example:decleaf}.
\begin{minted}{clojure}
  (fn [m :- Expr]
    (if (= (get m :op) :if)
      {:op :if, ...}
      (if ...)))
\end{minted}

We do not specifically support \equivliteral{} in our calculus, 
but on keyword arguments it works identically to \clj{isa?} which we model
in section~\ref{sec:isaformal}.
Intuitively, if {\judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}}
then \equivapp{\e{}}{\makekw{if}} has the proposition set 
$$
{\replacefor{\filterset{\isprop{\Value{\makekw{if}}}{\x{}}}{\notprop{\Value{\makekw{if}}}{\x{}}}}{\object{}}{\x{}}}
$$
where substitution reduces to \topprop{} if \object{} = \emptyobject{}.

By T-Abs, checking the body of the function we have the proposition environment \propenv{} = {\isprop{\Expr{}}{m}}.
By T-Local we have
$$
\judgement{\propenv{}}{\hastype{m}{\Expr{}}}{\filterset{\notprop{\falsy{}}{\x{}}}{\isprop{\falsy{}}{\x{}}}}{m}
$$
and since {\Expr{}} is a union of HMaps with the entry \makekw{op}, we use T-GetHMap to derive
$$
\judgement{\propenv{}}{\hastype{\getexp{m}{\makekw{op}}}{\Keyword}}{\filterset{\topprop{}}{\topprop{}}}{\object{1}}
$$
where \object{1} = {\path{\keype{\makekw{op}}}{m}}. Using our intuitive definition of \equivliteral{} above, we know
$$
\judgement{\propenv{}}{\hastype{\equivapp{\getexp{m}{\makekw{op}}}{\makekw{if}}}{\Boolean}}{\filterset{\isprop{\Value{\makekw{if}}}{\object{1}}}{\notprop{\Value{\makekw{if}}}{\object{1}}}}{\emptyobject{}}
$$
Now we check the then branch with our new assumption.
$$
\judgement{\propenvp{}}{\hastype{\curlymap{{\mapvalentrykwkeynoarrow{op}{\makekw{if}}}, ...}}{\Expr{}}}{...}{...}
$$
We are interested in what L-Update can derive in our new environment,
\propenvp{} = {\isprop{\Expr{}}{m}},{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}.

With the premises
\inpropenv{\propenvp{}}{\isprop{\Expr{}}{m}}
and
\inpropenv{\propenvp{}}{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}
we derive
$$
\inpropenv{\propenvp{}}{\isprop{\update{\Expr{}}{\Value{\makekw{if}}}{\keype{\makekw{op}}}}{m}}
$$
which simplifies to 
$$
\inpropenv{\propenvp{}}{\isprop{\HMapp{\mandatoryset{{\mandatoryentrykwnoarrow{op}{\makekw{if}}}, {\mandatoryentrykwnoarrow{test}{\Expr{}}},
                                       {\mandatoryentrykwnoarrow{then}{\Expr{}}},   {\mandatoryentrykwnoarrow{else}{\Expr{}}}}}
                                   {\emptyabsent{}}}{m}}
$$

Our second path element \classpe{} is used in the latent
object of the constant \classconst{} function. Like Clojure's \clj{class}
function \classconst{} returns the argument's class or \nil{}
if passed \nil{}.
$$
\begin{array}{lrlr}
  \pesyntax{}   &::=& \ldots \alt {\classpe{}}
                &\mbox{Path Elements}
\end{array}
$$
\begin{mathpar}
\constanttypefigure{}
\end{mathpar}
The full semantics are given in figure~\ref{main:figure:primitivesem}.
The definition of \updateliteral{} supports various idioms relating to \classpe{}
which we introduce in section~\ref{sec:isaformal}.

\subsection{Java Interoperability and Type Hints}

\begin{figure}[h]
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \mininonreflectiveexpsyntax{}
    \\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \tatypesyntax{}\\
    \typehintenvsyntax{}\\
    \classtableallsyntax{}
  \end{altgrammar}
  $$
 \classtablelookupsyntax{}
  \begin{mathpar}
    {\TNewStatic}
    {\TFieldStatic}

    {\TMethodStatic}
  \end{mathpar}
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \begin{mathpar}
    %\RAbs{}
%
%    \RNewElimRefl{}
%
%    \RMethodElimRefl{}
%
%    \RFieldElimRefl{}
%
%    \RLet{}
%

%    \RLetHint{}
  \end{mathpar}
  \convertjavatypegrammar{}
  \caption{Java Interoperability Syntax, Semantics, Typing Rules and Rewrite Relation}
  \label{main:figure:javatyping}
\end{figure}

In section~\ref{sec:overviewjavainterop} we discussed the role of type hints
to help eliminate reflective calls.
In this section, we introduce our model of Java and provide user-facing
syntax corresponding to Clojure's Java interoperability forms and type hinted forms.
Then we model the Clojure compiler's compile-time reflection resolution
algorithm.
To achieve this, first we define notation for
\emph{non-reflective} Java forms that 
unambiguously call a field, method or constructor.
Then we define a rewrite relation that uses
type hints to resolve reflection explicitly.
Finally we give typing rules that model how
Typed Clojure interacts with non-reflective calls.

We present Java interoperability in a restricted setting without class inheritance,
overloading or Java Generics.

  $$
  \begin{altgrammar}
    \e{} &::=& \ldots   \localhintsyntax{} \alt \lethintsyntax{} &\mbox{Expressions}\\
            &\alt& \reflectiveexpsyntax{} 
  \end{altgrammar}
  $$

We extend the syntax with Java field lookups and calls to
methods and constructors. We model the syntax after the `dot' special
form to prevent ambiguity---\clj{(.fld e)} is now \fieldexp{\fld{}}{\e{}},
\clj{(.mth e es*)} is $\methodexp{\mth{}}{\e{}}{\overrightarrow{es}}$
and \clj{(.class es*)} is $\newexp{\class{}}{\overrightarrow{es}}$.
These come without typing or evaluation rules---Typed Clojure 
demands statically resolved Java interactions
in typed code
(as demonstrated in section~\ref{sec:overviewjavainterop}).
We add type hinted syntax for local variables and let-bindings.

Now we model the compiler's reflection-resolution algorithm.
Figure~\ref{main:figure:javatyping} gives the syntax for non-reflective Java calls.
The method ${\methodstaticexp {\classhint{1}}
                             {\overrightarrow {\classhint{i}}}
                             {\classhint{2}}
                             {\mth{}} {\e{}} {\overrightarrow{\e{i}}}}$
is a non-reflective call to the \mth{} method on class {\class{1}}, 
with Java signature 
${\classhint{2}}\ \mth{}\ (\overrightarrow {\classhint{i}});$.
The field {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{}}}
calls the field on class {\classhint{1}} with Java signature
${\classhint{2}}\ \fld{};$.
The constructor {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                               {\class{}} {\overrightarrow{\e{i}}}}
calls the constructor
${\classhint{}}\ ({\overrightarrow{\classhint{i}}});$.

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%%    \TALocal{}
%%
%%    \TANil{}
%%
%%    \TANewStatic{}
%%
%%    \TALetHint{}
%
%%    \TALet{}
%  \end{mathpar}
%\caption{Type Hint Inference (select rules, figure~\ref{appendix:figure:hintinfer} for full rules)}
%\label{main:figure:hintinfer}
%\end{figure}


To obtain non-reflective calls we define our rewrite relation
$$
\rewrite {\taenv{}} {\e{}} {\ep{}}
$$
which rewrites \e{} to a possibly-less reflective expression
\ep{} with respect to type hint environment
\taenv{} and Java class table \ct{}.

Type hint inference is modelled by
$$
\tajudgement {\taenv{}} {\hastype {\e{}} {\tatype{}}}
$$
which infers the (possibly-unknown) type hint \tatype{} of expression \e{} in environment \taenv{}.
%$$
%\TALetHint{}
%$$

To demonstrate we consider the expression 
$$
\fieldexp{getParent}{\hinted{\File}{\x{}}}.
$$
where 
$$
\ct = \{ \File \mapsto \{ \ctfieldsliteral \mapsto \{\ctfldentry{getMethod}{\String}\} \} \}
$$

R-FieldElimRefl eliminates a reflective field.
  $$
    \RFieldElimRefl{}
  $$
First the target is rewritten \rewrite {\taenv{}} {\hinted{\File}{\x{}}}{\hinted{\File}{\x{}}}
then we infer the type hint on the new expression \tajudgement {\taenv{}} {\hastype {\hinted{\File}{\x{}}} {\File}}
We call \fieldtypeliteral{} (figure~\ref{main:figure:javatyping})
to determine the exact signature of the field:
\fieldtype{\ct{}}{\File}{getParent}{\File}{\String}
and return the non-reflective field 
$$
\fieldstaticexp{\File}{\String}{getParent}{\hinted{\File}{\x{}}}.
$$

Now we present the typing rules (figure~\ref{main:figure:javatyping}).
To briefly finish our example, let us assume \propenv{} = {\isprop{\File}{\x{}}},
then
T-FieldStatic converts the target Java type to a non-nilable
type \javatotc {\File} {\File}} and checks the target against it 
\judgement{\propenv{}}{\hastype{\x{}}{\File}}, and finally converts the return Java type 
to a nilable type and \javatotc {\String} {\Union{\Nil{}}{\String}}
to finish with 
$$
\judgementtwo{\propenv{}}{\hastype{\fieldstaticexp{\File}{\String}{getParent}{\hinted{\File}{\x{}}}}{\Union{\Nil{}}{\String}}}.
$$

The other rules T-MethodStatic and T-NewStatic work similarly, and vary
primarily in the choice of nilability in the conversion function---method returns
are nilable and constructor returns are non-nilable.

The operational semantics B-Field, B-New and B-Method simply evaluate their
arguments and call the relevant JVM operation---section~\label{sec:metatheory}
states our exact assumptions about each one.

\subsection{Multimethod dispatch mechanism: \isaliteral}

\label{sec:isaformal}

Before tackling multimethods we model their core dispatch mechanism
\isaliteral{}, a subclassing test for classes, otherwise an equality test.

\begin{minted}{clojure}
(isa? Keyword Object) ;=> true
(isa? Object Keyword) ;=> false
(isa? :a :a) ;=> true
(isa? :a :b) ;=> false
(isa? :a Keyword) ;=> false
(isa? (class :a) Keyword) ;=> true
\end{minted}

B-IsA with the metafunction \isaopsemliteral{} reflect these semantics.

$$
\begin{array}{ll}
  \vcenter{\hbox{\BIsA{}}}
  &
  \vcenter{\hbox{\isaopsemfigure{}}}
\end{array}
$$

For the typing rules, we add T-Kw and T-Class for type checking keyword and class literals
as singleton types, and T-IsA for \isaliteral{} expressions, which 
uses the \emph{object} of the left argument and the \emph{type} of the right argument
to infer the final proposition set.

$$
\begin{array}{ll}
\vcenter{\hbox{
    \TIsA{}}} &

  \vcenter{\hbox{$
    \begin{array}{l}
      {\TKw}\\\\
      {\TClass}
    \end{array}$}}
\end{array}
$$

The definition of \isacompareliteral{} (figure~\ref{main:figure:mmsyntax}) is deliberately conservative.
The first line considers the case where the object of the left argument
is a non-empty path ending in \classpe{} and the type of the right argument is a singleton class.
The simplest example

\begin{minted}{clojure}
  (isa? (class x) Keyword)
\end{minted}

has the proposition set \isacompare{\s{}}{\path{\classpe{}}{\x{}}}{\Value{\Keyword}}{\filterset{\isprop{\Keyword}{\x{}}}{\notprop{\Keyword}{\x{}}}},
that is if the expression is true then \clj{x} is a keyword, otherwise \clj{x} is not a keyword.

We can rewrite example~\ref{example:conditionalflow} as
\inputminted[firstline=5]{clojure}{code/demo/src/demo/isa_nil.clj}

because the then proposition is {\isprop{\Class}{\path{\classpe{}}{\x{}}}}, so
we know {\isprop{\Object}{\x{}}} by L-Update, and combined with the fact {\isprop{\Union{\Nil{}}{\Number}}{\x{}}}
we can infer {\isprop{\Number}{\x{}}} by L-Update.

The second \isacompareliteral{} line handles the equality mode of \isaliteral{}
with a non-class singleton type as the second argument.



\constantsemfigure{main}

%Substitution is used to ensure well formed propositions.

The final line gives up---we cannot distinguish between equality and subclassing mode.

\subsection{Multimethods}

\begin{figure}
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\createmultiexp {\t{}} {\e{}}} &\mbox{Expressions} \\
             &\alt& {\extendmultiexp {\e{}} {\e{}} {\e{}}}
             \alt {\isaapp {\e{}} {\e{}}}\\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \begin{mathpar}
    \isapropsfigure{}
  \end{mathpar}
  \begin{mathpar}
    \TDefMulti{}

    \TDefMethod{}
  \end{mathpar}
  \getmethodfigure{}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    \BBetaMulti{}
  \end{mathpar}
\caption{Multimethod Syntax, Subtyping, Typing Rules and Semantics}
\label{main:figure:mmsyntax}
\end{figure}

To ease presentation, we present \emph{immutable}
multimethods (figure~\ref{main:figure:mmsyntax}). \defmethodliteral{} returns a new extended multimethod
without changing the original multimethod. Example~\ref{example:rep} is now written
\begin{minted}{clojure}
(let [rep (defmulti [Any -> String] class)
      rep (defmethod rep Keyword [x] (str (name x)))
      rep (defmethod rep Number [x] (str (inc x)))]
  (rep :a)) ;=> "a"
\end{minted}

Multimethod semantics are in figure~\ref{main:figure:mmsyntax}.
B-DefMulti creates a multimethod with a dispatch function and an empty dispatch table.
B-DefMethod returns a new multimethod with an extended dispatch table.
B-BetaMulti invokes the dispatch function with the evaluated argument to get the dispatch value,
which \getmethodliteral{} uses to choose the method to invoke.

The typing rules (figure~\ref{main:figure:mmsyntax}) use the multimethod type {\MultiFntype{\s{}}{\t{}}}, 
where \s{} is the interface type for beta reduction, and \t{} is the type for
the dispatch function. T-DefMulti uses the provided interface type and dispatch function
to infer the multimethod type. T-DefMethod uses \isacompareliteral{} to infer the proposition
that must be true if this method is being invoked. The example can be type checked without
changes since we infer \isprop{\Number}{\x{}} and \isprop{\Keyword}{\x{}} for the respective
method bodies. T-App handles beta reduction because multimethods are subtypes of functions
(figure~\ref{main:figure:mmsyntax}).



\begin{figure*}
  $$
\begin{array}{lllll}
\updatefigure
\end{array}
$$
\caption{Type Update}
\label{main:figure:update}
\end{figure*}

\begin{figure}
  $$
\begin{array}{lllll}
  \restrictremovefigure{}
\end{array}
  $$
  \caption{Restrict and Remove}
  \label{main:figure:restrictremove}
\end{figure}
