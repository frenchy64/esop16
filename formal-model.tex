\section{A Formal Model of Typed Clojure}

\label{sec:formal}

We describe our type system in a similar way to Typed Racket (\citet{TF10}),
with differences highlighted in $\trdiff{\text{blue}}$.
The typing judgement 
$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}.

The propositions capture what can be assumed if an expression tests as logically true or false
respectively. The object is a possibly-empty symbolic representation of the expression.

Syntax is given in figure~\ref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals and let expressions.
All binding forms introduce fresh variables.

Values include booleans, \nil{}, class literals, keywords (written with a : prefix like \makekw{a}), 
constants and closures.  \false{} and \nil{} are logically false; all other values are logically true.

Types include the top type, untagged unions, functions, singleton types
and class instances. We abbreviate \EmptyUnion{} as \Bot{}, {\ValueNil} as \Nil{} and similarly
for \True and \False.
Function types contain \emph{latent} propositions and object, which, along with the return type,
may refer to the parameter identifier. They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

Propositions are identical to~\cite{TF10}---positive and negative type propositions, implications,
conjunctions, disjuctions, trivial and impossible propositions.
Type propositions contain a non-empty object which it claims type information about.

Proposition environments are sequences of propositions in conjunctive normal form.

Figure ~\ref{main:figure:typingrules} contains the standard typing rules.
The operational semantics are standard, except \nil{} is logically false:

\begin{mathpar}
    \BIfTrue{}

    \BIfFalse{}
\end{mathpar}

Subtyping (figure~\ref{main:figure:subtyping}) says singleton types are instances of their respective classes
and \Object is transitively a supertype to everything except {\Nil{}},
so \Top{} = {\Union{\Nil}{\Object}}.

\begin{figure}
  \footnotesize
$$
\begin{array}{lrll}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}} &\mbox{Expressions} \\
                      &\alt& {\ifexp {\e{}} {\e{}} {\e{}}}
                      %\alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}\\
                      %\alt {\errorvalv{}}
  \v{} &::=&          \singletonmeta{}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
                \constantssyntax{}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                &\mbox{Types} \\
                      &\alt& {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}\\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \propenvsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{array}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TLocal}

    {\TTrue}

    {\TFalse}

    {\TNil}

    %{\TDo}
    %{\TClass}
    {\TIf}
    {\TLet}

    %{\TKw}

    {\TApp}

    {\TAbs}

    %{\TError}

    {\TSubsume}
  \end{mathpar}
  \caption{Typing rules}
  \label{main:figure:typingrules}
\end{figure*}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%    {\BLocal}
%
%    %{\BDo}
%
%    {\BLet}
%
%    \BVal{}
%
    %\BIfTrue{}

%    \BIfFalse{}
%
%    \BAbs{}
%
%    \BBetaClosure{}
%
%    \BDelta{}
%  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{main:figure:standardopsem}
%\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \standardsubtyping{}
  \end{mathpar}
  \caption{Subtyping rules}
  \label{main:figure:subtyping}
\end{figure*}

\subsection{Reasoning about Exceptional Control Flow}
\label{sec:doformal}

Clojure assertions expand to simple exceptional control flow.

\begin{minted}{clojure}
(fn [x :- (U nil Number)] 
  (assert (number? x))
  (inc x))
\end{minted}

roughly expands to

\begin{minted}{clojure}
(fn [x :- (U nil Number)]
  (do (if (number? x) nil (throw (new Exception)))
      (inc x)))
\end{minted}

We extend our model with sequencing expressions and errors, where {\errorvalv{}}
is equivalent to Clojure's throw.

\smallskip
$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\errorvalv{}} \alt {\doexp {\e{}} {\e{}}} &\mbox{Expressions} 
\end{altgrammar}
$

\smallskip

B-Do simply evaluates its arguments sequentially and returns the right argument.
Since errors are not values, we define error propagation semantics
like BE-Do1 (figure~\ref{appendix:figure:errorstuck} for the full rules).

\begin{mathpar}
    {\BDo}

\infer [BE-Error]
{}
{ \opsem {\openv{}} 
         {\errorvalv{}}
         {\errorvalv{}}}

\infer [BE-Do1]
{ \opsem {\openv{}} {\e{1}} {\errorvalv{}} }
{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\errorvalv{}}}
\end{mathpar}

Our main insight is as follows: 
if the left argument reduces to a value, then it is either logically true or false.
Occurrence typing gives exactly the propositions for both cases, so their disjunction
can be assumed for the right argument.
T-Do formalises this intuition.

\begin{mathpar}
    {\TDo}  

    {\TError}
\end{mathpar}

The introduction of errors, specifically as an expression that is neither true nor false, 
makes our insight interesting.
For example, in checking \clj{(do (throw (Exception.)) (inc :a))}
by T-Error we assume \orprop{\botprop{}}{\botprop{}} in checking \clj{(inc :a)},
which is a contradiction by the logic system (L-False, figure~\ref{appendix:figure:proofsystem})
which allows us to assume \clj{(inc :a)} is unreachable (and it clearly is by BE-Do1).

This works similarly with our motivating example. Intuitively, when evaluating
\clj{(inc x)} we know \clj{(assert (number? x))} has evaluated to a value,
so we assume \clj{x} is a number.
In detail, the example is checked first by T-Abs, which checks the body with the 
environment \propenv{} = {\isprop{\Union{\Nil}{\Number{}}}{\x{}}}.
Since the body is a \doliteral{},
T-Do extracts the propositions of the left argument, an if:
T-If says 
\thenprop{\prop{1}} = {\orprop{\botprop{}}{\notprop{\falsy{}}{\x{}}}}
by T-Nil and T-Subsume and
\elseprop{\prop{1}} = {\orprop{\botprop{}}{\botprop{}}} by T-Error.
Now {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}} = {\notprop{\falsy}{\x{}}}
and we check \clj{(inc x)} in the extended environment 
\ma{{\propenv{},{\notprop{\falsy}{\x{}}}}}.
By L-Update (figure~\ref{appendix:figure:proofsystem}) we know {\isprop{\Number}{\x{}}},
so T-Local checks \clj{x} as a \Number.

\subsection{Heterogenous maps}
\label{sec:hmapformal}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
    \pesyntax{}   &::=& \ldots \alt {\keype{\k{}}}
                  &\mbox{Path Elements}
  \end{altgrammar}
  $$
  \caption{HMap Terms and Types}
  \label{main:figure:hmapsyntax}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \caption{HMap Semantics}
  \label{main:figure:hmapsem}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \caption{HMap Typing Rules}
  \label{main:figure:hmaptyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \caption{HMap subtyping rules}
  \label{main:figure:hmapsubtype}
\end{figure}

We now present \HMapliteral{} types in detail.
Figure~\ref{main:figure:hmapsyntax} extends the syntax for terms and types.
\clj{(HMap :mandatory p :absent-keys a)} is written \HMapgeneric{\mandatory{}}{\absent{}}.
The metavariable \completenessmeta{} tracks whether a HMap is fully ({\complete{}}) or partially ({\partial{}})
specified. \mandatory{} specifies a set of known present keyword entries, \absent{} tracks known absent keyword
entries and we abbreviate \HMapcwithabsent{\mandatory{}}{\absent{}} as \HMapc{\mandatory{}}. Keys cannot be both present and absent.

\getliteral{} and \assocliteral{} lookup and extend immutable maps respectively.
To simplify presentation, we only provide syntax for the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}}.

We introduce our first path element {\keype{\k{}}}, the symbolic representation
of a \getliteral{} expression on keyword \k{} where the sentinel value for
a missing entry is \nil{}.

Figure~\ref{main:figure:hmapsem} shows the semantics for HMaps. B-Get returns the associated
value if the entry is present otherwise  B-GetMissing returns \nil{}. B-Assoc returns a new extended
map.

Typing rules are given in figure~\ref{main:figure:hmaptyping}. T-GetHMap handles the simple
case where we know a lookup will succeed and use B-Get. In T-GetHMapAbsent we know B-GetMissing will give
a \Nil{} return type.
T-GetHMapPartialDefault does not know if the key is present or absent and has a \Top{} return type.
Even though their types vary significantly, we still use the same object.
T-Assoc extends the known keyword entries, overwriting previous entries with the same key.

S-HMap (figure~\ref{main:figure:hmapsubtype}) says that HMap subtypes must have all present entries to also be
subtypes and also cover the absent keys.
Complete maps are subtypes of partial maps by S-HMapP.

\subsection{\classconst{}}

The \classconst{} function is modeled as a constant which returns
an object's \Class{}, or \nil{} if provided \nil{}.

\begin{mathpar}
\constanttypefigure{}
\end{mathpar}

Our second path element \classpe{} is the symbolic representation
of a call to \classconst{}.

$$
\begin{array}{lrlr}
  \pesyntax{}   &::=& \ldots \alt {\classpe{}}
                &\mbox{Path Elements}
\end{array}
$$

% TODO semantics

\subsection{Proof system}

The essential piece of occurrence typing's logical system is L-Update,
where we combine propositions that have similar objects to learn new facts.
(The metavariable \propisnotmeta{} ranges over \t{} and \nottype{\t{}} (without variables).)

\begin{mathpar}
  {\LUpdate}
\end{mathpar}

For example, if \inpropenv {\propenv{}} {\isprop {\Union{\Keyword}{\Nil}} {\x{}}}
and
\inpropenv {\propenv{}} {\notprop {\Nil{}} {\x{}}},
then
$$
\inpropenv {\propenv{}} {\isprop {\update {\Union{\Keyword}{\Nil}} {\nottype{\Nil{}}} {\emptypath{}}} {\x{}}},
$$
so we learn \inpropenv {\propenv{}} {\isprop {\Keyword{}} {\x{}}} using \removeliteral{} (figure~\ref{main:figure:restrictremove}).

Now that we have our path elements \classpe{} and \keype{\k{}}
and the typings rules that introduce them, we look at \updateliteral{} 
(figure~\ref{main:figure:update}) and give one interesting example for each.

\smallsection{\classpe{}}
Consider the then branch of the following program:

\begin{minted}{clojure}
(fn [x :- (U nil Keyword)]
  (when (class x)
    ; here
    ))
\end{minted}

Intuitively, since \clj{(class x)} is a true value it must be a class, therefore
\clj{x} is an object (not \clj{nil}).

From checking the body with T-Abs we know {\isprop {\Union{\Keyword}{\Nil}} {\x{}}}
The test has the object {\path{\classpe{}}{\x{}}} by T-App.
By T-If we can assume
{\notprop {\falsy{}} {\path{\classpe{}}{\x{}}}} in the then branch.
Since the object of the first proposition {\x{}} is a prefix of the second proposition's object
{\path{\classpe{}}{\x{}}}, 
by T-Update 
$$
\inpropenv {\propenv{}} {\isprop {\update {\Union{\Keyword}{\Nil}} {\nottype {\falsy{}}} {\classpe{}}} {\x{}}}.
$$

This hits the sixth \classpe{} case of \updateliteral{}, which returns
$$
{\update {\Union{\Keyword}{\Nil}} {\Object} {\emptypath{}}}
$$
deriving \inpropenv {\propenv{}} {\isprop {\Keyword} {\x{}}} 
by \restrictliteral{} (figure~\ref{main:figure:restrictremove}).

\smallsection{\keype{\k{}}}
Consider the then branch of

\begin{minted}{clojure}
(fn [x :- '{:kw (U nil Keyword)}]
  (when (get x :kw)
    ; here
    ))
\end{minted}

Similar to before,
by T-Abs
{\isprop {\HMapp{\mandatorysetsingleton{\makekw{kw}}{\Union{\Nil}{\Keyword}}}{\emptyabsent}} {\x{}}},
the test's object is {\path{\keype{\makekw{kw}}}{\x{}}} by T-App
and by T-If we assume
{\notprop {\falsy{}} {\path{\keype{\makekw{kw}}}{\x{}}}} in the then branch.

T-Update combines these propositions
$$
\inpropenv {\propenv{}} {\isprop {\update {\HMapp{\mandatorysetsingleton{\makekw{kw}}{\Union{\Nil}{\Keyword}}}{\emptyabsent}} {\nottype {\falsy{}}} {\keype{\makekw{kw}}}} {\x{}}}.
$$
matching the \updateliteral{} case which pushes the \updateliteral{} inside the map
$$
{\HMapp{\mandatorysetsingleton{\makekw{kw}}{\update{\Union{\Nil}{\Keyword}}{\nottype {\falsy{}}}{\emptypath{}}}}{\emptyabsent}}
$$
concluding with
$$
\inpropenv {\propenv{}}
{\isprop {\HMapp{\mandatorysetsingleton{\makekw{kw}}{\Keyword}}{\emptyabsent}}   {\x{}}}.
$$

\begin{figure*}
  $$
\begin{array}{lllll}
\updatefigure
\end{array}
$$
\caption{Type Update}
\label{main:figure:update}
\end{figure*}

\subsection{Java Interoperability and Type Hints}

We model
Java interoperability in a restricted setting without class inheritance,
overloading or Java Generics. 

  $$
  \begin{altgrammar}
    \e{} &::=& \ldots   \localhintsyntax{} \alt \lethintsyntax{} &\mbox{Expressions}\\
            &\alt& \reflectiveexpsyntax{} 
  \end{altgrammar}
  $$

We extend the external language with Java field lookups and calls to
methods and constructors.
These come without typing or evaluation rules:
Typed Clojure requires the Clojure compiler to statically resolve all Java interactions
in typed code.
Type hinted expressions such as \localhintsyntax{} 
to help the compiler eliminate reflection.

\begin{figure*}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \mininonreflectiveexpsyntax{}
    &\mbox{Expressions}\\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \tatypesyntax{}\\
    \typehintenvsyntax{}\\
    \classtableallsyntax{}
  \end{altgrammar}
  $$
  \caption{Internal Language Reflection Resolution Extensions}
  \label{main:figure:nonreflectivesyntax}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    %\RAbs{}
%
%    \RNewElimRefl{}
%
%    \RMethodElimRefl{}
%
    \RFieldElimRefl{}
%
%    \RLet{}
%

    \RLetHint{}
  \end{mathpar}
\caption{Reflection Elimination %(select rules, figure~\ref{appendix:figure:rewrite} for full rules)
}
\label{main:figure:rewrite}
\end{figure}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%%    \TALocal{}
%%
%%    \TANil{}
%%
%%    \TANewStatic{}
%%
%%    \TALetHint{}
%
%%    \TALet{}
%  \end{mathpar}
%\caption{Type Hint Inference (select rules, figure~\ref{appendix:figure:hintinfer} for full rules)}
%\label{main:figure:hintinfer}
%\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \caption{Java Interoperability Semantics}
\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TNewStatic}

    {\TFieldStatic}
    {\TMethodStatic}
  \end{mathpar}
  \caption{Java Interoperability Typing Rules}
  \label{main:figure:javatyping}
\end{figure*}

$$
\rewrite {\taenv{}} {\e{}} {\ep{}}
$$

rewrites expression \e{} to a possibly-less reflective expression
\ep{} with respect to type hint environment
\taenv{} and Java class table \ct{}.

$$
\tajudgement {\taenv{}} {\hastype {\e{}} {\tatype{}}}
$$

infers the (possibly-unknown) type hint \tatype{} of expression \e{} in environment \taenv{}.

%$$
%\TALetHint{}
%$$

We now have two languages: an internal language that may contain non-reflective Java calls (figure 
  \ref{main:figure:nonreflectivesyntax}) 
  and an external language that resembles Clojure, where we must rely on type-hints to resolve
  reflective Java calls (figure~\ref{main:figure:reflectivesyntax}).

  $$
    \RFieldElimRefl{}
  $$

For example, R-FieldElimRefl, which rewrites a reflective field call to be non-reflective,
rewrites the target expression and uses the result to infer a class type hint as the field target.
\fieldtypeliteral{} uses the inferred type hint to lookup if the inferred class has the appropriate
field name and returns the actual target and result type hints which we store in the rewritten rule.

We then extract these type hints in T-FieldStatic for typing checking 
(figure~\ref{main:figure:javatyping}), which converts type hints
with \javatotcliteral{} to obtain a \emph{non-nilable} type to type check the target expression (which prevents
dereferencing nil) and \javatotcnilliteral{} to get a \emph{nilable} return type (because fields can be nil).

Method and constructor calls are similar, but T-MethodStatic and T-NewStatic disallow passing \nil{} as arguments, 
we assume methods can return \nil{} and we assume constructors cannot.

We rewrite to our internal language before type checking and remaining reflective calls are type errors.

\subsection{Multimethod dispatch mechanism: \isaliteral}

Before tackling multimethods we model their core dispatch mechanism
\isaliteral{}, a subclassing test for classes, otherwise an equality test.

\begin{minted}{clojure}
(isa? Keyword Object) ;=> true
(isa? Object Keyword) ;=> false
(isa? :a :a) ;=> true
(isa? :a :b) ;=> false
(isa? :a Keyword) ;=> false
(isa? (class :a) Keyword) ;=> true
\end{minted}

B-IsA with the metafunction \isaopsemliteral{} reflect these semantics.

$$
\begin{array}{ll}
  \vcenter{\hbox{\BIsA{}}}
  &
  \vcenter{\hbox{\isaopsemfigure{}}}
\end{array}
$$

For the typing rules, we add T-Kw and T-Class for type checking keyword and class literals
as singleton types, and T-IsA for \isaliteral{} expressions, which 
uses the \emph{object} of the left argument and the \emph{type} of the right argument
to infer the final proposition set.

$$
\begin{array}{ll}
\vcenter{\hbox{
    \TIsA{}}} &

  \vcenter{\hbox{$
    \begin{array}{l}
      {\TKw}\\\\
      {\TClass}
    \end{array}$}}
\end{array}
$$

The definition of \isacompareliteral{} (figure~\ref{main:figure:isaprops}) is deliberately conservative.
The first line considers the case where the object of the left argument
is a non-empty path ending in \classpe{} and the type of the right argument is a singleton class.
The simplest example

\begin{minted}{clojure}
  (isa? (class x) Keyword)
\end{minted}

has the proposition set \isacompare{\s{}}{\path{\classpe{}}{\x{}}}{\Value{\Keyword}}{\filterset{\isprop{\Keyword}{\x{}}}{\notprop{\Keyword}{\x{}}}},
that is if the expression is true then \clj{x} is a keyword, otherwise \clj{x} is not a keyword.

We can use \isaliteral{} as a crude \nil{} test

\inputminted[firstline=5]{clojure}{code/demo/src/demo/isa_nil.clj}

because the then proposition is {\isprop{\Class}{\path{\classpe{}}{\x{}}}}, so
we know {\isprop{\Object}{\x{}}} by L-Update, and combined with the fact {\isprop{\Union{\Nil{}}{\Number}}{\x{}}}
we can infer {\isprop{\Number}{\x{}}} by L-Update.

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \isapropsfigure{}
  \end{mathpar}

  \center{Takes \emph{object} of the left parameter and \emph{type} of the right parameter.}
  \caption{Proposition Set for \isaliteral{} expressions}
  \label{main:figure:isaprops}
\end{figure}

The second \isacompareliteral{} line handles the equality mode of \isaliteral{}
with a non-class singleton type as the second argument.



Substitution is used to ensure well formed propositions.

The final case gives up; we cannot distinguish between equality and subclassing mode.

\subsection{Multimethods}

\begin{figure*}
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt \multimethodexpsyntax{} 
                &\mbox{Expressions} \\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
\caption{Multimethod Syntax}
\label{main:figure:mmsyntax}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \TDefMulti{}

    \TDefMethod{}
  \end{mathpar}
  \caption{Multimethod typing rules}
  \label{main:figure:mmtyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \caption{Multimethod subtyping rules}
  \label{main:figure:mmsubtype}
\end{figure}


\begin{figure}
  \footnotesize
  \getmethodfigure{}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    \BBetaMulti{}
  \end{mathpar}
  \caption{Multimethod and method resolution semantics}
  \label{main:figure:mmsemantics}
\end{figure}

To ease presentation, we present \emph{immutable}
multimethods (figure~\ref{main:figure:mmsyntax}). \defmethodliteral{} returns a new extended multimethod
without changing the original multimethod. The above is now written

%$\letexp{foo}{\defmultiexp {\ArrowOne{\x{}}{\Top}{\clj{String}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}}
%                       {\classconst{}}}
%                     {\\ bar}$

\begin{minted}{clojure}
(let [foo (defmulti [Any -> String] class)
      foo (defmethod foo Number [x] (str (inc x)))
      foo (defmethod foo Keyword [x] (str (name x)))]
  (foo :a)) ;=> "a"
\end{minted}

Multimethod semantics are in figure~\ref{main:figure:mmsemantics}.
B-DefMulti creates a multimethod with a dispatch function and an empty dispatch table.
B-DefMethod returns a new multimethod with an extended dispatch table.
B-BetaMulti invokes the dispatch function with the evaluated argument to get the dispatch value,
which \getmethodliteral{} uses to choose the method to invoke.

The typing rules (figure~\ref{main:figure:mmtyping}) use the multimethod type {\MultiFntype{\s{}}{\t{}}}, 
where \s{} is the interface type for beta reduction, and \t{} is the type for
the dispatch function. T-DefMulti uses the provided interface type and dispatch function
to infer the multimethod type. T-DefMethod uses \isacompareliteral{} to infer the proposition
that must be true if this method is being invoked. The example can be type checked without
changes since we infer \isprop{\Number}{\x{}} and \isprop{\Keyword}{\x{}} for the respective
method bodies. T-App handles beta reduction because multimethods are subtypes of functions
(figure~\ref{main:figure:mmsubtype}).



{\footnotesize
\constantsemfigure{}

{\convertjavatypefigure{figure}{\footnotesize}}
}

\begin{figure}
  $$
\begin{array}{lllll}
  \restrictremovefigure{}
\end{array}
  $$
  \caption{Restrict and Remove}
  \label{main:figure:restrictremove}
\end{figure}
