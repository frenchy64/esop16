\section{A Formal Model of Typed Clojure}

\label{sec:formal}

Now that we have demonstrated the core features Typed Clojure
provides, we present a model that links them all together.
Our presentation will start with a review of
occurrence typing~\cite{TF10}.
Then for the rest of the section we incrementally add each
novel feature of Typed Clojure to the formalism,
interleaving presentation of typing rules, operational semantics
and
subtyping.

The first insight about occurrence typing is that
propositions can be used to capture type information about our programs,
in particular by referencing components or subcomponents of the runtime environment
and relating them to types.
\emph{Type Propositions} make assertions like ``variable \clj{x} is of type \clj{Number}'' or
``variable \clj{x} is not \clj{nil}''---
in our logical system we write these as
{\isprop{\clj{Number}}{\x{}}}
and {\notprop{\clj{nil}}{\x{}}}. 
The other propositions are standard: the implication, conjunction,
disjunction, trivial (\topprop{}) and impossible (\botprop{}) propositions
(figure~\ref{main:figure:termsyntax}).

The particular part of the environment we reference in a positive or negative
type proposition is called the \emph{object}.
Every expression has an object that is either \emph{empty}, written \emptyobject{}, which says there is no
known way to relate this expression to the current environment, or a 
variable with some \emph{path}, written \path{\pathelem{}}{\x{}},
that exactly indicates how the value of this
expression can be derived from the current environment.
Type propositions can only reference non-empty objects.

The second insight is that we can replace the traditional 
representation of a
type environment of a map from variables to types
with a sequence of propositions, written \propenv{}. 
Instead of mapping \clj{x} to
the type \clj{Number}, we instead use the proposition {\isprop{\clj{Number}}{\x{}}}.

The third insight is that we
can use a logic system to learn new information about our programs.
The key component of the logic system L-Update uses type propositions
to derive new propositions.
$$
  {\LUpdate}
$$
For example, with L-Update we can use the knowledge of
\inpropenv{\propenv{}}{\isprop{\clj{(U nil Number)}}{\x{}}}
and 
\inpropenv{\propenv{}}{\notprop{\clj{nil}}{\x{}}}
to derive \inpropenv{\propenv{}}{\isprop{\clj{Number}}{\x{}}}.
(The metavariable \propisnotmeta{} ranges over \t{} and \nottype{\t{}} (without variables).)
We cover \updateliteral{} in section~\ref{sec:updateformalsection}.

The fourth insight is a consequence of
programmers in dynamic languages
using implicit type-based reasoning based on the result of
conditional tests.
For instance, example~\ref{example:conditionalflow}
only utilises \clj{x} once
the programmer is convinced it is safe to do so based whether
\clj{(number? x)}
is 
a true or false value. The takeaway is that every expression has
two extra pieces of information relevant to the logic system: a `then' proposition
for when it reduces to a true value, and an `else' proposition
when it reduces to a false value---for \clj{(number? x)}
the then proposition is {\isprop{\clj{Number}}{\x{}}} and 
the else proposition is {\notprop{\clj{Number}}{\x{}}}.
%\ref{main:figure:typingrules}

\begin{figure}
  \footnotesize
$$
\begin{array}{lrll}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}} &\mbox{Expressions} \\
                      &\alt& {\ifexp {\e{}} {\e{}} {\e{}}}
                      %\alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}\\
                      %\alt {\errorvalv{}}
  \v{} &::=&          \singletonmeta{}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
                \constantssyntax{}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                &\mbox{Types} \\
                      &\alt& {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}\\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \propenvsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{array}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure}


We formalise our type system following~\citet{TF10}
(with differences highlighted in $\trdiff{\text{blue}}$).
The typing judgement 
$$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}. We sometimes write 
{\judgementtwo{\propenv}{\hastype {\e{}} {\t{}}} if we are only interested in the type.

Syntax is given in figure~\ref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals and let expressions.
All binding forms introduce fresh variables.
Values include booleans, \nil{}, class literals, keywords, 
constants and closures. \false{} and \nil{} are logically false, otherwise values are true.

Types include the top type, \emph{untagged} unions, functions, singleton types
and class instances. We abbreviate \EmptyUnion{} as \Bot{}, {\ValueNil} as \Nil{}, 
{\ValueTrue} as \True and {\ValueFalse} as {\False}.
Function types contain \emph{latent}(terminology from~\cite{Lucassen88polymorphiceffect}) propositions and object, which, along with the return type,
may refer to the parameter identifier. They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

Figure~\ref{main:figure:typingrules} contains the standard typing rules.
We can now demonstrate how to check example~\ref{example:conditionalflow}.
We abbreviate \clj{Num} as \clj{N},  \clj{Boolean} as \clj{B} and \clj{number?} as \clj{n?}.
The test is checked with T-App, 
$$
\judgement{\isprop{\clj{(U nil N)}}{\x{}}}{\hastype{\clj{(n? x)}}{\clj{B}}}{\filterset{\isprop{\clj{N}}{\x{}}}{\notprop{\clj{N}}{\x{}}}}{\emptyobject{}}
$$
\clj{n?} has type
$$
{\ArrowOne{\x{}}{\clj{Any}}{\clj{B}}
        {\filterset{\isprop{\clj{N}}{\x{}}}{\notprop{\clj{N}}{\x{}}}}{\emptyobject{}}}
$$
By T-Local.
$$
\judgement{\isprop{\clj{N}}{\x{}}}{\hastype{\clj{x}}{\clj{N}}}{\filterset{\topprop{}}{\topprop{}}}{\x{}}
$$
Now we check both branches.
$$
\judgement{\isprop{\clj{N}}{\x{}}}{\hastype{\clj{(inc x)}}{\clj{N}}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$
$$
\judgement{\notprop{\clj{N}}{\x{}}}{\hastype{\clj{0}}{\clj{N}}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$
We can now check the conditional with T-If.
$$
\judgement{\isprop{\clj{N}}{\x{}}}{\hastype{\clj{(if (n? x) (inc x) 0)}}{\clj{N}}}{\filterset{\orprop{\isprop{\clj{N}}{\x{}}}{\topprop{}}}{\orprop{\notprop{\clj{N}}{\x{}}}{\topprop{}}}}{\emptyobject{}}
$$
Finally the function can be checked with T-Abs.
$$
\judgement{}{\hastype{\clj{(fn ...)}}
                                             {\ArrowOne{\x{}}{\clj{(U nil N)}}{\clj{N}}
        {\filterset{\orprop{\isprop{\clj{N}}{\x{}}}{\topprop{}}}{\orprop{\notprop{\clj{N}}{\x{}}}{\topprop{}}}}{\emptyobject{}}}}
  {\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
$$
By T-Abs

The operational semantics are standard, except \nil{} is logically false:

\begin{mathpar}
    \BIfTrue{}

    \BIfFalse{}
\end{mathpar}

Subtyping (figure~\ref{main:figure:subtyping}) says singleton types are instances of their respective classes
and \Object is transitively a supertype to everything except {\Nil{}},
so \Top{} = {\Union{\Nil}{\Object}}.

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TLocal}

    {\TTrue}

    {\TFalse}

    {\TNil}

    %{\TDo}
    %{\TClass}
    {\TIf}
    {\TLet}
    {\TConst}

    %{\TKw}

    {\TApp}

    {\TAbs}

    %{\TError}

    {\TSubsume}
  \end{mathpar}
  \caption{Typing rules}
  \label{main:figure:typingrules}
\end{figure*}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%    {\BLocal}
%
%    %{\BDo}
%
%    {\BLet}
%
%    \BVal{}
%
    %\BIfTrue{}

%    \BIfFalse{}
%
%    \BAbs{}
%
%    \BBetaClosure{}
%
%    \BDelta{}
%  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{main:figure:standardopsem}
%\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \standardsubtyping{}
  \end{mathpar}
  \caption{Subtyping rules}
  \label{main:figure:subtyping}
\end{figure*}

\subsection{Reasoning about Exceptional Control Flow}
\label{sec:doformal}

We extend our model with sequencing expressions and errors, where {\errorvalv{}}
models Clojure's throw special form.

\smallskip
$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\errorvalv{}} \alt {\doexp {\e{}} {\e{}}} &\mbox{Expressions} 
\end{altgrammar}
$

\smallskip
%
%B-Do simply evaluates its arguments sequentially and returns the right argument.
%Since errors are not values, we define error propagation semantics
%like BE-Do1 (figure~\ref{appendix:figure:errorstuck} for the full rules).
%
%\begin{mathpar}
%    {\BDo}
%
%\infer [BE-Error]
%{}
%{ \opsem {\openv{}} 
%         {\errorvalv{}}
%         {\errorvalv{}}}
%
%\infer [BE-Do1]
%{ \opsem {\openv{}} {\e{1}} {\errorvalv{}} }
%{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\errorvalv{}}}
%\end{mathpar}

Our main insight is as follows: 
if the left argument reduces to a value, then it is either logically true or false.
If we learn the same information in both cases then we can use it as an assumption to check the right argument.
T-Do formalises this intuition.

\begin{mathpar}
    {\TDo}  
\end{mathpar}

The introduction of errors, specifically as an expression that is neither true nor false, 
makes our insight interesting.

\begin{mathpar}
    {\TError}
\end{mathpar}

Now we can check example~\ref{example:doexception}.
We check the test with T-App.
$$
\judgement{\isprop{\clj{(U nil Num)}}{\x{}}}{\hastype{\clj{(number? x)}}{\clj{B}}}{\filterset{\isprop{\clj{Num}}{\x{}}}{\notprop{\clj{Num}}{\x{}}}}{\emptyobject{}}
$$
By T-Nil and subsumption we derive the same information in both propositions.
$$
\judgement{\isprop{\clj{Num}}{\x{}}}{\hastype{\clj{nil}}{\clj{nil}}}{\filterset{\isprop{\clj{Num}}{\x{}}}{\notprop{\clj{Num}}{\x{}}}}{\emptyobject{}}
$$
By T-Error we can assume anything about the return of an error.
$$
\judgement{\notprop{\clj{Num}}{\x{}}}{\hastype{\errorvalv{}}{\Bot}}{\filterset{\botprop{}}{\botprop{}}}{\emptyobject{}}
$$
Using the above as premises to T-If we learn {\orprop{\isprop{\clj{Num}}{\x{}}}{\botprop{}}}
in both propositions.
$$
\judgement{\isprop{\clj{(U nil Num)}}{\x{}}}{\hastype{\clj{(if (number? x) nil}\ {\errorvalv{}{\clj{)}}}}{\clj{B}}}
          {\filterset{\orprop{\isprop{\clj{Num}}{\x{}}}{\botprop{}}}{\orprop{\notprop{\clj{Num}}{\x{}}}{\botprop{}}}}{\emptyobject{}}
$$
By T-Local we know \clj{x} is a \clj{Num}.
$$
\judgement{\orprop{\isprop{\clj{Num}}{\x{}}}{\botprop{}}}{\hastype{\clj{x}}{\clj{Num}}}{\filterset{\topprop{}}{\topprop{}}}{\x{}}
$$
\clj{inc} requires a \clj{Num} argument which we just proved.
$$
\judgement{\orprop{\isprop{\clj{Num}}{\x{}}}{\botprop{}}}{\hastype{\clj{(inc x)}}{\clj{Num}}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}
$$

\subsection{Heterogenous maps}
\label{sec:hmapformal}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
    \pesyntax{}   &::=& \ldots \alt {\keype{\k{}}}
                  &\mbox{Path Elements}
  \end{altgrammar}
  $$
  \caption{HMap Terms and Types}
  \label{main:figure:hmapsyntax}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \caption{HMap Typing Rules}
  \label{main:figure:hmaptyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \caption{HMap Semantics}
  \label{main:figure:hmapsem}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \caption{HMap subtyping rules}
  \label{main:figure:hmapsubtype}
\end{figure}

We now present \HMapliteral{} types in detail.
Figure~\ref{main:figure:hmapsyntax} extends the syntax for terms and types.
$$
\clj{(HMap :mandatory p :absent-keys a :complete? b)}
$$
is written \HMapgeneric{\mandatory{}}{\absent{}},
where the metavariable \completenessmeta{} is {\complete{}} if \clj{b} is \clj{true} otherwise {\partial{}}. 
\mandatory{} specifies a set of known present keyword entries. \absent{} tracks known absent keys.
\HMapcwithabsent{\mandatory{}}{\absent{}} is abbreviated to \HMapc{\mandatory{}}. Keys cannot be both present and absent.

\clj{(get m :a)} is identical to \clj{(:a m)}.
To simplify presentation, we only provide syntax for the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}}.

\subsection{Paths}

We introduce our first path element {\keype{\k{}}}, the symbolic representation
of \clj{(get m k)} where \clj{m} represents the path after {\keype{\k{}}}---{\path{\keype{\makekw{b}}}{\path{\keype{\makekw{a}}}{\x{}}}}
  represents \clj{(get (get x :a) :b)}.

Figure~\ref{main:figure:hmaptyping} contains the typing rules. T-GetHMap models a lookup
that will certainly succeed, T-GetHMapAbsent a lookup that will certainly fail
and T-GetHMapPartialDefault a lookup with unknown results.
T-Assoc extends a HMap with a mandatory entry.
Figure~\ref{main:figure:hmapsem} contains the semantics for \getliteral{}
and \assocliteral{}.

S-HMap (figure~\ref{main:figure:hmapsubtype}) says that HMap subtypes must have all present entries to also be
subtypes and also cover the absent keys.
Complete maps are subtypes of partial maps by S-HMapP.

The \classconst{} function is a constant which returns
the argument's class or \nil{}.

$$
\begin{array}{lrlr}
  \pesyntax{}   &::=& \ldots \alt {\classpe{}}
                &\mbox{Path Elements}
\end{array}
$$

\begin{mathpar}
\constanttypefigure{}
\end{mathpar}

Our second path element \classpe{} is the symbolic representation
of a call to \classconst{}---{\path{\classpe{}}{\path{\keype{\makekw{a}}}{\x{}}}}
represents \clj{(class (get x :a))}.
Figure~\ref{main:figure:primitivesem} contains the semantics for \classconst{}.

\constantsemfigure{main}

\subsection{Proof system}

The essential piece of occurrence typing's logical system is L-Update,
where we combine propositions that have similar objects to learn new facts.

\begin{mathpar}
  {\LUpdate}
\end{mathpar}
For example, if \inpropenv {\propenv{}} {\isprop {\Union{\Keyword}{\Nil}} {\x{}}}
and
\inpropenv {\propenv{}} {\notprop {\Nil{}} {\x{}}},
then
$$
\inpropenv {\propenv{}} {\isprop {\update {\Union{\Keyword}{\Nil}} {\nottype{\Nil{}}} {\emptypath{}}} {\x{}}},
$$
so by the definition of \updateliteral{} (figure~\ref{main:figure:update})
\inpropenv {\propenv{}} {\isprop {\Keyword{}} {\x{}}} using \removeliteral{} (figure~\ref{main:figure:restrictremove}).

Now that we have our path elements \classpe{} and \keype{\k{}}
and the typing rules that introduce them, we give a detailed example how
each path element interacts with L-Update.

\smallsection{\classpe{}}
Consider the then branch of the following program:

\begin{minted}{clojure}
(fn [x :- (U nil Keyword)]
  (if (class x)
    ; here
    nil))
\end{minted}

Intuitively, since \clj{(class x)} is a true value it must be a class, therefore
\clj{x} is an object (not \clj{nil}).

From checking the body with T-Abs we know {\isprop {\Union{\Keyword}{\Nil}} {\x{}}}
The test has the object {\path{\classpe{}}{\x{}}} by T-App.
By T-If we can assume
{\notprop {\falsy{}} {\path{\classpe{}}{\x{}}}} in the then branch.
Since the object of the first proposition {\x{}} is a prefix of the second proposition's object
{\path{\classpe{}}{\x{}}}, 
by L-Update 
$$
\inpropenv {\propenv{}} {\isprop {\update {\Union{\Keyword}{\Nil}} {\nottype {\falsy{}}} {\classpe{}}} {\x{}}}.
$$
This hits the sixth \classpe{} case of \updateliteral{}, which returns
$$
{\update {\Union{\Keyword}{\Nil}} {\Object} {\emptypath{}}}
$$
deriving \inpropenv {\propenv{}} {\isprop {\Keyword} {\x{}}} 
by \restrictliteral{} (figure~\ref{main:figure:restrictremove}).

\smallsection{\keype{\k{}}}
Consider the then branch of

\begin{minted}{clojure}
(fn [x :- '{:kw (U nil Keyword)}]
  (if (get x :kw)
    ; here
    nil))
\end{minted}

Similar to before,
by T-Abs
{\isprop {\HMapp{\mandatorysetsingleton{\makekw{kw}}{\Union{\Nil}{\Keyword}}}{\emptyabsent}} {\x{}}},
the test's object is {\path{\keype{\makekw{kw}}}{\x{}}} by T-App
and by T-If we assume
{\notprop {\falsy{}} {\path{\keype{\makekw{kw}}}{\x{}}}} in the then branch.

L-Update combines these propositions
$$
\inpropenv {\propenv{}} {\isprop {\update {\HMapp{\mandatorysetsingleton{\makekw{kw}}{\Union{\Nil}{\Keyword}}}{\emptyabsent}} {\nottype {\falsy{}}} {\keype{\makekw{kw}}}} {\x{}}}.
$$
matching the \updateliteral{} case which pushes the \updateliteral{} inside the map
$$
{\HMapp{\mandatorysetsingleton{\makekw{kw}}{\update{\Union{\Nil}{\Keyword}}{\nottype {\falsy{}}}{\emptypath{}}}}{\emptyabsent}}
$$
concluding with
$$
\inpropenv {\propenv{}}
{\isprop {\HMapp{\mandatorysetsingleton{\makekw{kw}}{\Keyword}}{\emptyabsent}}   {\x{}}}.
$$

\begin{figure*}
  $$
\begin{array}{lllll}
\updatefigure
\end{array}
$$
\caption{Type Update}
\label{main:figure:update}
\end{figure*}

\subsection{Java Interoperability and Type Hints}

We model
Java interoperability in a restricted setting without class inheritance,
overloading or Java Generics. 

  $$
  \begin{altgrammar}
    \e{} &::=& \ldots   \localhintsyntax{} \alt \lethintsyntax{} &\mbox{Expressions}\\
            &\alt& \reflectiveexpsyntax{} 
  \end{altgrammar}
  $$

We extend the external language with Java field lookups and calls to
methods and constructors.
These come without typing or evaluation rules:
Typed Clojure requires the Clojure compiler to statically resolve all Java interactions
in typed code.
Type hinted expressions such as \localhintsyntax{} 
to help the compiler eliminate reflection.

\begin{figure*}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \mininonreflectiveexpsyntax{}
    &\mbox{Expressions}\\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \tatypesyntax{}\\
    \typehintenvsyntax{}\\
    \classtableallsyntax{}
  \end{altgrammar}
  $$
  \caption{Internal Language Reflection Resolution Extensions}
  \label{main:figure:nonreflectivesyntax}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    %\RAbs{}
%
%    \RNewElimRefl{}
%
%    \RMethodElimRefl{}
%
    \RFieldElimRefl{}
%
%    \RLet{}
%

    \RLetHint{}
  \end{mathpar}
\caption{Reflection Elimination %(select rules, figure~\ref{appendix:figure:rewrite} for full rules)
}
\label{main:figure:rewrite}
\end{figure}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%%    \TALocal{}
%%
%%    \TANil{}
%%
%%    \TANewStatic{}
%%
%%    \TALetHint{}
%
%%    \TALet{}
%  \end{mathpar}
%\caption{Type Hint Inference (select rules, figure~\ref{appendix:figure:hintinfer} for full rules)}
%\label{main:figure:hintinfer}
%\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \caption{Java Interoperability Semantics}
\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TNewStatic}

    {\TFieldStatic}
    {\TMethodStatic}
  \end{mathpar}
  \caption{Java Interoperability Typing Rules}
  \label{main:figure:javatyping}
\end{figure*}

$$
\rewrite {\taenv{}} {\e{}} {\ep{}}
$$
rewrites expression \e{} to a possibly-less reflective expression
\ep{} with respect to type hint environment
\taenv{} and Java class table \ct{} and
$$
\tajudgement {\taenv{}} {\hastype {\e{}} {\tatype{}}}
$$
infers the (possibly-unknown) type hint \tatype{} of expression \e{} in environment \taenv{}.

%$$
%\TALetHint{}
%$$

We now have two languages: an internal language that may contain non-reflective Java calls (figure 
  \ref{main:figure:nonreflectivesyntax}) 
  and an external language that resembles Clojure, where we must rely on type-hints to resolve
  reflective Java calls (figure~\ref{main:figure:reflectivesyntax}).

  $$
    \RFieldElimRefl{}
  $$

For example, R-FieldElimRefl, which rewrites a reflective field call to be non-reflective,
rewrites the target expression and uses the result to infer a class type hint as the field target.
\fieldtypeliteral{} uses the inferred type hint to lookup if the inferred class has the appropriate
field name and returns the actual target and result type hints which we store in the rewritten rule.

We then extract these type hints in T-FieldStatic for typing checking 
(figure~\ref{main:figure:javatyping}), which converts type hints
with \javatotcliteral{} to obtain a \emph{non-nilable} type to type check the target expression (which prevents
dereferencing nil) and \javatotcnilliteral{} to get a \emph{nilable} return type (because fields can be nil).

Method and constructor calls are similar, but T-MethodStatic and T-NewStatic disallow passing \nil{} as arguments, 
we assume methods can return \nil{} and we assume constructors cannot.

We rewrite to our internal language before type checking and remaining reflective calls are type errors.

\subsection{Multimethod dispatch mechanism: \isaliteral}

Before tackling multimethods we model their core dispatch mechanism
\isaliteral{}, a subclassing test for classes, otherwise an equality test.

\begin{minted}{clojure}
(isa? Keyword Object) ;=> true
(isa? Object Keyword) ;=> false
(isa? :a :a) ;=> true
(isa? :a :b) ;=> false
(isa? :a Keyword) ;=> false
(isa? (class :a) Keyword) ;=> true
\end{minted}

B-IsA with the metafunction \isaopsemliteral{} reflect these semantics.

$$
\begin{array}{ll}
  \vcenter{\hbox{\BIsA{}}}
  &
  \vcenter{\hbox{\isaopsemfigure{}}}
\end{array}
$$

For the typing rules, we add T-Kw and T-Class for type checking keyword and class literals
as singleton types, and T-IsA for \isaliteral{} expressions, which 
uses the \emph{object} of the left argument and the \emph{type} of the right argument
to infer the final proposition set.

$$
\begin{array}{ll}
\vcenter{\hbox{
    \TIsA{}}} &

  \vcenter{\hbox{$
    \begin{array}{l}
      {\TKw}\\\\
      {\TClass}
    \end{array}$}}
\end{array}
$$

The definition of \isacompareliteral{} (figure~\ref{main:figure:isaprops}) is deliberately conservative.
The first line considers the case where the object of the left argument
is a non-empty path ending in \classpe{} and the type of the right argument is a singleton class.
The simplest example

\begin{minted}{clojure}
  (isa? (class x) Keyword)
\end{minted}

has the proposition set \isacompare{\s{}}{\path{\classpe{}}{\x{}}}{\Value{\Keyword}}{\filterset{\isprop{\Keyword}{\x{}}}{\notprop{\Keyword}{\x{}}}},
that is if the expression is true then \clj{x} is a keyword, otherwise \clj{x} is not a keyword.

We can rewrite example~\ref{example:conditionalflow} as
\inputminted[firstline=5]{clojure}{code/demo/src/demo/isa_nil.clj}

because the then proposition is {\isprop{\Class}{\path{\classpe{}}{\x{}}}}, so
we know {\isprop{\Object}{\x{}}} by L-Update, and combined with the fact {\isprop{\Union{\Nil{}}{\Number}}{\x{}}}
we can infer {\isprop{\Number}{\x{}}} by L-Update.

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \isapropsfigure{}
  \end{mathpar}

  \center{Takes \emph{object} of the left parameter and \emph{type} of the right parameter.}
  \caption{Proposition Set for \isaliteral{} expressions}
  \label{main:figure:isaprops}
\end{figure}

The second \isacompareliteral{} line handles the equality mode of \isaliteral{}
with a non-class singleton type as the second argument.



%Substitution is used to ensure well formed propositions.

The final line gives up---we cannot distinguish between equality and subclassing mode.

\subsection{Multimethods}

\begin{figure*}
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt \multimethodexpsyntax{} 
                &\mbox{Expressions} \\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
\caption{Multimethod Syntax}
\label{main:figure:mmsyntax}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \TDefMulti{}

    \TDefMethod{}
  \end{mathpar}
  \caption{Multimethod typing rules}
  \label{main:figure:mmtyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \caption{Multimethod subtyping rules}
  \label{main:figure:mmsubtype}
\end{figure}


\begin{figure}
  \footnotesize
  \getmethodfigure{}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    \BBetaMulti{}
  \end{mathpar}
  \caption{Multimethod and method resolution semantics}
  \label{main:figure:mmsemantics}
\end{figure}

To ease presentation, we present \emph{immutable}
multimethods (figure~\ref{main:figure:mmsyntax}). \defmethodliteral{} returns a new extended multimethod
without changing the original multimethod. Example~\ref{example:rep} is now written
\begin{minted}{clojure}
(let [rep (defmulti [Any -> String] class)
      rep (defmethod rep Keyword [x] (str (name x)))
      rep (defmethod rep Number [x] (str (inc x)))]
  (rep :a)) ;=> "a"
\end{minted}

Multimethod semantics are in figure~\ref{main:figure:mmsemantics}.
B-DefMulti creates a multimethod with a dispatch function and an empty dispatch table.
B-DefMethod returns a new multimethod with an extended dispatch table.
B-BetaMulti invokes the dispatch function with the evaluated argument to get the dispatch value,
which \getmethodliteral{} uses to choose the method to invoke.

The typing rules (figure~\ref{main:figure:mmtyping}) use the multimethod type {\MultiFntype{\s{}}{\t{}}}, 
where \s{} is the interface type for beta reduction, and \t{} is the type for
the dispatch function. T-DefMulti uses the provided interface type and dispatch function
to infer the multimethod type. T-DefMethod uses \isacompareliteral{} to infer the proposition
that must be true if this method is being invoked. The example can be type checked without
changes since we infer \isprop{\Number}{\x{}} and \isprop{\Keyword}{\x{}} for the respective
method bodies. T-App handles beta reduction because multimethods are subtypes of functions
(figure~\ref{main:figure:mmsubtype}).



{\convertjavatypefigure{figure}{\footnotesize}}

\begin{figure}
  $$
\begin{array}{lllll}
  \restrictremovefigure{}
\end{array}
  $$
  \caption{Restrict and Remove}
  \label{main:figure:restrictremove}
\end{figure}
