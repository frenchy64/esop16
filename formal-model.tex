\section{A Formal Model of \lambdatc{}}

\label{sec:formal}

Now that we have demonstrated the core features Typed Clojure
provides, we link them together in a formal model called
\lambdatc{}.
Our presentation will start with a review of
occurrence typing~\cite{TF10}.
Then for the rest of the section we incrementally add each
novel feature of Typed Clojure to the formalism,
interleaving presentation of syntax, typing rules, operational semantics
and subtyping.

The first insight about occurrence typing is that
logical formulas
can be used to represent type information about our programs
by relating parts of the runtime environment to types
via propositional logic.
\emph{Type Propositions} \prop{} make assertions like ``variable \x{} is of type \NumberFull{}'' or
``variable \x{} is not \nil{}''---in our logical system we write these as
{\isprop{\NumberFull}{\x{}}}
and {\notprop{\Nil{}}{\x{}}}. 
The other propositions are standard logical connectives: implications, conjunctions,
disjunctions, and the trivial (\topprop{}) and impossible (\botprop{}) propositions
(\figref{main:figure:termsyntax}).


The particular part of the runtime environment we reference in a
type proposition is called the \emph{object}.
The typing judgement relates an object to every expression in the language.
An object is either \emph{empty}, written \emptyobject{}, 
which says 
this expression is not known to evaluate to a particular part
  of the current runtime environment, or a 
variable with some \emph{path}, written \path{\pathelem{}}{\x{}},
that exactly indicates how the value of this
expression can be derived from the current runtime environment.
Type propositions can only reference non-empty objects.

The second insight is that we can replace the traditional 
representation of a
type environment (eg., a map from variables to types)
with a set of propositions, written \propenv{}. 
Instead of mapping \x{} to
the type \NumberFull{}, we use the proposition {\isprop{\NumberFull}{\x{}}}.

Given a set of propositions, we can use logical reasoning to derive
new information about our programs
with the judgement \inpropenv{\propenv{}}{\prop{}}.
In addition to the standard rules for the logical connectives, the key
rule is L-Update, which combines multiple propositions about the same variable,
allowing us to refine its type.
$$
  {\LUpdate}
$$
For example, with L-Update we can use the knowledge of
\inpropenv{\propenv{}}{\isprop{\UnionNilNum}{\x{}}}
and 
\inpropenv{\propenv{}}{\notprop{\Nil{}}{\x{}}}
to derive \inpropenv{\propenv{}}{\isprop{\Number}{\x{}}}.
(The metavariable \propisnotmeta{} ranges over \t{} and \nottype{\t{}} (without variables).)
We cover L-Update in more detail in \secref{sec:formalpaths}.

Finally, this approach allows the type system to track
programming idioms from 
dynamic languages
using implicit type-based reasoning based on the result of
conditional tests.
For instance, \egref{example:conditionalflow}
only utilises \clj{x} once
the programmer is convinced it is safe to do so based whether
\clj{(number? x)}
is 
true or false. 
To express this in the type system, every expression 
is described by two propositions: a `then' proposition
for when it reduces to a true value, and an `else' proposition
when it reduces to a false value---for \clj{(number? x)}
the then proposition is {\isprop{\NumberFull}{\x{}}} and 
the else proposition is {\notprop{\NumberFull}{\x{}}}.
%\ref{main:figure:typingrules}

\begin{figure}
  \footnotesize
$$
\begin{array}{lrll}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}} &\mbox{Expressions} \\
                      &\alt& {\ifexp {\e{}} {\e{}} {\e{}}}
                      %\alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}\\
                      %\alt {\errorvalv{}}
  \v{} &::=&          \singletonmeta{}
                      \alt {\num{}}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
                \constantssyntax{}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                &\mbox{Types} \\
                      &\alt& {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}\\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \propenvsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{array}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure}


We formalise our type system following~\citet{TF10}
(with differences highlighted in $\trdiff{\text{blue}}$).
The typing judgement 
$$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}. We write 
{\judgementtwo{\propenv}{\hastype {\e{}} {\t{}}} if we are only interested in the type.

Syntax is given in \figref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals and let expressions.
All binding forms introduce fresh variables.
Values include booleans, \nil{}, class literals, keywords, 
numbers,
constants and closures. 
Value environments map local bindings to values.

Types include the top type, \emph{untagged} unions, functions, singleton types
and class instances. 
We abbreviate \Booleanlong{} as \Boolean{}, \Keywordlong{} as \Keyword{}
and \NumberFull{} and \Number{}.
The type \Value{\Keyword} is inhabited by the class literal \Keyword{} and \clj{:a} is of type \Keyword{}.
We abbreviate \EmptyUnion{} as \Bot{}, {\ValueNil} as \Nil{}, 
{\ValueTrue} as \True and {\ValueFalse} as {\False}.
Function types contain \emph{latent} (terminology from~\cite{Lucassen88polymorphiceffect}) propositions and object, which, along with the return type,
may refer to the function argument.
%Latent means they are relevant when the function is applied rather than evaluated.
They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

\figref{main:figure:typingrules} contains the core typing rules.
The key rule for reasoning about conditional control flow is
T-If. 

\begin{mathpar}
  {\TIf}
\end{mathpar}

The propositions of the test expression \e{1}, \thenprop{\prop{1}} and \elseprop{\prop{1}}, are 
used as assumptions in the then and else branch respectively.
If the result of the \ifliteral{} is a true value, then it either
came from \e{2}, in which case \thenprop{\prop{2}} is true, or from \e{3},
which implies \thenprop{\prop{3}} is true. 
The else proposition is \orprop{\elseprop{\prop{2}}}{\elseprop{\prop{3}}} 
similarly.
The T-Local rule connects the type system to the proof system over type propositions
via \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}
to derive a type for a variable.
Using this rule, the type system can then appeal to L-Update to refine the type
assigned to \x{}.

We are now equipped to type check
\egref{example:conditionalflow}, starting at body:
$$
\clj{... (if (number? x) (inc x) 0) ...}
$$

We know {\propenv{}} = {\isprop{\UnionNilNum{}}{\x{}}}.
The test expression uses T-App, 
$$
\judgement{\propenv{}}{\hastype{\appexp{\numberhuh{}}{\x{}}}{\Boolean}}{\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}
$$
since \numberhuh{} has type
{\ArrowOne{\x{}}{\Top}{\Boolean}
        {\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}}
      and \x{} has object \x{}.

Finally we check both branches using the extended proposition environment as specified by T-If.
Going down the then branch, our new assumption {\isprop{\Number}{\x{}}} is crucial to check
$$
\judgement{{\propenv{}},{\isprop{\Number}{\x{}}}}{\hastype{\x{}}{\Number{}}}{\filterset{\notprop{\falsy{}}{\x{}}}{\isprop{\falsy{}}{\x{}}}}{\emptyobject{}}
$$
because we can now satisify the premise of T-Local:
$$
\inpropenv{{\propenv{}},\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}.
$$
%\judgement{{\propenv{}},\isprop{\Number}{\x{}}}{\hastype{\appexp{\inc{}}{\x{}}}{\Number{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$
%$$
%\judgement{{\propenv{}},\notprop{\Number}{\x{}}}{\hastype{\zeroliteral{}}{\Number}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$

%\inc{} has type
%$$
%{\ArrowOne{\x{}}{\Number}{\Number}
%        {\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}}
%$$
%We can now check the conditional with T-If.
%$$
%\judgement{\isprop{\Number}{\x{}}}{\hastype{\ifexp{\appexp{\numberhuh{}}{\x{}}}{\appexp{\inc{}}{\x{}}}{\zeroliteral{}}}{\Number}}{\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}
%$$
%Finally the function can be checked with T-Abs
%$$
%\judgement{}{\hastype{\abs{\x{}}{\UnionNilNum}{\ ...}}
%                                             {\ArrowOne{\x{}}{\UnionNilNum}{\Number}
%        {\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}}}
%  {\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$

\paragraph{Operational semantics} We define the dynamic semantics for \lambdatc{}
in a big-step style using an environment, following~\citet{TF10}.
We include both errors and a \wrong{} value, which is provably ruled out by the
type system.
The main judgement is \opsem{\openv{}}{\e{}}{\definedreduction{}}
which states that \e{} evaluates to answer \definedreduction{} in environment
\openv{}. We chose to omit the core rules (see \figref{appendix:figure:opsem})
however a notable difference is \nil{} is a false value, which affects the
semantics of \ifliteral{}:

\begin{mathpar}
    \BIfTrue{}

    \BIfFalse{}
\end{mathpar}

Subtyping (\figref{main:figure:subtyping}) 
is a reflexive and transitive relation with top type \Top. 
Singleton types are instances of their respective classes---boolean singleton types
are of type \Boolean{}, class literals are instances of \Class{} and keywords are
instances of \Keyword{}.
Instances of classes \class{} are subtypes of \Object{}. Since function types 
are subtypes of \IFn{}, all types except for \Nil{} are subtypes of \Object{},
so \Top{} = {\Union{\Nil}{\Object}}.
Function subtyping is contravariant left of the arrow---latent propositions, object
and the result type are covariant.
Subtyping for untagged unions is standard.

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    %{\TDo}
    %{\TClass}
    %{\TIf}
    {\TAbs}
    {\TSubsume}
    \begin{array}{c}
      {\TConst}\\\\
      {\TKw}\\\\
      {\TClass}
    \end{array}
    \begin{array}{c}
      {\TTrue}\\\\
      {\TFalse}\\\\
      {\TNil}
    \end{array}

    {\TLet}
    {\TLocal}

    {\TApp}
    %{\TError}

  \end{mathpar}
  \caption{Typing rules}
  \label{main:figure:typingrules}
\end{figure*}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%    {\BLocal}
%
%    %{\BDo}
%
%    {\BLet}
%
%    \BVal{}
%
    %\BIfTrue{}

%    \BIfFalse{}
%
%    \BAbs{}
%
%    \BBetaClosure{}
%
%    \BDelta{}
%  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{main:figure:standardopsem}
%\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \standardsubtyping{}
  \end{mathpar}
  \caption{Subtyping rules}
  \label{main:figure:subtyping}
\end{figure*}

\subsection{Reasoning about Exceptional Control Flow}
\label{sec:doformal}

We extend our model with sequencing expressions and errors, where {\errorvalv{}}
models the result of calling Clojure's \clj{throw} special form
with some \clj{Throwable}.

\smallskip
$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\errorvalv{}} \alt {\doexp {\e{}} {\e{}}} &\mbox{Expressions} 
\end{altgrammar}
$

\smallskip
%
%B-Do simply evaluates its arguments sequentially and returns the right argument.
%Since errors are not values, we define error propagation semantics
%like BE-Do1 (figure~\ref{appendix:figure:errorstuck} for the full rules).
%
%\begin{mathpar}
%    {\BDo}
%
%\infer [BE-Error]
%{}
%{ \opsem {\openv{}} 
%         {\errorvalv{}}
%         {\errorvalv{}}}
%
%\infer [BE-Do1]
%{ \opsem {\openv{}} {\e{1}} {\errorvalv{}} }
%{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\errorvalv{}}}
%\end{mathpar}

Our main insight is as follows: 
if the first subexpression in a sequence reduces to a value, then it is either true or false.
If we learn some proposition in both cases then we can use that proposition as an assumption to check the second subexpression.
T-Do formalises this intuition.

\begin{mathpar}
    {\TDo}  
\end{mathpar}

The introduction of errors, 
which do not evaluate to either
a true or false value,
makes our insight interesting.

\begin{mathpar}
    {\TError}
\end{mathpar}

Recall \egref{example:doexception}.
\begin{minted}{clojure}
...  (do (if (number? x) nil (throw (Exception.)))
         (inc x)) ...
\end{minted}

As before, checking \appexp{\numberhuh{}}{\x{}} allows us to use the proposition \isprop{\Number}{\x{}}
when checking the then branch.

By T-Nil and subsumption we can propagate this  information to both propositions.
$$
\judgement{\isprop{\Number}{\x{}}}{\hastype{\nil{}}{\Nil{}}}{\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
$$
Furthermore, using T-Error
and subsumption we can conclude anything in the else branch.
$$
\judgement{\notprop{\Number}{\x{}}}{\hastype{\errorvalv{}}{\Bot}}{\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
$$
Using the above as premises to T-If we conclude that if the first
expression in the \doliteral{} evaluates successfully, \isprop{\Number}{\x{}} must be true.
$$
\judgement{\isprop{\UnionNilNum}{\x{}}}
          {\hastype{\ifexp{\appexp{\numberhuh{}}{\x{}}}{\nil{}}{\errorvalv{}}}{\Boolean}}
          {\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
$$
We can now use \isprop{\Number}{\x{}} in the environment to check the second subexpression
{\appexp{\inc{}}{\x{}}}, completing the example.

\subsection{Heterogeneous maps}
\label{sec:hmapformal}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
    \pesyntax{}   &::=& \ldots \alt {\keype{\k{}}}
                  &\mbox{Path Elements}
  \end{altgrammar}
  $$
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \caption{HMap Terms, Types, Semantics, Subtyping and Typing Rules}
  \label{main:figure:hmapsyntax}
\end{figure}


We now present \HMapliteral{} types in detail.
\figref{main:figure:hmapsyntax} extends the syntax for terms and types.

We write \HMapgeneric{\mandatory{}}{\absent{}}
where {\mandatory{}} is a map of \emph{present} entries (mapping keywords to types),
\absent{} is a set of keyword keys that are known to be \emph{absent}
and
\completenessmeta{} is {\complete{}} (``complete'') if the map is fully specified by \mandatory{},
and {\partial{}} (``partial'') if there are \emph{unknown} entries.
To ease presentation, 
if a HMap is declared as \complete{} then \absent{} implicitly contains all keywords not in the domain of \mandatory{}.
%\HMapcwithabsent{\mandatory{}}{\absent{}} is abbreviated to \HMapc{\mandatory{}}. 
Keys cannot be both present and absent.

The expressions \clj{(get m :a)} and \clj{(:a m)} are semantically identical, though
we only model the former to avoid the added complexity of keywords being functions.
To simplify presentation, we only provide syntax for the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}},
usually written {\curlymapvaloverrightnoarrow{\k{}}{\v{}}}.

Subtyping for HMaps (\figref{main:figure:hmapsyntax})
designate \MapLiteral{} as a common supertype for all HMaps.
S-HMap says that a HMap is a subtype of another HMap if they agree
on \completenessmeta{}, agree on mandatory entries with subtyping
and at least cover the absent keys of the supertype.
Complete maps are subtypes of partial maps
as long as they agree on the mandatory entries of the partial map via subtyping (S-HMapP).

\figref{main:figure:hmapsyntax} contains the typing rules. T-GetHMap models a lookup
that will certainly succeed, T-GetHMapAbsent a lookup that will certainly fail
and T-GetHMapPartialDefault a lookup with unknown results.
Lookups on unions of HMaps are only supported in T-GetHMap, 
in particular to support
looking up \clj{:op} on a map of type \clj{Expr} (\egref{example:decleaf})
where every element in the union
contains the key we are looking up.
The objects in the T-Get rules are more complicated than those in T-Local---the 
next section discusses this in detail.
Finally T-AssocHMap extends a HMap with a mandatory entry while preserving completeness
and absent entries, and enforcing ${\k{}} \not\in {\absent{}}$ to prevent badly
formed types.

\figref{main:figure:hmapsyntax} contains the semantics for \getliteral{}
and \assocliteral{}.
The B-Get rule evaluates first evaluates the map and the key, asserts
the key must be present in the map and returns the associated key. If
the entry is missing, B-GetMissing says we return \nil{}.

\subsection{Paths}
\label{sec:formalpaths}

Recall the first insight of occurrence typing---we can reason
about specific \emph{parts} of the runtime environment
using propositions.
The way to refer to \emph{parts} of the runtime environment with
occurrencing is via \emph{path elements}.
A \emph{path} consists of a series of path elements
applied right-to-left to a variable
written
\path{\pathelem{}}{\x{}}.
\citet{TF10} introduce the path elements \carpe{} and \cdrpe{}
to reason about selector operations on cons cells.
We instead want to reason about HMap lookups and calls to \classconst{}.

\paragraph{Key path element} We introduce our first path element
{\keype{\k{}}}, which represents the operation of looking up
a key \k{}.
We directly relate this to our typing rule T-GetHMap
(\figref{main:figure:hmapsyntax}) by
checking the then branch of the first conditional test is checked in 
an equivalent version of \egref{example:decleaf}.
\begin{minted}{clojure}
  (fn [m :- Expr]
    (if (= (get m :op) :if)
      {:op :if, ...}
      (if ...)))
\end{minted}

We do not specifically support \equivliteral{} in our calculus, 
but on keyword arguments it works identically to \clj{isa?} which we model
in \secref{sec:isaformal}.
Intuitively, if {\judgement{\propenv{}}{\hastype{\e{}}{\t{}}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}}
then \equivapp{\e{}}{\makekw{if}} has the proposition set 
$$
{\replacefor{\filterset{\isprop{\Value{\makekw{if}}}{\x{}}}{\notprop{\Value{\makekw{if}}}{\x{}}}}{\object{}}{\x{}}}
$$
where substitution reduces to \topprop{} if \object{} = \emptyobject{}.

We start with proposition environment \propenv{} = {\isprop{\Expr{}}{m}}.
Since {\Expr{}} is a union of HMaps, each with the entry \makekw{op}, we can use T-GetHMap.
$$
\judgement{\propenv{}}{\hastype{\getexp{m}{\makekw{op}}}{\Keyword}}{\filterset{\topprop{}}{\topprop{}}}{\path{\keype{\makekw{op}}}{m}}
$$
Using our intuitive definition of \equivliteral{} above, we know
$$
\judgement{\propenv{}}{\hastype{\equivapp{\getexp{m}{\makekw{op}}}{\makekw{if}}}{\Boolean}}{\filterset{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}{\notprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}}{\emptyobject{}}
$$
Going down the then branch gives us the extended environment
\propenvp{} = {\isprop{\Expr{}}{m}},{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}.
Using L-Update we can combine what we know about object $m$ and object
{\path{\keype{\makekw{op}}}{m}}
to derive
$$
\inpropenv{\propenvp{}}{\isprop{\HMapp{\mandatoryset{{\mandatoryentrykwnoarrow{op}{\makekw{if}}}, {\mandatoryentrykwnoarrow{test}{\Expr{}}},
                                       {\mandatoryentrykwnoarrow{then}{\Expr{}}},   {\mandatoryentrykwnoarrow{else}{\Expr{}}}}}
                                   {\emptyabsent{}}}{m}}
$$

\paragraph{Class path element} Our second path element \classpe{} is used in the latent
object of the constant \classconst{} function. Like Clojure's \clj{class}
function \classconst{} returns the argument's class or \nil{}
if passed \nil{}.
$$
\begin{array}{lrlr}
  \pesyntax{}   &::=& \ldots \alt {\classpe{}}
                &\mbox{Path Elements}
\end{array}
$$
\begin{mathpar}
\constanttypefigure{}
\end{mathpar}
The full semantics are given in \figref{main:figure:primitivesem}.
The definition of \updateliteral{} supports various idioms relating to \classpe{}
which we introduce in \secref{sec:isaformal}.

\subsection{Java Interoperability and Type Hints}

\begin{figure}[h]
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \mininonreflectiveexpsyntax{}
    \\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \tatypesyntax{}\\
    \typehintenvsyntax{}\\
    \classtableallsyntax{}
  \end{altgrammar}
  $$
 \classtablelookupsyntax{}
 \begin{mathpar}
  \begin{altgrammar}
    \convertjavatypenil{}
  \end{altgrammar}
  \begin{altgrammar}
    \convertjavatypenonnil{}
  \end{altgrammar}
\end{mathpar}
  \begin{mathpar}
    {\TNewStatic}

    {\TMethodStatic}

    %{\TInstance}
  \end{mathpar}
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \begin{mathpar}
    %\RAbs{}
%
%    \RNewElimRefl{}
%
%    \RMethodElimRefl{}
%
%    \RFieldElimRefl{}
%
%    \RLet{}
%

%    \RLetHint{}
  \end{mathpar}
  \caption{Java Interoperability Syntax, Semantics, Typing Rules and Rewrite Relation}
  \label{main:figure:javatyping}
\end{figure}

In \secref{sec:overviewjavainterop} we discussed the role of type hints
to help eliminate reflective calls.
In this section, we introduce our model of Java and provide user-facing
syntax corresponding to Clojure's Java interoperability forms and type hinted forms.
Then we model the Clojure compiler's compile-time reflection resolution
algorithm.
To achieve this, first we define notation for
\emph{non-reflective} Java forms that 
unambiguously call a field, method or constructor.
Then we define a rewrite relation that uses
type hints to resolve reflection explicitly.
Finally we give typing rules that model how
Typed Clojure interacts with non-reflective calls.

We present Java interoperability in a restricted setting without class inheritance,
overloading or Java Generics.

  $$
  \begin{altgrammar}
    \e{} &::=& \ldots   \localhintsyntax{} \alt \lethintsyntax{} &\mbox{Expressions}\\
            &\alt& \reflectiveexpsyntax{} 
  \end{altgrammar}
  $$

We extend the syntax with type hinted expressions, Java field lookups and calls to
methods and constructors. We model the syntax after the `dot' special
form to prevent ambiguity---\clj{(.fld e)} is now \fieldexp{\fld{}}{\e{}},
\clj{(.mth e es*)} is $\methodexp{\mth{}}{\e{}}{\overrightarrow{es}}$
and \clj{(.class es*)} is $\newexp{\class{}}{\overrightarrow{es}}$.
The Java expressions come without typing rules because Typed Clojure
only reasons about resolved reflection
(as demonstrated in \secref{sec:overviewjavainterop}).

Now we model the compiler's reflection-resolution algorithm.
\figref{main:figure:javatyping} gives the syntax for non-reflective Java calls.
The method ${\methodstaticexp {\classhint{1}}
                             {\overrightarrow {\classhint{i}}}
                             {\classhint{2}}
                             {\mth{}} {\e{}} {\overrightarrow{\e{i}}}}$
is a non-reflective call to the \mth{} method on class {\class{1}}, 
with Java signature 
${\classhint{2}}\ \mth{}\ (\overrightarrow {\classhint{i}});$.
The field {\fieldstaticexp {\classhint{1}} {\classhint{2}} {\fld{}} {\e{}}}
calls the field on class {\classhint{1}} with Java signature
${\classhint{2}}\ \fld{};$.
The constructor {\newstaticexp {\overrightarrow{\classhint{i}}} {\classhint{}} 
                               {\class{}} {\overrightarrow{\e{i}}}}
calls the constructor with Java signature
${\classhint{}}\ ({\overrightarrow{\classhint{i}}});$.

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%%    \TALocal{}
%%
%%    \TANil{}
%%
%%    \TANewStatic{}
%%
%%    \TALetHint{}
%
%%    \TALet{}
%  \end{mathpar}
%\caption{Type Hint Inference (select rules, figure~\ref{appendix:figure:hintinfer} for full rules)}
%\label{main:figure:hintinfer}
%\end{figure}


To obtain non-reflective calls we define our rewrite relation
\rewrite {\taenv{}} {\e{}} {\ep{}}
which rewrites \e{} to a possibly-less reflective expression
\ep{} with respect to type hint environment
\taenv{} and Java class table \ct{}.

For example,
R-FieldElimRefl emits a non-reflective field if it can
find a field matching the type hint inferred on \ep{}.
  $$
    \RFieldElimRefl{}
  $$

Type hint inference is modelled by
\tajudgement {\taenv{}} {\hastype {\e{}} {\tatype{}}}
which infers the (possibly-unknown) type hint \tatype{} of expression \e{} in environment \taenv{}.
%$$
%\TALetHint{}
%$$

For demonstration purposes let us rewrite
a simple field expression, with the assumptions that
that we have a class \Point{} with a field \getx{} of Java type \Number
and \intaenv {\taenv{}} {\x{}} {\Point{}}.
In rewriting
the expression \fieldexp{\getx}{\x{}},
{\Point{}} is inferred as the type hint of \x{}
and \Number{} is the field type
by \fieldtypeliteral{} (\figref{main:figure:javatyping}).
Now we just plug in the new information into our new expression
$$
\fieldstaticexp{\Point}{\Number}{\getx}{\x{}}.
$$

Now we present the typing rules for resolved Java interoperability.
T-FieldStatic checks a resolved field expression by ensuring the target has
the correct static type, then returns a nilable type corresponding the Java type.

\begin{mathpar}
    {\TFieldStatic}
\end{mathpar}

To continue our example, let us assume \propenv{} = {\isprop{\Point}{\x{}}}.
T-FieldStatic checks \x{} under the non-nilable type {\Point}
and returns the nilable type {\Union{\Nil}{\Number}}.

The other rules T-MethodStatic and T-NewStatic work similarly (\figref{main:figure:javatyping}), varying
in the choice of nilability in the conversion function---method returns
are nilable and constructor returns are non-nilable.

The operational semantics B-Field, B-New and B-Method (\figref{main:figure:javatyping}) simply evaluate their
arguments and call the relevant JVM operation---\secref{sec:metatheory}
states our exact assumptions about each.

\subsection{Multimethod dispatch mechanism: \isaliteral}

\label{sec:isaformal}

We now consider the core dispatch mechanism for multimethods. 
Recalling the examples in \secref{sec:multioverview},
\isaliteral{} is
a subclassing test for classes, otherwise an equality test---we do not model
the semantics for vectors.

The main interest for the T-IsA typing rule is the \isacompareliteral{} 
metafunction
(\figref{main:figure:mmsyntax}), used to calculate the propositions for
\isaliteral{} expressions.

\begin{mathpar}
  \TIsA{}
\end{mathpar}

To demonstrate,
\isaapp{\appexp{\classconst{}}{\x{}}}{\Keyword}
has the proposition set \isacompare{\s{}}{\path{\classpe{}}{\x{}}}{\Value{\Keyword}}{\filterset{\isprop{\Keyword}{\x{}}}{\notprop{\Keyword}{\x{}}}}.

B-IsA models the semantics. \isaopsemliteral{} explicitly handles classes in the second case.

$$
\begin{array}{ll}
  \vcenter{\hbox{\BIsA{}}}
  &
  \vcenter{\hbox{\isaopsemfigure{}}}
\end{array}
$$

%The definition of \isacompareliteral{} (figure~\ref{main:figure:mmsyntax}) is deliberately conservative.
%The first line considers the case where the object of the left argument
%is a non-empty path ending in \classpe{} and the type of the right argument is a singleton class.

\constantsemfigure{main}

\subsection{Multimethods}

\begin{figure}
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\createmultiexp {\t{}} {\e{}}} &\mbox{Expressions} \\
             &\alt& {\extendmultiexp {\e{}} {\e{}} {\e{}}}
             \alt {\isaapp {\e{}} {\e{}}}\\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \begin{mathpar}
    \isapropsfigure{}
  \end{mathpar}
  \begin{mathpar}
    \TDefMulti{}

    \TDefMethod{}
  \end{mathpar}
  \getmethodfigure{}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    \BBetaMulti{}
  \end{mathpar}
\caption{Multimethod Syntax, Subtyping, Typing Rules and Semantics}
\label{main:figure:mmsyntax}
\end{figure}

To ease presentation, we present \emph{immutable}
multimethods (\figref{main:figure:mmsyntax}). \defmethodliteral{} returns a new extended multimethod
without changing the original multimethod. \egref{example:rep} is now written
\begin{minted}{clojure}
(let [rep (defmulti [Any -> String] class)
      rep (defmethod rep Keyword [x] (str (name x)))
      rep (defmethod rep Number [x] (str (inc x)))]
  (rep :a)) ;=> "a"
\end{minted}

Multimethod semantics are in \figref{main:figure:mmsyntax}.
B-DefMulti creates a multimethod with a dispatch function and an empty dispatch table.
B-DefMethod returns a new multimethod with an extended dispatch table.
B-BetaMulti invokes the dispatch function with the evaluated argument to get the dispatch value,
which \getmethodliteral{} uses to choose the method to invoke.

The typing rules (\figref{main:figure:mmsyntax}) use the multimethod type {\MultiFntype{\s{}}{\t{}}}, 
where \s{} is the interface type for beta reduction, and \t{} is the type for
the dispatch function. T-DefMulti uses the provided interface type and dispatch function
to infer the multimethod type. T-DefMethod uses \isacompareliteral{} to infer the proposition
that must be true if this method is being invoked. The example can be type checked without
changes since we infer \isprop{\Number}{\x{}} and \isprop{\Keyword}{\x{}} for the respective
method bodies. T-App handles beta reduction because multimethods are subtypes of functions
(\figref{main:figure:mmsyntax}).



\begin{figure*}
  $$
\begin{array}{lllll}
\updatefigure
\end{array}
$$
\caption{Type Update}
\label{main:figure:update}
\end{figure*}

\begin{figure}
  $$
\begin{array}{lllll}
  \restrictremovefigure{}
\end{array}
  $$
  \caption{Restrict and Remove}
  \label{main:figure:restrictremove}
\end{figure}
