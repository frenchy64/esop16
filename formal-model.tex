\section{A Formal Model of \lambdatc{}}

\label{sec:formal}

Now that we have demonstrated the core features Typed Clojure
provides, we link them together in a formal model called
\lambdatc{}.
Our presentation will start with a review of
occurrence typing~\cite{TF10}.
Then for the rest of the section we incrementally add each
novel feature of Typed Clojure to the formalism,
interleaving presentation of syntax, typing rules, operational semantics
and subtyping.

The first insight about occurrence typing is that
logical formulas
can be used to represent type information about our programs
by relating parts of the runtime environment to types
via propositional logic.
\emph{Type Propositions} \prop{} make assertions like ``variable \x{} is of type \NumberFull{}'' or
``variable \x{} is not \nil{}''---in our logical system we write these as
{\isprop{\NumberFull}{\x{}}}
and {\notprop{\Nil{}}{\x{}}}. 
The other propositions are standard logical connectives: implications, conjunctions,
disjunctions, and the trivial (\topprop{}) and impossible (\botprop{}) propositions
(\figref{main:figure:termsyntax}).


The particular part of the runtime environment we reference in a
type proposition is called the \emph{object}.
The typing judgment relates an object to every expression in the language.
An object is either \emph{empty}, written \emptyobject{}, 
which says 
this expression is not known to evaluate to a particular part
  of the current runtime environment, or a 
variable with some \emph{path}, written \path{\pathelem{}}{\x{}},
that exactly indicates how the value of this
expression can be derived from the current runtime environment.
Type propositions can only reference non-empty objects.

The second insight is that we can replace the traditional 
representation of a
type environment (eg., a map from variables to types)
with a set of propositions, written \propenv{}. 
Instead of mapping \x{} to
the type \NumberFull{}, we use the proposition {\isprop{\NumberFull}{\x{}}}.

Given a set of propositions, we can use logical reasoning to derive
new information about our programs
with the judgment \inpropenv{\propenv{}}{\prop{}}.
In addition to the standard rules for the logical connectives, the key
rule is L-Update, which combines multiple propositions about the same variable,
allowing us to refine its type.
$$
  {\LUpdate}
$$
For example, with L-Update we can use the knowledge of
\inpropenv{\propenv{}}{\isprop{\UnionNilNum}{\x{}}}
and 
\inpropenv{\propenv{}}{\notprop{\Nil{}}{\x{}}}
to derive \inpropenv{\propenv{}}{\isprop{\Number}{\x{}}}.
(The metavariable \propisnotmeta{} ranges over \t{} and \nottype{\t{}} (without variables).)
We cover L-Update in more detail in \secref{sec:formalpaths}.

Finally, this approach allows the type system to track
programming idioms from 
dynamic languages
using implicit type-based reasoning based on the result of
conditional tests.
For instance, \egref{example:conditionalflow}
only utilizes \clj{x} once
the programmer is convinced it is safe to do so based whether
\clj{(number? x)}
is 
true or false. 
To express this in the type system, every expression 
is described by two propositions: a `then' proposition
for when it reduces to a true value, and an `else' proposition
when it reduces to a false value---for \clj{(number? x)}
the then proposition is {\isprop{\NumberFull}{\x{}}} and 
the else proposition is {\notprop{\NumberFull}{\x{}}}.
%\ref{main:figure:typingrules}

\begin{figure}
  \footnotesize
$$
\begin{array}{lrll}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}} &\mbox{Expressions} \\
                      &\alt& {\ifexp {\e{}} {\e{}} {\e{}}}
                      %\alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}\\
                      %\alt {\errorvalv{}}
  \v{} &::=&          \singletonmeta{}
                      \alt {\num{}}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
                \constantssyntax{}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                &\mbox{Types} \\
                      &\alt& {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}\\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \propenvsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{array}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure}


We formalize our type system following~\citet{TF10}
(with differences highlighted in $\trdiff{\text{blue}}$).
The typing judgment 
$$
{\judgement   {\propenv}
              {\e{}} {\t{}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}. We write 
{\judgementtwo{\propenv}{\e{}} {\t{}} if we are only interested in the type.

The syntax is given in \figref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals and let expressions.
All binding forms introduce fresh variables.
Values include booleans, \nil{}, class literals, keywords, 
numbers,
constants and closures. 
Value environments map local bindings to values.

Types include the top type, \emph{untagged} unions, functions, singleton types
and class instances. 
We abbreviate \Booleanlong{} as \Boolean{}, \Keywordlong{} as \Keyword{}
and \NumberFull{} and \Number{}.
The type \Value{\Keyword} is inhabited by the class literal \Keyword{} and \clj{:a} is of type \Keyword{}.
We abbreviate \EmptyUnion{} as \Bot{}, {\ValueNil} as \Nil{}, 
{\ValueTrue} as \True and {\ValueFalse} as {\False}.
Function types contain \emph{latent} (terminology from~\cite{Lucassen88polymorphiceffect}) propositions and object, which, along with the return type,
may refer to the function argument.
%Latent means they are relevant when the function is applied rather than evaluated.
They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

\figref{main:figure:typingrules} contains the core typing rules.
The key rule for reasoning about conditional control flow is
T-If. 

\begin{mathpar}
  {\TIf}
\end{mathpar}

The propositions of the test expression \e{1}, \thenprop{\prop{1}} and \elseprop{\prop{1}}, are 
used as assumptions in the then and else branch respectively.
If the result of the \ifliteral{} is a true value, then it either
came from \e{2}, in which case \thenprop{\prop{2}} is true, or from \e{3},
which implies \thenprop{\prop{3}} is true. 
The else proposition is \orprop{\elseprop{\prop{2}}}{\elseprop{\prop{3}}} 
similarly.
The T-Local rule connects the type system to the proof system over type propositions
via \inpropenv {\propenv{}} {\isprop {\t{}} {\x{}}}
to derive a type for a variable.
Using this rule, the type system can then appeal to L-Update to refine the type
assigned to \x{}.

We are now equipped to type check
\egref{example:conditionalflow}, starting at body:
$$
\clj{... (if (number? x) (inc x) 0) ...}
$$

We know {\propenv{}} = {\isprop{\UnionNilNum{}}{\x{}}}.
The test expression uses T-App, 
$$
\judgement{\propenv{}}{\appexp{\numberhuh{}}{\x{}}}{\Boolean}{\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}
$$
since \numberhuh{} has type
{\ArrowOne{\x{}}{\Top}{\Boolean}
        {\filterset{\isprop{\Number}{\x{}}}{\notprop{\Number}{\x{}}}}{\emptyobject{}}}
      and \x{} has object \x{}.

Finally we check both branches using the extended proposition environment as specified by T-If.
Going down the then branch, our new assumption {\isprop{\Number}{\x{}}} is crucial to check
$$
\judgement{{\propenv{}},{\isprop{\Number}{\x{}}}}{\x{}}{\Number{}}{\filterset{\notprop{\falsy{}}{\x{}}}{\isprop{\falsy{}}{\x{}}}}{\emptyobject{}}
$$
because we can now satisfy the premise of T-Local:
$$
\inpropenv{{\propenv{}},\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}.
$$
%\judgement{{\propenv{}},\isprop{\Number}{\x{}}}{\hastype{\appexp{\inc{}}{\x{}}}{\Number{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$
%$$
%\judgement{{\propenv{}},\notprop{\Number}{\x{}}}{\hastype{\zeroliteral{}}{\Number}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$

%\inc{} has type
%$$
%{\ArrowOne{\x{}}{\Number}{\Number}
%        {\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}}
%$$
%We can now check the conditional with T-If.
%$$
%\judgement{\isprop{\Number}{\x{}}}{\hastype{\ifexp{\appexp{\numberhuh{}}{\x{}}}{\appexp{\inc{}}{\x{}}}{\zeroliteral{}}}{\Number}}{\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}
%$$
%Finally the function can be checked with T-Abs
%$$
%\judgement{}{\hastype{\abs{\x{}}{\UnionNilNum}{\ ...}}
%                                             {\ArrowOne{\x{}}{\UnionNilNum}{\Number}
%        {\filterset{\orprop{\isprop{\Number}{\x{}}}{\topprop{}}}{\orprop{\notprop{\Number}{\x{}}}{\topprop{}}}}{\emptyobject{}}}}
%  {\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
%$$

\paragraph{Operational semantics} We define the dynamic semantics for \lambdatc{}
in a big-step style using an environment, following~\citet{TF10}.
We include both errors and a \wrong{} value, which is provably ruled out by the
type system.
The main judgment is \opsem{\openv{}}{\e{}}{\definedreduction{}}
which states that \e{} evaluates to answer \definedreduction{} in environment
\openv{}. We chose to omit the core rules (see \figref{appendix:figure:opsem})
however a notable difference is \nil{} is a false value, which affects the
semantics of \ifliteral{}:

\begin{mathpar}
    \BIfTrue{}

    \BIfFalse{}
\end{mathpar}

Subtyping (\figref{main:figure:subtyping}) 
is a reflexive and transitive relation with top type \Top. 
Singleton types are instances of their respective classes---boolean singleton types
are of type \Boolean{}, class literals are instances of \Class{} and keywords are
instances of \Keyword{}.
Instances of classes \class{} are subtypes of \Object{}. Since function types 
are subtypes of \IFn{}, all types except for \Nil{} are subtypes of \Object{},
so \Top{} = {\Union{\Nil}{\Object}}.
Function subtyping is contravariant left of the arrow---latent propositions, object
and the result type are covariant.
Subtyping for untagged unions is standard.

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    %{\TDo}
    %{\TClass}
    %{\TIf}
    {\TAbs}
    \begin{array}{c}
      {\TSubsume}\\\\
      {\TNum}
    \end{array}
    \begin{array}{c}
      {\TConst}\\\\
      {\TKw}\\\\
      {\TClass}
    \end{array}
    \begin{array}{c}
      {\TTrue}\\\\
      {\TFalse}\\\\
      {\TNil}
    \end{array}

    {\TLet}
    {\TLocal}

    {\TApp}
    %{\TError}

  \end{mathpar}
  \caption{Typing rules}
  \label{main:figure:typingrules}
\end{figure*}

%\begin{figure}
%  \footnotesize
%  \begin{mathpar}
%    {\BLocal}
%
%    %{\BDo}
%
%    {\BLet}
%
%    \BVal{}
%
    %\BIfTrue{}

%    \BIfFalse{}
%
%    \BAbs{}
%
%    \BBetaClosure{}
%
%    \BDelta{}
%  \end{mathpar}
%  \caption{Operational Semantics}
%  \label{main:figure:standardopsem}
%\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \SRefl{}

    \STop{}

\SUnionSuper{}

\SUnionSub{}

\SFunMono{}

\SObject{}

\SClass{}

\begin{array}{l}
\SSBool{}\\\\
\SSKw{}
\end{array}

\SFun{}


  \end{mathpar}
  \caption{Core Subtyping rules}
  \label{main:figure:subtyping}
\end{figure}

\subsection{Reasoning about Exceptional Control Flow}
\label{sec:doformal}

We extend our model with sequencing expressions and errors, where {\errorvalv{}}
models the result of calling Clojure's \clj{throw} special form
with some \clj{Throwable}.

\smallskip
$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\errorvalv{}} \alt {\doexp {\e{}} {\e{}}} &\mbox{Expressions} 
\end{altgrammar}
$

\smallskip
%
%B-Do simply evaluates its arguments sequentially and returns the right argument.
%Since errors are not values, we define error propagation semantics
%like BE-Do1 (figure~\ref{appendix:figure:errorstuck} for the full rules).
%
%\begin{mathpar}
%    {\BDo}
%
%\infer [BE-Error]
%{}
%{ \opsem {\openv{}} 
%         {\errorvalv{}}
%         {\errorvalv{}}}
%
%\infer [BE-Do1]
%{ \opsem {\openv{}} {\e{1}} {\errorvalv{}} }
%{ \opsem {\openv{}} {\doexp{\e{1}}{\e{}}} {\errorvalv{}}}
%\end{mathpar}

Our main insight is as follows: 
if the first subexpression in a sequence reduces to a value, then it is either true or false.
If we learn some proposition in both cases then we can use that proposition as an assumption to check the second subexpression.
T-Do formalizes this intuition.

\begin{mathpar}
    {\TDo}  
\end{mathpar}

The introduction of errors, 
which do not evaluate to either
a true or false value,
makes our insight interesting.

\begin{mathpar}
    {\TError}
\end{mathpar}

Recall \egref{example:doexception}.
\begin{minted}{clojure}
...
  (do (if (number? x) nil (throw (new Exception)))
      (inc x)) 
...
\end{minted}

As before, checking \appexp{\numberhuh{}}{\x{}} allows us to use the proposition \isprop{\Number}{\x{}}
when checking the then branch.

By T-Nil and subsumption we can propagate this  information to both propositions.
$$
\judgement{\isprop{\Number}{\x{}}}{\nil{}}{\Nil{}}{\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
$$
Furthermore, using T-Error
and subsumption we can conclude anything in the else branch.
$$
\judgement{\notprop{\Number}{\x{}}}{\errorvalv{}}{\Bot}{\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
$$
Using the above as premises to T-If we conclude that if the first
expression in the \doliteral{} evaluates successfully, \isprop{\Number}{\x{}} must be true.
$$
\judgement{\isprop{\UnionNilNum}{\x{}}}
          {\ifexp{\appexp{\numberhuh{}}{\x{}}}{\nil{}}{\errorvalv{}}}{\Boolean}
          {\filterset{\isprop{\Number}{\x{}}}{\isprop{\Number}{\x{}}}}{\emptyobject{}}
$$
We can now use \isprop{\Number}{\x{}} in the environment to check the second subexpression
{\appexp{\inc{}}{\x{}}}, completing the example.

\subsection{Precise Types for Heterogeneous maps}
\label{sec:hmapformal}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
    \pesyntax{}   &::=& \ldots \alt {\keype{\k{}}}
                  &\mbox{Path Elements}
  \end{altgrammar}
  $$
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \caption{HMap Syntax, Typing and Operational Semantics}
  \label{main:figure:hmapsyntax}
\end{figure}


\figref{main:figure:hmapsyntax} presents syntax, typing rules
and dynamic semantics in detail.
%
The type \HMapgeneric{\mandatory{}}{\absent{}}
includes {\mandatory{}}, a map of \emph{present} entries (mapping keywords to types),
\absent{}, a set of keyword keys that are known to be \emph{absent}
and
tag \completenessmeta{} which is either {\complete{}} (``complete'') if the map is fully specified by \mandatory{},
and {\partial{}} (``partial'') if there are \emph{unknown} entries.
To ease presentation, 
if an HMap has completeness tag \complete{} then \absent{} implicitly contains all keywords not in the domain of \mandatory{}.
%\HMapcwithabsent{\mandatory{}}{\absent{}} is abbreviated to \HMapc{\mandatory{}}. 
Keys cannot be both present and absent.

The expressions \clj{(get m :a)} and \clj{(:a m)} are semantically identical, though
we only model the former to avoid the added complexity of keywords being functions.
To simplify presentation, we only provide syntax for the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}},
usually written {\curlymapvaloverrightnoarrow{\k{}}{\v{}}}.

Subtyping for HMaps
designate \MapLiteral{} as a common supertype for all HMaps.
S-HMap says that an HMap is a subtype of another HMap if they agree
on \completenessmeta{}, agree on mandatory entries with subtyping
and at least cover the absent keys of the supertype.
Complete maps are subtypes of partial maps
as long as they agree on the mandatory entries of the partial map via subtyping (S-HMapP).

The typing rules for \getliteral{} consider three possible cases. T-GetHMap models a lookup
that will certainly succeed, T-GetHMapAbsent a lookup that will certainly fail
and T-GetHMapPartialDefault a lookup with unknown results.
Lookups on unions of HMaps are only supported in T-GetHMap, 
in particular to support
looking up \clj{:op} on a map of type \clj{Expr} (\egref{example:decleaf})
where every element in the union
contains the key we are looking up.
The objects in the T-Get rules are more complicated than those in T-Local---the 
next section discusses this in detail.
Finally T-AssocHMap extends an HMap with a mandatory entry while preserving completeness
and absent entries, and enforcing ${\k{}} \not\in {\absent{}}$ to prevent badly
formed types.

The semantics for \getliteral{} and \assocliteral{} are straightforward.
If the entry is missing, B-GetMissing produces \nil{}.

\subsection{Paths}
\label{sec:formalpaths}

Recall the first insight of occurrence typing---we can reason
about specific \emph{parts} of the runtime environment
using propositions.
We refer to parts of the runtime environment via 
a \emph{path} that consists of a series of
\emph{path elements} applied right-to-left to a variable
written \path{\pathelem{}}{\x{}}.
\citet{TF10} introduce the path elements \carpe{} and \cdrpe{}
to reason about selector operations on cons cells.
We instead want to reason about HMap lookups and calls to \classconst{}.

\paragraph{Key path element} We introduce our first path element
{\keype{\k{}}}, which represents the operation of looking up
a key \k{}.
We directly relate this to our typing rule T-GetHMap
(\figref{main:figure:hmapsyntax}) by
checking the then branch of the first conditional test is checked in 
an equivalent version of \egref{example:decleaf}.
\begin{minted}{clojure}
  (fn [m :- Expr]
    (if (= (get m :op) :if)
      {:op :if, ...}
      (if ...)))
\end{minted}

We do not specifically support \equivliteral{} in our calculus, 
but on keyword arguments it works identically to \clj{isa?} which we model
in \secref{sec:isaformal}.
Intuitively, if {\judgement{\propenv{}}{\e{}}{\t{}}{\filterset{\thenprop{\prop{}}}{\elseprop{\prop{}}}}{\object{}}}
then \equivapp{\e{}}{\makekw{if}} has the true and false propositions
$$
{\replacefor{\filterset{\isprop{\Value{\makekw{if}}}{\x{}}}{\notprop{\Value{\makekw{if}}}{\x{}}}}{\object{}}{\x{}}}
$$
where substitution reduces to \topprop{} if \object{} = \emptyobject{}.

We start with proposition environment \propenv{} = {\isprop{\Expr{}}{m}}.
Since {\Expr{}} is a union of HMaps, each with the entry \makekw{op}, we can use T-GetHMap.
$$
\judgement{\propenv{}}{\getexp{m}{\makekw{op}}}{\Keyword}{\filterset{\topprop{}}{\topprop{}}}{\path{\keype{\makekw{op}}}{m}}
$$
Using our intuitive definition of \equivliteral{} above, we know
$$
\judgement{\propenv{}}{\equivapp{\getexp{m}{\makekw{op}}}{\makekw{if}}}{\Boolean}{\filterset{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}{\notprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}}{\emptyobject{}}
$$
Going down the then branch gives us the extended environment
\propenvp{} = {\isprop{\Expr{}}{m}},{\isprop{\Value{\makekw{if}}}{\path{\keype{\makekw{op}}}{m}}}.
Using L-Update we can combine what we know about object $m$ and object
{\path{\keype{\makekw{op}}}{m}}
to derive
$$
\inpropenv{\propenvp{}}{\isprop{\HMapp{\mandatoryset{{\mandatoryentrykwnoarrow{op}{\makekw{if}}}, {\mandatoryentrykwnoarrow{test}{\Expr{}}},
                                       {\mandatoryentrykwnoarrow{then}{\Expr{}}},   {\mandatoryentrykwnoarrow{else}{\Expr{}}}}}
                                   {\emptyabsent{}}}{m}}
$$

The full definition of \updateliteral{} is given in \figref{main:figure:update}
which considers both keys a path elements as well as the \classconst{}
path element described below.
In the absence of paths, update simply performs set-theoretic operations
on types; see \figref{main:figure:restrictremove} for details.

\paragraph{Class path element} Our second path element \classpe{} is used in the latent
object of the constant \classconst{} function. Like Clojure's \clj{class}
function \classconst{} returns the argument's class or \nil{}
if passed \nil{}.
$$
\begin{array}{lrlr}
  \pesyntax{}   &::=& \ldots \alt {\classpe{}}
                &\mbox{Path Elements}
\end{array}
$$
\begin{mathpar}
\constanttypefigure{}
\end{mathpar}
The dynamic semantics are given in \figref{main:figure:primitivesem}.
The definition of \updateliteral{} supports various idioms relating to \classpe{}
which we introduce in \secref{sec:isaformal}.

\subsection{Java Interoperability}

\begin{figure}[t]
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \reflectiveexpsyntax{} &\mbox{Expressions}\\
    \\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \classtableallsyntax{}
  \end{altgrammar}
  $$
  \begin{mathpar}
    {\TNew}

    {\TMethod}

    %{\TInstance}
  \end{mathpar}
 \classtablelookupsyntax{}
 \begin{mathpar}
  \begin{altgrammar}
    \convertjavatypenil{}
  \end{altgrammar}
  \begin{altgrammar}
    \convertjavatypenonnil{}
  \end{altgrammar}
\end{mathpar}
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \caption{Java Interoperability Syntax, Typing and Operational Semantics}
  \label{main:figure:javatyping}
\end{figure}

We present Java interoperability in a restricted setting without class inheritance,
overloading or Java Generics.

We extend the syntax in \figref{main:figure:javatyping} with Java field lookups and calls to
methods and constructors. 
We model the syntax after the `dot' special
form to prevent ambiguity---\clj{(.fld e)} is now \fieldexp{\fld{}}{\e{}},
\clj{(.mth e es*)} is $\methodexp{\mth{}}{\e{}}{\overrightarrow{es}}$
and \clj{(new class es*)} is $\newexp{\class{}}{\overrightarrow{es}}$.

T-Field checks a resolved field expression by ensuring the target has
the correct static type, then returns a nilable type corresponding the Java type.

\begin{mathpar}
    {\TField}
\end{mathpar}

The rules T-Method and T-New work similarly (\figref{main:figure:javatyping}), varying
in the choice of nilability in the conversion function---methods
can return nil but constructors cannot. Void also does not have a constructor.

The evaluation rules B-Field, B-New and B-Method (\figref{main:figure:javatyping}) simply evaluate their
arguments and call the relevant JVM operation, which we do not model---\secref{sec:metatheory}
states our exact assumptions.

\subsection{Multimethod preliminaries: \isaliteral}

\label{sec:isaformal}

We now consider the \isaliteral{} operation, a core part of the dispatch mechanism for multimethods. 
Recalling the examples in \secref{sec:multioverview},
\isaliteral{} is
a subclassing test for classes, otherwise an equality test---we do not model
the semantics for vectors.

The key component of the T-IsA rule is the \isacompareliteral{} 
metafunction
(\figref{main:figure:mmsyntax}), used to calculate the propositions for
\isaliteral{} tests.
\begin{mathpar}
  \TIsA{}
\end{mathpar}

As an example,
\isaapp{\appexp{\classconst{}}{\x{}}}{\Keyword}
has the true and false propositions 
\isacompare{\s{}}{\path{\classpe{}}{\x{}}}{\Value{\Keyword}}{\filterset{\isprop{\Keyword}{\x{}}}{\notprop{\Keyword}{\x{}}}},
meaning that if this expression produces true, \x{} is a keyword, otherwise it is not.

The operational behavior of \isaliteral{} is given by B-IsA (\figref{main:figure:mmsyntax}). \isaopsemliteral{} explicitly handles classes in the second case.

%The definition of \isacompareliteral{} (figure~\ref{main:figure:mmsyntax}) is deliberately conservative.
%The first line considers the case where the object of the left argument
%is a non-empty path ending in \classpe{} and the type of the right argument is a singleton class.

\constantsemfigure{main}

\subsection{Multimethods}

\begin{figure}[t!]
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt {\createmultiexp {\t{}} {\e{}}} &\mbox{Expressions} \\
             &\alt& {\extendmultiexp {\e{}} {\e{}} {\e{}}}
             \alt {\isaapp {\e{}} {\e{}}}\\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
  \begin{mathpar}
    \TDefMulti{}

    \TDefMethod{}
  \end{mathpar}
  \begin{mathpar}
    \isapropsfigure{}
  \end{mathpar}
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    \BBetaMulti{}
  \end{mathpar}
  \getmethodfigure{}
$$
\begin{array}{ll}
  \vcenter{\hbox{\BIsA{}}}
  &
  \vcenter{\hbox{\isaopsemfigure{}}}
\end{array}
$$
\caption{Multimethod Syntax, Typing and Operational Semantics}
\label{main:figure:mmsyntax}
\end{figure}

To ease presentation, we present \emph{immutable}
multimethods, with syntax and semantics given in \figref{main:figure:mmsyntax}. 
\defmethodliteral{} returns a new extended multimethod
without changing the original multimethod. \egref{example:rep} is now written
\begin{minted}{clojure}
(let [path (defmulti [Any -> (U nil String)] class)]
  (let [path (defmethod path String [x] x)]
    (let [path (defmethod path File [^File x] 
                 (.getPath x))]
      (path (File. "dir/a"))))) ;=> "dir/a"
\end{minted}

The type {\MultiFntype {\s{}} {\sp{}}} characterizes multimethods with \emph{interface type}
{\s{}} and \emph{dispatch function type} {\sp{}}.
The expression {\createmultiexp {\s{}} {\e{}}} defines a multimethod
with interface type \s{} and dispatch function \e{}.
The expression {\extendmultiexp {\e{m}} {\e{v}}{\e{f}}}
extends multimethod \e{m} and to map
dispatch value {\e{v}} to {\e{f}} in an extended dispatch table.
The value {\multi {\v{}} {\disptable{}}} is the runtime value of a multimethod
with dispatch function {\v{}} and dispatch table {\disptable{}}.

The T-DefMulti rule ensures that the type of the dispatch function
has at least as permissive a parameter type
as the interface type.
%
For example, we can check the definition from our translation above of \egref{example:rep}
using T-DefMulti.
$$
\judgement{}%{\propenv{}}
{\createmultiexp 
      {\s{}}
      {\classconst{}}}
  {\MultiFntype {\s{}}{\sp{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
$$
where \s{}  = {\ArrowOne {\x{}} {\Top{}} {\t{}} {\filterset {\topprop{}} {\topprop{}}} {\emptyobject{}}}
  and \sp{} = {\ArrowOne {\x{}} {\Top{}} {\Union{\Nil}{\Class}} {\filterset {\topprop{}} {\topprop{}}} {\path{\classpe{}}{\x{}}}}.
  Since the parameter types agree, this is well-typed.

The T-DefMethod rule is carefully constructed to ensure we have a syntactic
lambda expression as the right-most subexpression.
This way we can manually check the body of the lambda under an extended
environment as sketched in \egref{example:incmap}.
We use \isacompareliteral{} to compute the proposition for this method,
since \isaliteral{} is used at runtime in multimethod dispatch.

We continue with the next line of the translation of \egref{example:rep}.
From the previous line we have \propenv{} = {\isprop{\MultiFntype {\s{}}{\sp{}}}{path}},
so
$$
\judgement{\propenv{}}
  {\extendmultiexp {prop} {\String}
                   {\abs {\x{}} {\Top{}} {\x{}}}}
  {\MultiFntype {\s{}}{\sp{}}}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
$$
We know \emph{prop} is a multimethod by \propenv{}, so now we check the body
of this method.
$$
\judgement{\propenv{},{\isprop{\Top}{\x{}}},{\isprop{\String}{\x{}}}}
  {\x{}}
  {\String}{\filterset{\topprop{}}{\botprop{}}}{\emptyobject{}}
$$
%This is checked by T-Local since {\inpropenv{\propenv{},{\isprop{\Top}{\x{}}},{\isprop{\String}{\x{}}}}{\isprop{\String}{\x{}}}}.
The new proposition {\isprop{\String}{\x{}}} is derived by 
$$
  \isacompare{\Top{}}{\path{\classpe{}}{\x{}}}{\Value{\File{}}}
             {\filterset{\isprop{\String}{\x{}}}
                        {\notprop{\String}{\x{}}}}.
$$
%
The body of the \clj{let} is checked by T-App because
{\MultiFntype {\s{}}{\sp{}}} is a subtype of its interface type {\s{}}.

Multimethod definition semantics are straightforward.
B-DefMulti creates a multimethod with the given dispatch function and an empty dispatch table.
B-DefMethod produces a new multimethod with an extended dispatch table.
B-BetaMulti invokes the dispatch function with the evaluated argument to obtain the dispatch value,
and uses \getmethodliteral{} (which models Clojure's \clj{get-method}) 
to extract the appropriate method. The call to \getmethodliteral{} only returns a value
if there is \emph{exactly one} method such that the corresponding dispatch value
is compatible, using \isaopsemliteral{}, with the result of the dispatch function.
Finally we return the result of applying the extracted method and the original argument.

\begin{figure*}
  $$
\begin{array}{lllll}
\updatefigure
\end{array}
$$
\caption{Type Update}
\label{main:figure:update}
\end{figure*}

\begin{figure}
  $$
\begin{array}{lllll}
  \restrictremovefigure{}
\end{array}
  $$
  \caption{Restrict and Remove}
  \label{main:figure:restrictremove}
\end{figure}
