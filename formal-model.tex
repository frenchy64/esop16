\section{A Formal Model of Typed Clojure}

We describe our type system in a similar way to Typed Racket (\citet{TF10}),
with differences highlighted in $\trdiff{\text{blue}}$.
The typing judgement 
$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}.

The propositions inform conditionals on what they can assume down the then and else
branches if the expression is used as a test.
The object is a possibly-empty symbolic representation of the expression.

Syntax is given in figure~\ref{figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals, do (sequencing) expressions and let expressions.
We model throwable errors without a catching mechanism. All binding forms introduce fresh
variables.

Values include booleans, \nil{}, class literals, keywords, constants and closures.
\false{} and \nil{} are the only logically false values.

Types include the top type, untagged unions, functions, singleton types
and class instances. We abbreviate \EmptyUnion{} as \Bot{}.
Function types contain \emph{latent} propositions and object, which, along with the return type,
may refer to the parameter identifier. They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

Propositions are identical to~\cite{TF10}; positive and negative type propositions, implications,
conjunctions, disjuctions, trivial and impossible propositions.
Type propositions contain a non-empty object which it claims type information about.

Proposition environments are sequences of propositions in conjunctive normal form.

Typing rules are in figure~\ref{figure:typingrules}.
T-Error neither returns logically true or false as it does not return normally.
T-Do uses the propositions learnt in the first expression to type check the second.
Other than compensating for the extra logically false value \nil{}, the rest are standard.

Figure~\ref{figure:standardopsem} contains the operational semantics, which are standard
except for \nil{} being false.

Subtyping (figure~\ref{figure:subtyping}) says singleton types are instances of their respective classes
and \Object is transitively a supertype to everything except {\Nil{}},
so \Top{} = {\Union{\Nil}{\Object}}.

\begin{figure*}
  \footnotesize
$$
\begin{altgrammar}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}}
                      \alt {\ifexp {\e{}} {\e{}} {\e{}}}
                      \alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}
                      \alt {\errorvalv{}}
                &\mbox{Expressions} \\
  \v{} &::=&          \true{} \alt \false{} \alt \trdiff{\nil{}}
                      \alt \trdiff{\class{}}
                      \alt \k{}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
  {\const{}}           &::=& \classconst \alt \throwconst

                &\mbox{Constants}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                      \alt {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}
                &\mbox{Types} \\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{altgrammar}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{figure:termsyntax}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TLocal}

    {\TTrue}

    {\TFalse}

    {\TNil}

    {\TDo}

    {\TClass}

    {\TIf}

    {\TLet}

    {\TKw}

    {\TApp}

    {\TAbs}

    {\TError}

    {\TSubsume}
  \end{mathpar}
  \caption{Typing rules}
  \label{figure:typingrules}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\BLocal}

    {\BDo}

    {\BLet}

    \BVal{}

    \BIfTrue{}

    \BIfFalse{}

    \BAbs{}

    \BBetaClosure{}

    \BDelta{}
  \end{mathpar}
  \caption{Operational Semantics}
  \label{figure:standardopsem}
\end{figure*}

\begin{figure*}
  \footnotesize
\begin{mathpar}
\standardsubtyping{}
\end{mathpar}
\caption{Subtyping rules}
\label{figure:subtyping}
\end{figure*}

\subsection{\isaliteral{}}

One interesting Clojure function we modeled is \isaliteral.
It takes two arguments, and returns \true{} if they are the same (equality mode)
or if they are both classes and the left is a subtype of the right (subclassing mode),
otherwise returns \false{}, as described in figure~\ref{figure:isasemantics}.

For example, {\isaapp{\Keyword}{\Object}} = \true{} but 
{\isaapp{\Object}{\Keyword}} = \false{}.
This is useful in combination with \classconst{}
with a fixed second argument, where {\isaapp{\appexp{\classconst}{\x{}}}{\Keyword}}
is a test for \x{} being a \Keyword{}, and also
as an equality test like
{\isaapp{\x{}}{\makekw{a}}}.

We encode this behaviour in figure~\ref{figure:isatyping}. 
\isacompareliteral{} is the interesting part,
which takes the object of the first argument 
and the type of the second argument, and returns the then and else propositions
of the expression.

The first case handles subclassing mode
in expressions like {\isaapp{\appexp{\classconst}{\x{}}}{\Object}},
where the first argument has an object ending in \classpe{} and the second argument has a singleton class type.
For example, in this case \isacomparetwo{\path{\classpe{}}{\x{}}}{\Value{\Object}}
gives a then proposition {\isprop{\Object} {\x{}}}
and an else proposition {\notprop{\Object}{\x{}}}.

The reason to peel off one path element is subtle. For example,
claiming {\isprop{\Value{\Object}} {\path{\classpe{}}{\x{}}}}
might seem suitable, however it implies \inopenv{\openv{}}{\path{\classpe{}}{\x{}}}{\Object}
which is wrong if \x{} = \makekw{a} where \inopenv{\openv{}}{\path{\classpe{}}{\x{}}}{\Keyword}.
(In formulating \isacompareliteral we found a three year old bug in how core.typed handles this case).

The second case handles the equality mode of \isaliteral{}
with a non-class singleton type as the second argument, to be certain we are not in subclassing mode.
Substitution is used to ensure well formed propositions.

The final case gives up; we cannot distinguish between equality and subclassing mode.

\isaliteral{} serves as the default dispatch mechanism for multimethods in Clojure.

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \isaopsemfigure{}

    \BIsA{}
  \end{mathpar}
  \caption{\isaliteral{} semantics}
  \label{figure:isasemantics}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \isapropsfigure{}

    \TIsA{}
  \end{mathpar}
  \caption{\isaliteral{} typing rules}
  \label{figure:isatyping}
\end{figure}


\subsection{Multimethods}

\begin{figure}
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt \multimethodexpsyntax{} 
                &\mbox{Expressions} \\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
\caption{Multimethod Syntax}
\end{figure}

\begin{figure}
  \footnotesize
\begin{mathpar}
  \TDefMulti{}

  \TDefMethod{}
\end{mathpar}
\caption{Multimethod typing rules}
\end{figure}

\begin{figure}
  \footnotesize
\begin{mathpar}
  \Multisubtyping{}
\end{mathpar}
\caption{Multimethod subtyping rules}
\end{figure}


\begin{figure}
  \footnotesize
  \getmethodfigure{}
\begin{mathpar}

       \BDefMulti{}

       \BDefMethod{}

  \BBetaMulti{}
\end{mathpar}
\caption{Multimethod semantics}
\end{figure}

Clojure provides multimethods which can dispatch on the result of an
arbitrary function, the \emph{dispatch function}. \emph{Methods} are
added to the multimethod
which are associated with a \emph{dispatch value}, which is compared to the
result of apply the dispatch function to the argument passed to the
multimethod. If this comparison unambiguously dispatches to one method,
that method is then called with the current arguments.

Occurrence typing, in particular when extended with paths,
for checking method definitions for arbitrary dispatch functions.

\begin{lstlisting}
(ns example.mm
  (:require 
    [clojure.core.typed :refer [ann]]))

(ann my-mm [Any -> Number])
(defmulti my-mm class)

(defmethod my-mm Float [f] (inc f))
\end{lstlisting}

\begin{lstlisting}
(ann clojure.core/class
  [Any -> (U nil Class)
   :object {:id 0, :path [Class]}])
\end{lstlisting}

\subsection{Heterogenous maps}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
  \end{altgrammar}
  $$
  \caption{HMap Terms and Types}
  \label{figure:hmapsyntax}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \caption{HMap Typing Rules}
  \label{figure:hmaptyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \caption{HMap subtyping rules}
\end{figure}

It is common in Clojure to use plain immutable hash maps to represent ad-hoc
objects with a known set of keyword entries. We use \HMapliteral{}
types to track known present, known absent and unknown keyword entries
(figure~\ref{figure:hmapsyntax}).

The metavariable \completenessmeta{} tracks whether a HMap is fully ({\complete{}}) or partially ({\partial{}})
specified. \mandatory{} specifies a set of known present keyword entries, \absent{} tracks known absent keyword
entries and we write \HMapcwithabsent{\mandatory{}}{\absent{}} as \HMapc{\mandatory{}} as a fully specified
HMap can assume all entries not in {\mandatory{}} as absent.

\getliteral{} and \assocliteral{} lookup and extend immutable maps respectively.
To simplify presentation, we only allow the empty map literal and
restrict lookup and extension to keyword keys.

\subsection{Java interoperability}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \reflectiveexpsyntax{}\\
            &\alt&  \localhintsyntax{} \alt \lethintsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\
  \end{altgrammar}
  $$
  \caption{Java Interoperability Terms and Types}
  \label{figure:reflectivesyntax}
\end{figure}

As Clojure supports Java interoperability, Typed Clojure has some
integration with Java's type system. Calls to Java methods from
Clojure can be type checked by Typed Clojure.

We do not support Java Generics for several reasons. Firstly
Clojure programmers already use \emph{type hints} to resolve
Java methods which does not interact with generics. Secondly
it would complicate the type system to need to consider advanced
Generics features like existentials and f-bounded polymorphism
which has complicated other type systems like Scala's.
Finally Java interop is rare in Clojure code, so the extra
work needed would not be worth the effort compared to the number
of new bugs core.typed catches.

Thanks to type erasure, only unparameterised classes, primitive
types and array classes live at runtime. This simplifies 
inference for \emph{tools.analyzer}, which uses type hints
to resolve ambiguities in Java interop like overloaded methods.

\subsection{Clojure type hints}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \mininonreflectiveexpsyntax{}\\
    &&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
    \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \

    \mbox{Expressions}
  \end{altgrammar}
  $$
  \caption{Non-Reflective Java Interoperability Syntax}
  \label{figure:nonreflectivesyntax}
\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \RAbs{}

    \RNewElimRefl{}

    \RMethodElimRefl{}

    \RFieldElimRefl{}

    \RLet{}

    \RLetHint{}
  \end{mathpar}
\caption{Reflection Elimination}
\label{figure:rewrite}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \TALocal{}

    \TANil{}

    \TANewStatic{}

    \TALetHint{}

    \TALet{}
  \end{mathpar}
\caption{Type Hint Inference}
\label{figure:hintinfer}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \BField{}

    \BMethod{}

    \BNew{}
  \end{mathpar}
  \caption{Java Interoperability Semantics}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\TNewStatic}

    {\TFieldStatic}

    {\TMethodStatic}
  \end{mathpar}
  \caption{Java Interoperability Typing Rules}
  \label{figure:javatyping}
\end{figure}

Clojure supports \emph{type hints}, an optional type system to improve performance
and disambiguate Java calls.
Programmers communicate to the Clojure compiler via type hints
to resolve Java methods and prevent boxing in loops. Tags are propagated bidirectionally
and the programmer is free to add them where they like.

core.typed uses tools.analyzer to obtain a rich abstract syntax tree that includes resolved
reflection, however to tell the full story we include a rewrite relation 
in figure~\ref{figure:rewrite} to eliminate reflection when sufficient type hints are provided.
Figure~\ref{figure:hintinfer} models how type hints are propagated.

We now have two languages: an internal language that may contain non-reflective Java calls (figure 
  \ref{figure:nonreflectivesyntax}) 
  and an external language that resembles Clojure, where we must rely on type-hints to resolve
  reflective Java calls (figure~\ref{figure:reflectivesyntax}).

For example, R-FieldElimRefl, which rewrites a reflective field call to be non-reflective,
rewrites the target expression and uses the result to infer a class type hint as the field target.
\fieldtypeliteral{} uses the inferred type hint to lookup if the inferred class has the appropriate
field name and returns the actual target and result type hints which we store in the rewritten rule.

We then extract these type hints in T-FieldStatic for typing checking 
(figure~\ref{figure:javatyping}), which converts type hints
with \javatotcliteral{} to obtain a \emph{non-nilable} type to type check the target expression (which prevents
dereferencing nil) and \javatotcnilliteral{} to get a \emph{nilable} return type (because fields can be nil).

Method and constructor calls are similar, but T-MethodStatic and T-NewStatic disallow passing \nil{} as arguments, 
we assume methods can return \nil{} and we assume constructors cannot.

We rewrite to our internal language before type checking and remaining reflective calls are type errors.

\subsection{Handling null}
\label{sec:null}

Probably the most common pain point in Java programming is dealing with \emph{null}.
It is crucial that Typed Clojure deals with \emph{null} intelligently so that
all potentially erroneous interactions with \emph{null} in typed code are caught at compile time.
We also want to represent \emph{null} in a way that is natural to Clojure programmers
and models their reasoning of Clojure code.

Firstly, we separate the concepts of \emph{null} and reference types at the type level.
This is unlike Java, where a reference type, like \emph{java.lang.Number}, includes \emph{null}.
We provide a singleton type \Nil{}, which contains just the value \lstinline|nil|,
Clojure's equivalent of \emph{null}. 

Armed with general unions and the type \lstinline|nil|, 
we make Typed Clojure's reference types \emph{non-nullable}.
A Java type like \emph{java.lang.Number} is written \lstinline|(U nil java.lang.Number)|
in Typed Clojure.

Typed Racket already provides what is needed to write such types; indeed this is a repurposing
of a common Typed Racket idiom of approximating an Option or Maybe type by
making a union that includes \emph{\#f}, Racket's only false value.
However, like handling covariant arrays, the subtlety lies in our interactions with foreign
Java code.

A set of conversion rules define how to convert a Java type signature into a null-safe
Clojure version. These rules are designed to be conservative and can be explicitly overridden
by programmers. Method parameters are non-nullable, while return types are nullable.
Field types are nullable. Constructor parameters are non-nullable, and return types
are also non-nullable: it is a Java invariant that all constructors return an instance
of the class they are constructing.

\input{constant}
\input{update}
\input{convert-types-figure}
