\section{A Formal Model of Typed Clojure}

We describe our type system in a similar way to Typed Racket (\citet{TF10}),
with differences highlighted in $\trdiff{\text{blue}}$.
The main judgement 

$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$

says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
then proposition {\thenprop {\prop{}}}, else proposition {\elseprop {\prop{}}}
and object \object{}.


\subsection{Multimethods}

Clojure provides multimethods which can dispatch on the result of an
arbitrary function, the \emph{dispatch function}. \emph{Methods} are
added to the multimethod
which are associated with a \emph{dispatch value}, which is compared to the
result of apply the dispatch function to the argument passed to the
multimethod. If this comparison unambiguously dispatches to one method,
that method is then called with the current arguments.

Occurrence typing, in particular when extended with paths,
for checking method definitions for arbitrary dispatch functions.

\begin{lstlisting}
(ns example.mm
  (:require 
    [clojure.core.typed :refer [ann]]))

(ann my-mm [Any -> Number])
(defmulti my-mm class)

(defmethod my-mm Float [f] (inc f))
\end{lstlisting}

\begin{lstlisting}
(ann clojure.core/class
  [Any -> (U nil Class)
   :object {:id 0, :path [Class]}])
\end{lstlisting}

\begin{verbatim}
TODO
- example of normal MM usage
- explain descrepency btwn TC syntax and formal
  TR calculs syntax. eg. :object/:filter 
    vs over arrow
\end{verbatim}

\subsection{Extending occurrence typing}

\subsection{Java interoperability}

As Clojure supports Java interoperability, Typed Clojure has some
integration with Java's type system. Calls to Java methods from
Clojure can be type checked by Typed Clojure.

We do not support Java Generics for several reasons. Firstly
Clojure programmers already use \emph{type hints} to resolve
Java methods which does not interact with generics. Secondly
it would complicate the type system to need to consider advanced
Generics features like existentials and f-bounded polymorphism
which has complicated other type systems like Scala's.
Finally Java interop is rare in Clojure code, so the extra
work needed would not be worth the effort compared to the number
of new bugs core.typed catches.

Thanks to type erasure, only unparameterised classes, primitive
types and array classes live at runtime. This simplifies 
inference for \emph{tools.analyzer}, which uses type hints
to resolve ambiguities in Java interop like overloaded methods.

\subsection{Clojure type hints}

Clojure comes with a small type system that helps improve
performance in Clojure code: type hints. They are used to help
the compiler resolve Java methods and prevent unboxing in
certain situations. Tags are propagated bidirectionally
and the programmer is free to add them where they like.

\subsection{Handling null}
\label{sec:null}

Probably the most common pain point in Java programming is dealing with \emph{null}.
It is crucial that Typed Clojure deals with \emph{null} intelligently so that
all potentially erroneous interactions with \emph{null} in typed code are caught at compile time.
We also want to represent \emph{null} in a way that is natural to Clojure programmers
and models their reasoning of Clojure code.

Firstly, we separate the concepts of \emph{null} and reference types at the type level.
This is unlike Java, where a reference type, like \emph{java.lang.Number}, includes \emph{null}.
We provide a singleton type \Nil{}, which contains just the value \lstinline|nil|,
Clojure's equivalent of \emph{null}. 

Armed with general unions and the type \lstinline|nil|, 
we make Typed Clojure's reference types \emph{non-nullable}.
A Java type like \emph{java.lang.Number} is written \lstinline|(U nil java.lang.Number)|
in Typed Clojure.

Typed Racket already provides what is needed to write such types; indeed this is a repurposing
of a common Typed Racket idiom of approximating an Option or Maybe type by
making a union that includes \emph{\#f}, Racket's only false value.
However, like handling covariant arrays, the subtlety lies in our interactions with foreign
Java code.

A set of conversion rules define how to convert a Java type signature into a null-safe
Clojure version. These rules are designed to be conservative and can be explicitly overridden
by programmers. Method parameters are non-nullable, while return types are nullable.
Field types are nullable. Constructor parameters are non-nullable, and return types
are also non-nullable: it is a Java invariant that all constructors return an instance
of the class they are constructing.

\begin{verbatim}
TODO 
- write conversion rules for 
  Java type -> Clojure type
\end{verbatim}
