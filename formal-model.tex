\section{A Formal Model of Typed Clojure}

We describe our type system in a similar way to Typed Racket (\citet{TF10}),
with differences highlighted in $\trdiff{\text{blue}}$.
The typing judgement 
$
{\judgement   {\propenv}
              {\hastype {\e{}} {\t{}}}
  {\filterset {\thenprop {\prop{}}}
              {\elseprop {\prop{}}}}
  {\object{}}}
$
says expression \e{} is of type \t{} in the 
proposition environment $\propenv{}$, with 
`then' proposition {\thenprop {\prop{}}}, `else' proposition {\elseprop {\prop{}}}
and object \object{}.

The propositions inform conditionals on what they can assume down the then and else
branches if the expression is used as a test.
The object is a possibly-empty symbolic representation of the expression.

Syntax is given in figure~\ref{main:figure:termsyntax}. Expressions include variables, values,
application, abstractions, conditionals, do (sequencing) expressions and let expressions.
We model throwable errors without a catching mechanism. All binding forms introduce fresh
variables.

Values include booleans, \nil{}, class literals, keywords, constants and closures.
\false{} and \nil{} are the only logically false values.

Types include the top type, untagged unions, functions, singleton types
and class instances. We abbreviate \EmptyUnion{} as \Bot{}, {\ValueNil} as \Nil{} and similarly
for \True and \False.
Function types contain \emph{latent} propositions and object, which, along with the return type,
may refer to the parameter identifier. They are latent because they are instantiated with the
actual object of the argument in applications before they are used in the proposition environment.

Propositions are identical to~\cite{TF10}; positive and negative type propositions, implications,
conjunctions, disjuctions, trivial and impossible propositions.
Type propositions contain a non-empty object which it claims type information about.

Proposition environments are sequences of propositions in conjunctive normal form.

Typing rules are in figure~\ref{main:figure:typingrules}.
T-Error neither returns logically true or false as it does not return normally.
T-Do uses the propositions learnt in the first expression to type check the second.
Other than compensating for the extra logically false value \nil{}, the rest are standard.

Figure~\ref{main:figure:standardopsem} contains the operational semantics, which are standard
except for \nil{} being false.

Subtyping (figure~\ref{main:figure:subtyping}) says singleton types are instances of their respective classes
and \Object is transitively a supertype to everything except {\Nil{}},
so \Top{} = {\Union{\Nil}{\Object}}.

\begin{figure*}
  \footnotesize
$$
\begin{altgrammar}
  \expd{}, \e{} &::=& \x{}
                      \alt \v{} 
                      \alt {\comb {\e{}} {\e{}}} 
                      \alt {\abs {\x{}} {\t{}} {\e{}}}
                      \alt {\ifexp {\e{}} {\e{}} {\e{}}}
                      \alt {\trdiff{\doexp {\e{}} {\e{}}}}
                      \alt {\letexp {\x{}} {\e{}} {\e{}}}
                      %\alt {\errorvalv{}}
                &\mbox{Expressions} \\
  \v{} &::=&          \singletonmeta{}
                      \alt {\const{}}
                      \alt {\closure {\openv{}} {\abs {\x{}} {\t{}} {\e{}}}}
                &\mbox{Values} \\
  {\const{}}           &::=& \classconst \alt \throwconst

                &\mbox{Constants}\\
  \s{}, \t{}    &::=& \Top 
                      \alt {\Unionsplice {\overrightarrow{\t{}}}}
                      \alt
                      {\ArrowOne {\x{}} {\t{}}
                                   {\t{}}
                                   {\filterset {\prop{}} {\prop{}}}
                                   {\object{}}}
                      \alt {\Value \singletonmeta{}} 
                      \alt \trdiff{\class{}}
                &\mbox{Types} \\
  \singletonallsyntax{}
                \\ \\
  \occurrencetypingsyntax{}\\
  \openvsyntax{}
  %\\
  %\classliteralallsyntax{}
\end{altgrammar}
$$
\caption{Syntax of Terms, Types, Propositions and Objects}
\label{main:figure:termsyntax}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TLocal}

    {\TTrue}

    {\TFalse}

    {\TNil}

    {\TDo}
    %{\TClass}
    {\TIf}
    {\TLet}

    %{\TKw}

    {\TApp}

    {\TAbs}

    %{\TError}

    {\TSubsume}
  \end{mathpar}
  \caption{Typing rules}
  \label{main:figure:typingrules}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\BLocal}

    {\BDo}

    {\BLet}

    \BVal{}

    \BIfTrue{}

    \BIfFalse{}

    \BAbs{}

    \BBetaClosure{}

    \BDelta{}
  \end{mathpar}
  \caption{Operational Semantics}
  \label{main:figure:standardopsem}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \standardsubtyping{}
  \end{mathpar}
  \caption{Subtyping rules}
  \label{main:figure:subtyping}
\end{figure*}

\subsection{\doliteral{}}

Assertions in Clojure often expand to simple exceptional control flow reasoning.

\begin{minted}{clojure}
(fn [x :- (U nil Number)] {:pre (number? x)} (inc x))
\end{minted}

roughly expands to

\begin{minted}{clojure}
(fn [x :- (U nil Number)]
  (do (if x (throw (new Exception)) nil)
      (inc x)))
\end{minted}

With an elegant extension in T-Do (figure~\ref{main:figure:typingrules}) we can follow this reasoning
to infer \mintinline{clojure}{(inc x)} is safe. The main insight is we can assume the
disjunction of the propositions of the first \doliteral{} argument while checking the second.

To sketch how this example is checked, first T-Abs type checks the body under the 
environment \propenv{} = {\isprop{\Union{\Nil}{\Number{}}}{\x{}}}.
T-Do then extracts the propositions of its first argument:
T-If tells us \thenprop{\prop{1}} = {\orprop{\botprop{}}{\botprop{}}} and 
\elseprop{\prop{1}} = {\orprop{\botprop{}}{\notprop{\falsy{}}{\x{}}}}
using T-Error, T-Nil and T-Subsume.
Now {\orprop {\thenprop {\prop{1}}} {\elseprop {\prop{1}}}} = {\notprop{\falsy}{\x{}}}
and we check \mintinline{clojure}{(inc x)} in the extended environment 
\ma{{\propenv{},{\notprop{\falsy}{\x{}}}}}
and by L-Update we know {\isprop{\Number}{\x{}}}
so T-Local says \mintinline{clojure}{x} is a \Number.

\subsection{\isaliteral{}}

One interesting Clojure function we modeled is \isaliteral.
It takes two arguments, and returns \true{} if they are the same (equality mode)
or if they are both classes and the left is a subtype of the right (subclassing mode),
otherwise returns \false{}, as described in figure~\ref{main:figure:isasemantics}.

For example, {\isaapp{\Keyword}{\Object}} = \true{} but 
{\isaapp{\Object}{\Keyword}} = \false{}.
This is useful in combination with \classconst{}
with a fixed second argument, where {\isaapp{\appexp{\classconst}{\x{}}}{\Keyword}}
is a test for \x{} being a \Keyword{}, and also
as an equality test like
{\isaapp{\x{}}{\makekw{a}}}.

We encode this behaviour in figure~\ref{main:figure:isatyping}. 
\isacompareliteral{} is the interesting part,
which takes the object of the first argument 
and the type of the second argument, and returns the then and else propositions
of the expression.

The first case handles subclassing mode
in expressions like {\isaapp{\appexp{\classconst}{\x{}}}{\Object}},
where the first argument has an object ending in \classpe{} and the second argument has a singleton class type.
For example, in this case \isacomparetwo{\path{\classpe{}}{\x{}}}{\Value{\Object}}
gives a then proposition {\isprop{\Object} {\x{}}}
and an else proposition {\notprop{\Object}{\x{}}}.

The reason to peel off one path element is subtle. For example,
claiming {\isprop{\Value{\Object}} {\path{\classpe{}}{\x{}}}}
might seem suitable, however it implies \inopenv{\openv{}}{\path{\classpe{}}{\x{}}}{\Object}
which is wrong if \x{} = \makekw{a} where \inopenv{\openv{}}{\path{\classpe{}}{\x{}}}{\Keyword}.
(Formulating \isacompareliteral revealed a three year old bug in the implementation).

The second case handles the equality mode of \isaliteral{}
with a non-class singleton type as the second argument, to be certain we are not in subclassing mode.
Substitution is used to ensure well formed propositions.

The final case gives up; we cannot distinguish between equality and subclassing mode.

\isaliteral{} serves as the default dispatch mechanism for multimethods in Clojure.

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \isaopsemfigure{}

    \BIsA{}
  \end{mathpar}
  \caption{\isaliteral{} semantics}
  \label{main:figure:isasemantics}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \isapropsfigure{}

    \TIsA{}
  \end{mathpar}
  \caption{\isaliteral{} typing rules}
  \label{main:figure:isatyping}
\end{figure}


\subsection{Multimethods}

\begin{figure*}
  \footnotesize
$$
\begin{altgrammar}
  \e{} &::=& \ldots \alt \multimethodexpsyntax{} 
                &\mbox{Expressions} \\
  \v{} &::=& \ldots \alt {\multi {\v{}} {\disptable{}}}
                &\mbox{Values} \\
  \s{}, \t{} &::=& \ldots \alt {\MultiFntype{\t{}}{\t{}}}
                &\mbox{Types} \\

 \disptablesyntax{} \\
\end{altgrammar}
$$
\caption{Multimethod Syntax}
\label{main:figure:mmsyntax}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \TDefMulti{}

    \TDefMethod{}
  \end{mathpar}
  \caption{Multimethod typing rules}
  \label{main:figure:mmtyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \Multisubtyping{}
  \end{mathpar}
  \caption{Multimethod subtyping rules}
  \label{main:figure:mmsubtype}
\end{figure}


\begin{figure}
  \footnotesize
  \getmethodfigure{}
  \begin{mathpar}
    \BDefMethod{}
    \BDefMulti{}
    \BBetaMulti{}
  \end{mathpar}
  \caption{Multimethod and method resolution semantics}
  \label{main:figure:mmsemantics}
\end{figure}

A multimethod in Clojure is a function with a dispatch mechanism to
of internal methods. Multimethods are created with {\mintinline{clojure}{defmulti}}
and methods are installed via {\mintinline{clojure}{defmethod}}.
They are called like regular functions.

\begin{minted}{clojure}
(ann foo [Any -> String])
(defmulti foo class)
(defmethod foo Number [x] (str (inc x)))
(defmethod foo Keyword [x] (str (name x)))
(foo :a) ;=> "a"
(foo 1)  ;=> "2"
\end{minted}

To ease presentation, we present \emph{immutable}
multimethods (figure~\ref{main:figure:mmsyntax}). \defmethodliteral{} returns a new extended multimethod
without changing the original multimethod. The above is now written

%$\letexp{foo}{\defmultiexp {\ArrowOne{\x{}}{\Top}{\mintinline{clojure}{String}}{\filterset{\topprop{}}{\topprop{}}}{\emptyobject{}}}
%                       {\classconst{}}}
%                     {\\ bar}$

\begin{minted}{clojure}
(let [foo (defmulti [Any -> String] class)
      foo (defmethod foo Number [x] (str (inc x)))
      foo (defmethod foo Keyword [x] (str (name x)))]
  (foo :a)) ;=> "a"
\end{minted}

Multimethod semantics are in figure~\ref{main:figure:mmsemantics}.
B-DefMulti creates a multimethod with a dispatch function and an empty dispatch table.
B-DefMethod returns a new multimethod with an extended dispatch table.
B-BetaMulti invokes the dispatch function with the evaluated argument to get the dispatch value,
which \getmethodliteral{} uses to choose the method to invoke.

The typing rules (figure~\ref{main:figure:mmtyping}) use the multimethod type {\MultiFntype{\s{}}{\t{}}}, 
where \s{} is the interface type for beta reduction, and \t{} is the type for
the dispatch function. T-DefMulti uses the provided interface type and dispatch function
to infer the multimethod type. T-DefMethod uses \isacompareliteral{} to infer the proposition
that must be true if this method is being invoked. The example can be type checked without
changes since we infer \isprop{\Number}{\x{}} and \isprop{\Keyword}{\x{}} for the respective
method bodies. T-App handles beta reduction because multimethods are subtypes of functions
(figure~\ref{main:figure:mmsubtype}).

\subsection{Heterogenous maps}

\begin{figure}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \hmapexpressionsyntax{}
    &\mbox{Expressions} \\
    \v{} &::=& \ldots \alt {\emptymap{}}
    &\mbox{Values} \\
    \t{} &::=& \ldots \alt {\HMapgeneric {\mandatory{}} {\absent{}}}
    &\mbox{Types} \\
    \auxhmapsyntax{}\\
  \end{altgrammar}
  $$
  \caption{HMap Terms and Types}
  \label{main:figure:hmapsyntax}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\BAssoc}
    {\BGet}
    {\BGetMissing}
  \end{mathpar}
  \caption{HMap Semantics}
  \label{main:figure:hmapsem}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    {\TGetHMap}

    {\TGetAbsent}

    {\TGetHMapPartialDefault}

    {\TAssoc}
  \end{mathpar}
  \caption{HMap Typing Rules}
  \label{main:figure:hmaptyping}
\end{figure}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \HMapsubtyping{}
  \end{mathpar}
  \caption{HMap subtyping rules}
  \label{main:figure:hmapsubtype}
\end{figure}

It is common in Clojure to use plain immutable hash maps to represent ad-hoc
objects with a known set of keyword entries. We use \HMapliteral{}
types (figure~\ref{main:figure:hmapsyntax}) to track known present, known absent and unknown keyword entries.

The metavariable \completenessmeta{} tracks whether a HMap is fully ({\complete{}}) or partially ({\partial{}})
specified. \mandatory{} specifies a set of known present keyword entries, \absent{} tracks known absent keyword
entries and we write \HMapcwithabsent{\mandatory{}}{\absent{}} as \HMapc{\mandatory{}} as a fully specified
HMap can assume all entries not in {\mandatory{}} as absent. We disallow keys to be both present and absent.

\getliteral{} and \assocliteral{} lookup and extend immutable maps respectively.
To simplify presentation, we only allow the empty map literal and
restrict lookup and extension to keyword keys. The metavariable \mapval{}
ranges over the runtime value of maps {\curlymapvaloverright{\k{}}{\v{}}}.

Figure~\ref{main:figure:hmapsem} shows the semantics for HMaps, where B-Get returns the associated
entry if it is present and B-GetMissing returns \nil{} otherwise. B-Assoc returns a new extended
map.

Typing rules are given in figure~\ref{main:figure:hmaptyping}. T-GetHMap handles the simple
case where we know a lookup will succeed and use B-Get. In T-GetHMapAbsent we know B-GetMissing will give
a \Nil{} return type.
T-GetHMapPartialDefault does not know if the key is present or absent and has a \Top{} return type.
T-Assoc extends the known keyword entries, overwriting previous entries with the same key.

S-HMap (figure~\ref{main:figure:hmapsubtype}) says that HMap subtypes must have all present entries to also be
subtypes and also cover the absent keys.
Complete maps are subtypes of partial maps by S-HMapP.

\subsection{Java Interoperability and Type Hints}

\begin{figure*}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \reflectiveexpsyntax{}
            \alt  \localhintsyntax{} \alt \lethintsyntax{}
    &\mbox{Expressions}
  \end{altgrammar}
  $$
  \caption{Java Interoperability Terms and Types}
  \label{main:figure:reflectivesyntax}
\end{figure*}

Clojure supports interoperability with Java, including the ability to
call constructors, methods and access fields. We model
these operations in a restricted setting without class inheritance,
overloading or Java Generics. 

We extend the external language with Java field lookups and calls to
methods and constructors (figure~\ref{main:figure:nonreflectivesyntax}).
There are no typing or evaluation rules for these syntaxes because
Typed Clojure must be convinced that Java interactions are \emph{non-reflective},
ie., are unambiguously resolved at compile-time. Programmers use
type hinted expressions (figure~\ref{main:figure:nonreflectivesyntax}) 
to help the compiler eliminate reflection.

\begin{figure*}
  \footnotesize
  $$
  \begin{altgrammar}
    \e{} &::=& \ldots \alt \mininonreflectiveexpsyntax{}
    &\mbox{Expressions}\\

    \v{} &::=& \ldots \alt {\classvalue{\classhint{}} {\overrightarrow {\classfieldpair{\fld{}} {\v{}}}}}
    &\mbox{Values} \\

    \tatypesyntax{}\\
    \typehintenvsyntax{}\\
    \classtableallsyntax{}
  \end{altgrammar}
  $$
  \caption{Internal Language Reflection Resolution Extensions}
  \label{main:figure:nonreflectivesyntax}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \RAbs{}

    \RNewElimRefl{}

    \RMethodElimRefl{}

    \RFieldElimRefl{}

    \RLet{}

    \RLetHint{}
  \end{mathpar}
\caption{Reflection Elimination (select rules, figure~\ref{appendix:figure:rewrite} for full rules)}
\label{main:figure:rewrite}
\end{figure*}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    \TALocal{}

    \TANil{}

    \TANewStatic{}

    \TALetHint{}

    \TALet{}
  \end{mathpar}
\caption{Type Hint Inference (select rules, figure~\ref{appendix:figure:hintinfer} for full rules)}
\label{main:figure:hintinfer}
\end{figure*}

\begin{figure}
  \footnotesize
  \begin{mathpar}
    \BField{}

    \BNew{}

    \BMethod{}
  \end{mathpar}
  \caption{Java Interoperability Semantics}
\end{figure}

\begin{figure*}
  \footnotesize
  \begin{mathpar}
    {\TNewStatic}

    {\TFieldStatic}
    {\TMethodStatic}
  \end{mathpar}
  \caption{Java Interoperability Typing Rules}
  \label{main:figure:javatyping}
\end{figure*}

Clojure supports \emph{type hints}, an optional type system to improve performance
and disambiguate Java calls.
Programmers communicate to the Clojure compiler via type hints
to resolve Java methods and prevent boxing in loops. Tags are propagated bidirectionally
and the programmer is free to add them where they like.

core.typed uses tools.analyzer to obtain a rich abstract syntax tree that includes resolved
reflection, however to tell the full story we include a rewrite relation 
in figure~\ref{main:figure:rewrite} to eliminate reflection when sufficient type hints are provided.
Figure~\ref{main:figure:hintinfer} shows the interesting cases in type hint inference.

We now have two languages: an internal language that may contain non-reflective Java calls (figure 
  \ref{main:figure:nonreflectivesyntax}) 
  and an external language that resembles Clojure, where we must rely on type-hints to resolve
  reflective Java calls (figure~\ref{main:figure:reflectivesyntax}).

For example, R-FieldElimRefl, which rewrites a reflective field call to be non-reflective,
rewrites the target expression and uses the result to infer a class type hint as the field target.
\fieldtypeliteral{} uses the inferred type hint to lookup if the inferred class has the appropriate
field name and returns the actual target and result type hints which we store in the rewritten rule.

We then extract these type hints in T-FieldStatic for typing checking 
(figure~\ref{main:figure:javatyping}), which converts type hints
with \javatotcliteral{} to obtain a \emph{non-nilable} type to type check the target expression (which prevents
dereferencing nil) and \javatotcnilliteral{} to get a \emph{nilable} return type (because fields can be nil).

Method and constructor calls are similar, but T-MethodStatic and T-NewStatic disallow passing \nil{} as arguments, 
we assume methods can return \nil{} and we assume constructors cannot.

We rewrite to our internal language before type checking and remaining reflective calls are type errors.

{\footnotesize
\input{constant}
\input{update}
}

{\convertjavatypefigure{figure}{\footnotesize}}
