We thank our reviewers for their feedback, including reports on
grammatical errors and typos. We address the major issues raised below.

Several reviewers suggest that the type system features presented do
not represent a significant improvement over prior work.

> A small step with respect to ICFP'10 (main reason for my overall 
> evaluation).

We will adjust presentation to make this clearer, but major
innovations include:

1) First, we demonstrate the importance of custom type system design
for bringing type systems to existing dynamically-typed
languages. This continues a tradition seen in systems such as
Strongtalk and Typed Racket, and more recently in Flow, Hack, and
TypeScript.

2) The synergy between multimethods and occurrence typing is far from
obvious. As a result, Typed Clojure can effectively typecheck
Clojure's highly-expressive multimethods by leveraging type system
features designed for other purposes, including multimethods using
*arbitrary* dispatch functions. See Example 13 for a notable instance.

3) Repurposing of *occurrence typing* to prevent null-pointer
exceptions in a JVM language is novel and widely applicable. Previous
systems have either
  1. allowed null pointers everywhere, as in Java, Scala, or OcamlJava, 
  2. relied on runtime boxing to Option/Maybe types (Frege), or
  3. tracked nullable types (Kotlin, Ceylon), but relied on ad-hoc rules 
     that ICFP'10 generalizes to a *compositional* and more expressive
     system.

More generally, we show how occurrence typing scales to
new features such as exceptional control flow and heterogenous maps
that are crucial to Clojure in practice.

> Many features discussed in Section 2 seem to be expressible in OCaml
  using polymorphic variants -- I miss technical comparison to
  polymorphic variants in OCaml.

Untagged union types in Typed Clojure are related to OCaml polymorphic
variants, however are not novel to this paper. Instead we argue our
comparison of HMaps to OCaml records is relevant, which reviewer C
correctly indicates is insufficient.

> I found this paper lacking in focus and sometimes forgetting to explain 
some basic things

We will omit irrelevant Clojure features such as 'ns' to help focus the paper and
explain relevant features. As the reviewer notes, multimethods and the 
interaction between type hints lack clear explanations.

> I also wonder how well type checking scales. 

Propositional satisfiability is NP-complete, and we rely on well-known 
optimisations (reiterated in ICFP'10) as well as recent Typed Racket 
innovations such as let-aliasing such that in practice, most code does 
not pay a significant performance penalty.

> Fig 6: No dissoc expression? How can empty maps be the only HMap values? 
> And why is there no typing rule for {} expressions?

For presentational purposes we chose not to model dissoc, and provide assoc 
and {} (whose typing rule is missing) as the only way to build non-empty
HMaps.
