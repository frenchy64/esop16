We thank our reviewers for their feedback, including reports on
grammatical errors and typos. We address the major issues raise below.

Several reviewers suggest that the type system features presented do
not represent a significant improvement over prior work.

> A small step with respect to ICFP'10 (main reason for
> my overall evaluation). For ICFP I found the ideas not original
> and innovative enough.

We will adjust presentation to make this clearer, but major
innovations include:

1) First, we demonstrate the importance of custom type system design
for bringing type systems to existing dynamically-typed
languages. This continues a tradition seen in systems such as
Strongtalk and Typed Racket, and more recently in Flow, Hack, and
TypeScript.

2) The synergy between multimethods and occurrence typing is far from
obvious. As a result, Typed Clojure can effectively typecheck
Clojure's highly-expressive multimethods by leveraging type system
features designed for other purposes, including functions using
*arbitrary* dispatch functions. See Example 13 for a notable instance.

3) Repurposing of *occurrence typing* to prevent null-pointer
exceptions in a JVM language is novel and widely applicable. Previous
systems have allowed null pointers everywhere, as in Java, Scala, or
OcamlJava, relied on runtime boxing to Option/Maybe types (Frege) or
ad-hoc rules based on conditional expressions (Kotlin,
Ceylon). Occurrence typing is *compositional* and more
expressive. More generally, we show how occurrence typing scales to
new features such as exceptional control flow and heterogenous maps
that are crucial to Clojure in practice.

> Many features discussed in Section 2 seem to be expressible in OCaml
  using polymorphic variants -- I miss technical comparison to
  polymorphic variants in OCaml.

Untagged union types in Typed Clojure are related to OCaml polymorphic
variants, however are not novel to this paper. Instead we argue our
comparison of HMaps to OCaml records is relevant, which reviewer C
correctly indicates is insufficient.

> OCaml also supports interoperability with Java.

We thank the reviewer for bringing this to our attention. On further
investigation, OCaml's Java interoperability uses nullable reference
types; in other words, it cannot statically prevent null-pointer
exceptions in OCaml, unlike Typed Clojure which prevents null-pointer
exceptions in typed code.

