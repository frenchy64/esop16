We thank our reviewers for their feedback, including reports on
grammatical errors and typos. We address the major issues raise below.

Several reviewers suggest that the type system features presented do
not represent a significant improvement over prior work.

> A small step with respect to ICFP'10 (main reason for my overall 
> evaluation).

We will adjust presentation to make this clearer, but major
innovations include:

1) First, we demonstrate the importance of custom type system design
for bringing type systems to existing dynamically-typed
languages. This continues a tradition seen in systems such as
Strongtalk and Typed Racket, and more recently in Flow, Hack, and
TypeScript.

2) The synergy between multimethods and occurrence typing is far from
obvious. As a result, Typed Clojure can effectively typecheck
Clojure's highly-expressive multimethods by leveraging type system
features designed for other purposes, including functions using
*arbitrary* dispatch functions. See Example 13 for a notable instance.

3) Repurposing of *occurrence typing* to prevent null-pointer
exceptions in a JVM language is novel and widely applicable. Previous
systems have allowed null pointers everywhere, as in Java, Scala, or
OcamlJava, relied on runtime boxing to Option/Maybe types (Frege) or
ad-hoc rules based on conditional expressions (Kotlin,
Ceylon). Occurrence typing is *compositional* and more
expressive. More generally, we show how occurrence typing scales to
new features such as exceptional control flow and heterogenous maps
that are crucial to Clojure in practice.

> Many features discussed in Section 2 seem to be expressible in OCaml
  using polymorphic variants -- I miss technical comparison to
  polymorphic variants in OCaml.

Untagged union types in Typed Clojure are related to OCaml polymorphic
variants, however are not novel to this paper. Instead we argue our
comparison of HMaps to OCaml records is relevant, which reviewer C
correctly indicates is insufficient.

> I found this paper lacking in focus and sometimes forgetting to explain 
some basic things

We will remove extraneous Clojure features to help focus the paper and
explain relevant features.

> I also wonder how well type checking scales. 

Propositional satisfiability is NP-complete, and we rely on well-known 
optimisations (reiterated in ICFP'10) as well as recent Typed Racket 
innovations such as let-aliasing such that in practice, most code does not pay
a significant performance penalty.

> Fig 6: No dissoc expression? How can empty maps be the only HMap values? 
> And why is there no typing rule for {} expressions?

For presentational purposes we chose not to model dissoc, and provide assoc 
and {} (whose typing rule is missing) as the only way to build non-empty
HMaps.
